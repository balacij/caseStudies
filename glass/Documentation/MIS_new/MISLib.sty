\usepackage{amsmath}
\usepackage{fullpage}
\usepackage{amsfonts}
\usepackage{xkeyval}
\usepackage{xparse}
\usepackage{ifthen}
\usepackage{xstring}
\usepackage{etoolbox}
\usepackage{graphicx}
\noexpandarg
\allowdisplaybreaks

\renewcommand\baselinestretch{1.0}

\pagestyle {plain}
\pagenumbering{arabic}

\setlength\parindent{0pt}
\setlength{\mathindent}{0pt}
\newlength{\mytextsize}
\setlength{\mytextsize}{\f@size pt}


\define@cmdkey [MIS] {module} {moduleType} {}
\define@cmdkey [MIS] {module} {moduleName} {}
\define@cmdkey [MIS] {module} {uses} {}
\define@cmdkey [MIS] {module} {exportedConstants} {}
\define@cmdkey [MIS] {module} {exportedTypes} {}
\define@cmdkey [MIS] {module} {exportedAccessPrograms} {}
\define@cmdkey [MIS] {module} {stateVariables} {}
\define@cmdkey [MIS] {module} {environmentVariables} {}
\define@cmdkey [MIS] {module} {assumptions} {}
\define@cmdkey [MIS] {module} {accessRoutineSemantics} {}
\define@cmdkey [MIS] {module} {localFunctions} {}

\define@cmdkey [MIS] {routine} {routineName} {}
\define@cmdkey [MIS] {routine} {routineArgs} {}
\define@cmdkey [MIS] {routine} {transition} {}
\define@cmdkey [MIS] {routine} {output} {}
\define@cmdkey [MIS] {routine} {exception} {}

\define@cmdkey [MIS] {local} {functionName} {}
\define@cmdkey [MIS] {local} {functionIn} {}
\define@cmdkey [MIS] {local} {functionOut} {}
\define@cmdkey [MIS] {local} {functionBody} {}

\newcommand{\module}[2]{
  \setkeys[MIS]{module}{#2}
  \@moduletitle{#1}
  \@moduletype{\cmdMIS@module@moduleType}{\cmdMIS@module@moduleName}
  \@uses{\cmdMIS@module@uses}
  \@syntax
  \expandafter\@constants\expandafter{\cmdMIS@module@exportedConstants}
  \expandafter\@types\expandafter{\cmdMIS@module@exportedTypes}
  \expandafter\@accessprogs\expandafter{\cmdMIS@module@exportedAccessPrograms}
  \@semantics
  \expandafter\@statevars\expandafter{\cmdMIS@module@stateVariables}
  \expandafter\@envvars\expandafter{\cmdMIS@module@environmentVariables}
  \expandafter\@assumptions\expandafter{\cmdMIS@module@assumptions}
  \expandafter\@arsemantics\expandafter{\cmdMIS@module@accessRoutineSemantics}
  \expandafter\@localfunctions\expandafter{\cmdMIS@module@localFunctions}
  \newpage
}

\newcommand{\@routine}[1]{
  \setkeys[MIS]{routine}{#1}
  \cmdMIS@routine@routineName(\cmdMIS@routine@routineArgs):
  \begin{itemize}
  \item transition: 
  \item[] \expandafter\@artransition\expandafter{\cmdMIS@routine@transition}
  \item output:
  \item[] \expandafter\@aroutput\expandafter{\cmdMIS@routine@output}
  \item exception: 
  \item[] \expandafter\@arexception\expandafter{\cmdMIS@routine@exception}
  \end{itemize}
}

\NewDocumentCommand{\@localFunction}{m}{
  \setkeys[MIS]{local}{#1}
  \cmdMIS@local@functionName~: $\expandafter\@functionInTypes\expandafter{\cmdMIS@local@functionIn} \rightarrow \cmdMIS@local@functionOut$\\
  \cmdMIS@local@functionName($\expandafter\@functionInNames\expandafter{\cmdMIS@local@functionIn}$)~$\equiv \cmdMIS@local@functionBody$\\[\mytextsize]
}

% -------------- SECTION CREATION ----------------------------------------------
\newcommand{\@moduletitle}[1]{
  \section*{#1 Module}
}

\newcommand{\@moduletype}[2]{
  \subsection*{\ifthenelse{\equal{#1}{}}{}{#1 }Module}
  #2
}

\newcommand{\@uses}[1]{
  \subsection*{Uses}
  \ifthenelse{\equal{#1}{}}
    { N/A }
    { \@@uses{#1} }
}

\newcommand{\@syntax}{ 
  \subsection* {Syntax}
}

\newcommand{\@constants}[1]{
  \subsubsection*{Exported Constants}
  \ifthenelse{\equal{#1}{}}
    { N/A }
    { \@@constants{#1} }
}

\newcommand{\@types}[1]{
  \subsubsection*{Exported Types}
  \ifthenelse{\equal{#1}{}}
    { N/A }
    { \@@types{#1} }
}

\newcommand{\@accessprogs}[1]{
  \subsubsection*{Exported Access Programs}
  \ifthenelse{\equal{#1}{}}
    { N/A }
    { \@@accessprogs{#1} }
}

\newcommand{\@semantics}{
  \subsection* {Semantics}
}

\newcommand{\@statevars}[1]{
  \subsubsection*{State Variables}
  \ifthenelse{\equal{#1}{}}
    { N/A }
    { \@@statevars{#1} }
}

\newcommand{\@envvars}[1]{
  \subsubsection*{Environment Variables}
  \ifthenelse{\equal{#1}{}}
    { N/A }
    { \@@statevars{#1} }
}

\NewDocumentCommand{\@assumptions}{ >{ \SplitList {,} } m }{
  \subsubsection*{Assumptions}
  \ifthenelse{\equal{#1}{{}}}
    { N/A }
    { 
      \begin{itemize}
      \ProcessList {#1} {\item } 
      \end{itemize}
    }
}

\NewDocumentCommand{\@arsemantics}{m}{
  \subsubsection*{Access Routine Semantics}
  \ifthenelse{\equal{#1}{}}
    { N/A }
    { \ProcessList {#1} {\@routine} }
}

\NewDocumentCommand{\@localfunctions}{m}{
  \subsubsection*{Local Functions}
  \ifthenelse{\equal{#1}{}}
    { N/A }
    { \ProcessList {#1} {\@localFunctionPrep} }
}

\NewDocumentCommand{\@localFunctionPrep}{m}{
  \StrSubstitute{#1}{ }{}[\temp]
  \expandarg
  \StrLeft{\temp}{1}[\temp]
  \expandafter\ifdefmacro\expandafter{\temp}
  { 
    \edef\temp{#1}
    \expandarg
    \IfBeginWith{\temp}{ }{\StrGobbleLeft{\temp}{1}[\temp]}{}
    \noexpandarg
    \expandafter\@localFunction\expandafter{\temp}
  }
  { \@localFunction{#1} }
}


% -------------- INTERNALS -----------------------------------------------------

\NewDocumentCommand{\@@uses}{ >{ \SplitList {,} } m }{ 
  \ProcessList { #1 } { \@use } 
  \vspace{-\baselineskip}
}

\newcommand\@use[1]{
  #1\\
}

\NewDocumentCommand{\@@constants}{ >{ \SplitList {;} } m}{
  \begin{tabular}{| l | l | l |}
    \hline
    \textbf{Constant name} & \textbf{Type} & \textbf{Value}\\
    \hline
    \ProcessList { #1 } { \@newrow }
  \end{tabular}
}

\NewDocumentCommand{\@@types}{ >{ \SplitList {;} } m}{
  \begin{tabular}{| l | l |}
    \hline
    \textbf{Type name} & \textbf{Type}\\
    \hline
    \ProcessList { #1 } { \@newrow }
  \end{tabular}
}

\NewDocumentCommand{\@@accessprogs}{ >{ \SplitList {;} } m}{
  \begin{tabular}{| l | l | l | l |}
    \hline
    \textbf{Routine name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions}\\
    \hline
    \ProcessList { #1 } { \@newrow }
  \end{tabular}
}

\NewDocumentCommand{\@newrow}{m}{
  \StrSubstitute{#1}{,}{&}[\temp]
  \temp\\
  \hline
}

\NewDocumentCommand{\@@statevars}{ >{ \SplitList {;} } m}{
  \begin{tabular}{| l | l |}
    \hline
    \textbf{Variable name} & \textbf{Type}\\
    \hline
    \ProcessList { #1 } { \@newrow }
  \end{tabular}
}

\NewDocumentCommand{\@artransition}{ >{ \SplitList {;} } m}{
  \ifthenelse{\equal{#1}{{}}}
  { N/A }
  { \vspace{-2\baselineskip}
    \begin{alignat*}{2}
    \ProcessList { #1 } {\@neweqn}
    \end{alignat*}
    \vspace{-2\baselineskip}
  }
}

\NewDocumentCommand{\@neweqn}{m}{
  \StrSubstitute{#1}{#1}{;#1}[\temp]
  \expandarg
  \StrSubstitute{\temp}{,}{;;:=}[\temp]
  \StrSubstitute{\temp}{;}{&}[\temp]
  \noexpandarg
  \temp\\
}

\NewDocumentCommand{\@aroutput}{m}{
  \ifthenelse{\equal{#1}{}}
  { N/A }
  { \vspace{-2\baselineskip}
    \begin{alignat*}{2}
    \@neweqn{out, #1}
    \end{alignat*}
    \vspace{-2\baselineskip}
  }
}

\NewDocumentCommand{\@arexception}{m}{
  \ifthenelse{\equal{#1}{}}
  { N/A }
  { \vspace{-2\baselineskip}
    \begin{alignat*}{2}
    \@neweqn{exc, #1}
    \end{alignat*}
    \vspace{-2\baselineskip}
  }
}

\NewDocumentCommand{\@functionInTypes}{m}{
  \StrCount{#1}{;}[\temp]
  \ifthenelse{\equal{\temp}{0}}
  {
    \StrBehind{#1}{,}[\temp]
    \temp
  }
  {
    \StrBefore{#1}{;}[\temp]
    \expandarg
    \StrBehind{\temp}{,}[\temp]
    \temp \times
    \noexpandarg
    \StrBehind{#1}{;}[\temp]
    \expandafter\@functionInTypes\expandafter{\temp}
  }
}

\NewDocumentCommand{\@functionInNames}{m}{
  \StrCount{#1}{;}[\temp]
  \ifthenelse{\equal{\temp}{0}}
  {
    \StrBefore{#1}{,}[\temp]
    \temp
  }
  {
    \StrBefore{#1}{;}[\temp]
    \expandarg
    \StrBefore{\temp}{,}[\temp]
    \temp,~
    \noexpandarg
    \StrBehind{#1}{;}[\temp]
    \expandafter\@functionInNames\expandafter{\temp}
  }
}


\NewDocumentCommand{\conditional}{m}{
  \noexpandarg
  \StrSubstitute{#1}{#1}{@#1}[\temp]
  \expandarg
  \StrSubstitute{\temp}{;}{\\;}[\temp]
  \StrSubstitute{\temp}{,}{;;\implies}[\temp]
  \StrSubstitute{\temp}{@}{;}[\temp]
  \StrSubstitute{\temp}{;}{&}[\temp]
  \noexpandarg
  \begin{cases}
  \begin{alignedat}{2}
  \temp\\
  \end{alignedat}
  \end{cases}
}

\newcounter{@setcount}
\newcounter{@setmax}

\NewDocumentCommand{\finset}{o >{ \SplitList {,} } m}{
  \expandarg
  \setcounter{@setcount}{1}
  \IfNoValueTF{#1}{\setcounter{@setmax}{3}}{\setcounter{@setmax}{#1}}
  \left\{\begin{alignedat}{\the@setmax}
  \ProcessList{#2}{\@setelt}
  \end{alignedat}\right\}
  \noexpandarg
}

\NewDocumentCommand{\@setelt}{m}{
  \ifthenelse{\equal{\the@setcount}{\the@setmax}}
  {
    &#1,
    \setcounter{@setcount}{0}
  }
  { \ifthenelse{\equal{\the@setcount}{0}}
    { 
      \\
      \stepcounter{@setcount}
      \@setelt{#1}
    }
    { 
      &#1,~& 
      \stepcounter{@setcount}
    }
  }
}


\newcommand*\bigcdot{\mathpalette\bigcdot@{.7}}
\newcommand*\bigcdot@[2]{\mathbin{\vcenter{\hbox{\scalebox{#2}{$\m@th#1\bullet$}}}}}


% -------------- TYPES ---------------------------------------------------------
\newcommand{\real}{\ensuremath{\mathbb{R}}}

\newcommand{\bool}{\ensuremath{\mathbb{B}}}

\newcommand{\functype}[2]{\ensuremath{(#1 \rightarrow #2)}}

\NewDocumentCommand{\seq}{om}{\ensuremath{\textrm{sequence \IfNoValueF{#1}{[#1] }of }#2}}


% -------------- VALUES --------------------------------------------------------
\NewDocumentCommand{\seqval}{m}{
  \ensuremath{\langle #1 \rangle}
}

\define@cmdkey [MIS] {seqbuild} {newElement} {}
\define@cmdkey [MIS] {seqbuild} {variable} {}
\define@cmdkey [MIS] {seqbuild} {inputList} {}
\define@cmdkey [MIS] {seqbuild} {predicate} {}

\NewDocumentCommand{\seqbuild}{m}{
  \setkeys[MIS]{seqbuild}{#1}
  \ifthenelse{\equal{\cmdMIS@seqbuild@predicate}{}}
  {\ensuremath{\langle~\cmdMIS@seqbuild@newElement~|~\cmdMIS@seqbuild@variable\leftarrow\cmdMIS@seqbuild@inputList~\rangle}}
  {\ensuremath{\langle~\cmdMIS@seqbuild@newElement~|~\cmdMIS@seqbuild@variable\leftarrow\cmdMIS@seqbuild@inputList~\bigcdot~\cmdMIS@seqbuild@predicate~\rangle}}
}

\newcommand{\str}[1]{
  \ensuremath{\textrm{``#1"}}
}

\newcommand{\emptystr}{
  \ensuremath{\textrm{``"}}
}

\newcommand{\realzero}{
  \ensuremath{0.0}
}

\newcommand{\true}{
  \ensuremath{\textrm{True}}
}

\newcommand{\self}{
  \ensuremath{\textrm{self}}
}

\newcommand{\fsread}{
  \ensuremath{\textrm{FileSystem Read}}
}

\newcommand{\seqAt}[2]{
  \ensuremath{#1[#2]}
}

\newcommand{\AND}{
  \ensuremath{\wedge}
}

\newcommand{\OR}{
  \ensuremath{\vee}
}

\newcommand{\exc}[1]{
  \ensuremath{\textrm{#1}}
}

\newcommand{\fapp}[2]{
  \ensuremath{\textrm{#1}(#2)}
}


% COMMON LOCAL FUNCTIONS

\newcommand{\@localmap}[2]{
  functionName = map ,
  functionIn = {
    f , \noexpand\functype{#1}{#2} ;
    \noexpand\ell , \noexpand\seq{#1}
  },
  functionOut = \noexpand\seq{#2},
  functionBody = \noexpand\seqbuild{
    variable = x ,
    newElement = \noexpand\fapp{f}{x} ,
    inputList = \noexpand\ell ,
    predicate =
  }
}

\newcommand{\@localfilter}[1]{
  functionName = filter ,
  functionIn = {
    p , \noexpand\functype{#1}{\noexpand\bool} ;
    \noexpand\ell , \noexpand\seq{#1}
  },
  functionOut = \noexpand\seq{#1},
  functionBody = \noexpand\seqbuild{
    variable = x ,
    newElement = x ,
    inputList = \noexpand\ell ,
    predicate = \noexpand\fapp{p}{x}
  }
}

\newcommand{\localmap}[2]{\@localmap{\noexpand#1}{\noexpand#2}}
\newcommand{\localfilter}[1]{\@localfilter{\noexpand#1}}