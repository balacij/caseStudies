\documentclass[12pt]{article}

\usepackage{bm} 
\usepackage[all]{nowidow}
\usepackage{amsmath, mathtools} 
\usepackage{amsfonts}
\usepackage{amssymb} 
\usepackage{graphicx} 
\usepackage{colortbl}
\usepackage{xr} 
\usepackage{hyperref} 
\usepackage{array}
\usepackage{longtable} 
\usepackage{xfrac} 
\usepackage{tabularx} 
\usepackage{float} 
\usepackage{siunitx} 
\usepackage{booktabs} 
\usepackage{multirow} 
\usepackage[section]{placeins}
\usepackage{xcolor} 
\usepackage{multicol} 
\usepackage{caption}
\usepackage{enumitem}
\usepackage{underscore}
\usepackage{threeparttablex}

%\usepackage{refcheck}

\hypersetup{ bookmarks=true, % show bookmarks bar?  
colorlinks=true, %false: boxed links; true: coloured links 
linkcolor=red, % color of internal links (change box color with 
%linkbordercolor)
citecolor=green, % color of links to bibliography 
filecolor=magenta, %color of file links 
urlcolor=cyan % color of external links 
}

\newcommand{\colZwidth}{1.0\textwidth} \newcommand{\blt}{- } 
\newcommand{\colAwidth}{0.13\textwidth}
\newcommand{\colBwidth}{0.82\textwidth}
\newcommand{\colCwidth}{0.1\textwidth}
\newcommand{\colDwidth}{0.05\textwidth}
\newcommand{\colEwidth}{0.8\textwidth}
\newcommand{\colFwidth}{0.17\textwidth}
\newcommand{\colGwidth}{0.5\textwidth}
\newcommand{\colHwidth}{0.28\textwidth}
\newcommand{\colDescrip}{0.63\textwidth}
\newcommand{\funcPadding}{1.3}
\newcommand{\newfunc}{\\[1.5em]}
\newcommand{\inquote}[1]{``{#1}"}

\newcommand{\progname}{Chipmunk2D }
\newcommand{\vor}{$\vee$ }
\newcommand{\B}{$\mathbb{B}$}
\newcommand{\R}{$\mathbb{R}$}
\newcommand{\Z}{$\mathbb{Z}$}
\newcommand{\UZ}{$\mathbb{Z}^+$}

\newcounter{nmnum} \newcommand{\nmthenmnum}{NM\thenmnum}
\newcommand{\nmref}[1]{NM\ref{#1}}

\newcommand{\un}{\si{unitless}}
\newcommand{\du}{\si{data unit}}

\setitemize{itemsep=0pt}

\externaldocument[SRS-]{../SRS/GamePhysicsSRS}
\externaldocument[MG-]{../MG/GamePhysicsMG}

% define "struts", as suggested by Claudio Beccari in 
% a piece in TeX and TUG News, Vol. 2, 1993.  
\newcommand{\Tstrut}{\rule{0pt}{2.6ex}} %= `top' strut

%\oddsidemargin 0mm %\evensidemargin 0mm %\textwidth 160mm
%\textheight 200mm 
\usepackage{fullpage}

\newcommand{\blue}[1]{\textcolor{blue}{#1}}
\newcommand{\green}[1]{\textcolor{black!40!green}{#1}}

%% Comments 

\newif\ifcomments\commentstrue

\ifcomments \newcommand{\authornote}[3]{\textcolor{#1}{[#3 ---#2]}}
\newcommand{\todo}[1]{\textcolor{red}{[TODO: #1]}} \else
\newcommand{\authornote}[3]{} \newcommand{\todo}[1]{} \fi

\newcommand{\wss}[1]{\authornote{magenta}{SS}{#1}}
\newcommand{\hcf}[1]{\authornote{yellow}{HF}{#1}}
\newcommand{\cjl}[1]{\authornote{green!60!black}{CL}{#1}}

\newcolumntype{x}[1]{>{\raggedright\arraybackslash}m{#1}}
\newcolumntype{y}{>{\raggedright\arraybackslash}l}

\newcommand{\Body}{\hyperref[MISBody]{Rigid Body Module}}
\newcommand{\Shape}{\hyperref[MISShape]{Shape Module}}
\newcommand{\Circle}{\hyperref[MISCircle]{Circle Module}}
\newcommand{\Segment}{\hyperref[MISSegment]{Segment Module}}
\newcommand{\Poly}{\hyperref[MISPoly]{Polygon Module}}
\newcommand{\Space}{\hyperref[MISSpace]{Space Module}}
\newcommand{\Arbiter}{\hyperref[MISArbiter]{Arbiter Module}}
\newcommand{\Control}{\hyperref[MISControl]{Control Module}}
\newcommand{\Vector}{\hyperref[MISVector]{Vector Module}}
\newcommand{\BB}{\hyperref[MISBB]{Bounding Box Module}}
\newcommand{\Transform}{\hyperref[MISTransform]{Transform Matrix Module}}
\newcommand{\SpatialIndex}{\hyperref[MISSpatial]{Spatial Index Module}}
\newcommand{\Collision}{\hyperref[MISCollision]{Collision Solver Module}}
\newcommand{\Sequence}{\hyperref[MISSequence]{Sequence Data Structure Module}}
\newcommand{\Linked}{\hyperref[MISLinked]{Linked Data Structure Module}}
\newcommand{\Assoc}{\hyperref[MISAssoc]{Associative Data Structure Module}}

\begin{document}

\title{Module Interface Specification for Chipmunk2D Game Physics Library} \author{Luthfi Mawarid}
\date{\today}

\maketitle

\tableofcontents

\section{Introduction} \label{SecIntro}

The following document details the Module Interface
Specifications for the implemented modules in the \progname Game Physics Library.  It is intended to ease navigation through the program for design and
maintenance purposes.  Complementary documents include the System
Requirement Specifications and Module Guide.

\section{Notation} \label{SecNotation}

\progname uses six primitive data types: Booleans, characters, double-precision floating-point numbers (doubles), as well as signed and unsigned integers. These data types are summarized in the following table. The table lists the name of the 
data type, its notation, and a description of an element of the data type. 

\renewcommand*{\arraystretch}{1.2}
\noindent  \begin{longtable}{l l p{10.5cm}} 
\toprule 
\textbf{Data Type} & \textbf{Notation} & \textbf{Description} \\ 
\midrule
Boolean & $\mathbb{B}$ & An element of \{true, false\}. \\
Character & char & A single symbol or digit. \\
Double & $\mathbb{R}$ & Any number in (-$\infty$, $\infty$). \\
Integer & $\mathbb{Z}$ & A number without a fractional
  component in (-$\infty$, $\infty$). \\
Unsigned integer & $\mathbb{Z}^+$ & A number without a fractional
  component in $[0, \infty)$. \\
\bottomrule
\end{longtable} 

\noindent \progname also uses non-primitive data types such as arrays (not to be confused with the Array object of the \Sequence), enumerations, pointers (references), strings, structures, unions. These are summarized in the following table.

\renewcommand*{\arraystretch}{1.2}
\noindent \begin{longtable}{l l p{9.5cm}}
\toprule
	\textbf{Data Type} & \textbf{Notation} & \textbf{Description} \\
\midrule
	Array & array(\textit{T}) & A list of a given data type \textit{T}. \\
	Enumeration & enum & A data type containing named, constant values. \\
	Pointer & \textit{T}* & A reference to an object of data type \textit{T}. \\
	String & string/array(char) & An array of characters. \\
	Structure & struct & A data type that can store multiple fields of different data types in one variable. \\
	Union & union & Similar to a structure, but only one field can contain a value at any given time. \\
	\bottomrule
\end{longtable}

\noindent Finally, \progname uses two more important type-related concepts: void and function pointers. Void is not a data type in itself; however, functions that do not return any value are assigned a return type of void, and void pointers, denoted by void*, are used for references to objects of an unspecified data type. \progname also allows passing functions to other functions through the use of function pointers, which hold references to function definitions. Each function pointer is denoted by the name of their function type and is defined by a specific function signature, such as: 
$$\text{Function Type} : \text{Arg}_1 \times \text{Arg}_2 \times ... \times \text{Arg}_n \to \text{Return Type}$$
For example, an inequality operator would have the signature \inquote{Inequality : $\mathbb{R} \times \mathbb{R} \to \mathbb{B}$}.

\iffalse

\section{Table of Symbols}

In addition to the table of symbols in Section 
\ref{SRS-TblOfSym} of the SRS, the following table outlines the 
symbols that are used in this document. All other tables are sorted alphanumerically, with Greek alphabets following English alphabets. 

\renewcommand*{\arraystretch}{1.2}
\noindent 
\begin{longtable}{l l p{12cm}} 
\toprule 
\textbf{Symbol} & \textbf{Unit} & \textbf{Description}\\ \midrule
\bottomrule 
\end{longtable} 

\section{Numerical Methods} \label{SecNumMethods}

This section outlines the numerical methods that
are needed in order to fulfill the program requirements and further
connect the abstract and ambiguous to the concrete and explicit. 

\fi

\section{Module Hierarchy} 

To view the Module Hierarchy, please refer to the Module Hierarchy section of the MG.

%%%%%%%%%%%%%%%%%%%% RIGID BODY MODULE %%%%%%%%%%%%%%%%%%%%%%%

\section{MIS of the Rigid Body Module} \label{MISBody}

\subsection{Module Name: Body} 

\subsection{Uses} \label{SecUBody}
	\Shape, \Space, \Arbiter, \Control, \Vector, \Transform, \SpatialIndex, \Sequence
	
\subsection{Interface Syntax}

%\subsubsection{Exported Constants}
%\subsubsection{Exported Variables}

\subsubsection{Exported Data Types} \label{SecEDTBody}
	BodyType: enum \\
	Body: struct \\
	PositionFunc : Body* $\times$ $\mathbb{R} \to$ void \\
	VelocityFunc : Body* $\times$ Vector $\times$ $\mathbb{R} \to$ void \\
	ShapeIteratorFunc : Body* $\times$ Shape* $\times$ void* $\to$ void \\
	ArbiterIteratorFunc : Body* $\times$ Shape* $\times$ void* $\to$ void 
	
\subsubsection{Exported Access Programs} \label{SecEAPBody}
	\renewcommand*{\arraystretch}{1.2}
	\begin{longtable}{| y | x{3.5cm} | y | x{3.5cm} |}
		\hline \textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions} \\ \hline 
		bodyAlloc & - & Body* & - \\ \hline
		bodyInit & Body*, double, double & Body* & - \\ \hline
		newBody & double, double & Body* & NaNMass \vor NaNMoment \vor NegativeMass \vor NegativeMoment \vor InfiniteMass \\ \hline
		newStaticBody & - & Body* & - \\ \hline
		bodyDestroy & Body* & - & - \\ \hline
		bodyGetType & Body* & BodyType & - \\ \hline
		bodyAccumulateMassFromShapes & Body* & - & IllegalBody \\ \hline
		bodyGetSpace & Body* & Space* & - \\ \hline
		bodyGetMass & Body* & double & - \\ \hline
		bodyGetMoment & Body* & double & - \\ \hline
		bodyGetRotation & Body* & Vector & - \\ \hline
		bodyGetPosition & Body* & Vector & - \\ \hline
		bodyGetCenterOfMass & Body* & Vector & - \\ \hline
		bodyGetVelocity & Body* & Vector & - \\ \hline
		bodyGetForce & Body* & Vector & - \\ \hline
		bodyGetAngle & Body* & double & - \\ \hline
		bodyGetAngularVelocity & Body* & double & - \\ \hline
		bodyGetTorque & Body* & double & - \\ \hline
		bodySetType & Body*, BodyType & - & IllegalBody \\ \hline
		bodySetMass & Body*, double & - & StaticBodyMass \vor NegativeMass \vor InfiniteMass \\ \hline
		bodySetMoment & Body*, double & - & NegativeMoment \\ \hline
		bodySetPosition & Body*, Vector & - & IllegalBody \\ \hline
		bodySetCenterOfMass & Body*, Vector & - & IllegalBody \\ \hline
		bodySetVelocity & Body*, Vector & - & IllegalBody \\ \hline
		bodySetForce & Body*, Vector & - & IllegalBody \\ \hline
		bodySetAngle & Body*, double & - & IllegalBody \\ \hline
		bodySetAngularVelocity & Body*, double & - & IllegalBody \\ \hline
		bodySetTorque & Body*, double & - & IllegalBody \\ \hline
		bodySetPositionFunc & Body*, PositionFunc & - & - \\ \hline
		bodySetVelocityFunc & Body*, VelocityFunc & - & - \\ \hline
		bodyAddShape & Body*, Shape* & - & - \\ \hline
		bodyRemoveShape & Body*, Shape* & - & - \\ \hline
		bodyUpdatePosition & Body*, double & - & IllegalBody \\ \hline
		bodyUpdateVelocity & Body*, Vector, double & - & IllegalBody \\ \hline
		bodyKineticEnergy & Body* & double & - \\ \hline
		bodyEachShape & Body*, ShapeIteratorFunc, void* & - & - \\ \hline
		bodyEachArbiter & Body*, ArbiterIteratorFunc, void* & - & - \\ \hline
	\end{longtable} 
	
\subsection{Interface Semantics}

\subsubsection{State Variables} \label{SecSVBody}
	\textbf{BodyType} $\in$ \{DYNAMIC_BODY, STATIC_BODY\} \\ 
	\newline
	\textbf{Body:} 
	 \begin{multicols}{3}
		\noindent type: BodyType \\
		positionFunc: PositionFunc \\
		velocityFunc: VelocityFunc \\
		mass: \R \\
		massInv: \R \\
		moment: \R \\
		momentInv: \R \\
		com: Vector \\
		pos: Vector \\
		vel: Vector \\
		force: Vector \\
		angle: \R \\
		avel: \R \\
		torque: \R \\
		velBias: Vector \\
		avelBias: \R \\
		transform: Transform \\
		space: Space* \\
		shapeList: Shape* \\
		arbiterList: Arbiter* 
	\end{multicols}
	
\subsubsection{State Invariant} \label{SecSIBody}
	For dynamic bodies, the following invariants apply. Any value in $\mathbb{R}$ means that it must be a valid and finite real number: 
	\begin{itemize}
	\item Body.mass $\in [0, \infty)$ 
	\item Body.moment $\in [0, \infty)$ 
	\item $|\text{Body.pos.x}| \in \mathbb{R} \wedge |\text{Body.pos.y}| \in \mathbb{R}$ 
	\item $|\text{Body.vel.x}| \in \mathbb{R} \wedge |\text{Body.vel.y}| \in \mathbb{R}$ 	
	\item $|\text{Body.force.x}| \in \mathbb{R} \wedge |\text{Body.force.y}| \in \mathbb{R}$ 
	\item $|\text{Body.angle}| \in \mathbb{R}$  
	\item $|\text{Body.avel}| \in \mathbb{R}$  
	\item $|\text{Body.torque}| \in \mathbb{R}$
	\end{itemize}
	
\subsubsection{Assumptions} \label{SecABody}
	bodyAlloc, or newBody, or newStaticBody are called before any other access program. All input pointers are also assumed to be non-null.

\subsubsection{Access Program Semantics} \label{SecAPSBody}

\renewcommand*{\arraystretch}{\funcPadding}
\begin{longtable*}{@{} p{3.3cm} l p{\colDescrip}} 
\textbf{bodyAlloc:} & \textbf{Input:} & None. \\
& \textbf{Exceptions:} & None.\\
& \textbf{Transition:} & None. \\
& \textbf{Output:} & bodyAlloc heap-allocates a new Body object and returns a pointer to it as output. \newfunc

\textbf{bodyInit:} & \textbf{Input:} & bodyInit accepts a Body pointer and two double values as inputs. \\
& \textbf{Exceptions:} & None.\\
& \textbf{Transition:} & bodyInit allocates a new Body and initializes its mass and moment with the input values. Other fields are zero-initialized and kinematic functions are set to default ones. \\
& \textbf{Output:} & bodyInit returns a pointer to the initialized Body.\newfunc

\textbf{newBody:} & \textbf{Input:} & newBody accepts two double values as inputs. \\
& \textbf{Exceptions:} & newBody may throw a NaNMass, NaNMoment, NegativeMass or NegativeMoment exception when the user provides NaN or negative values for input, or an InfiniteMass exception when the user provides an infinite value for the first input double. \\
& \textbf{Transition:} & newBody will allocate a new Body, initialize it with the input and default values, and set it to a dynamic body. \\
& \textbf{Output:} & newBody returns a pointer to the new Body. \newfunc  \pagebreak %stylebreak

\textbf{newStaticBody:} & \textbf{Input:} & None. \\
& \textbf{Exceptions:} & None.\\
& \textbf{Transition:} & newStaticBody creates a new Body and sets it to a static body. \\
& \textbf{Output:} & newStaticBody returns a pointer to the new Body. \newfunc
	
\textbf{bodyDestroy:} & \textbf{Input:} & bodyDestroy accepts a Body pointer. \\
& \textbf{Exceptions:} & None.\\
& \textbf{Transition:} & bodyDestroy frees the input Body object.\\
& \textbf{Output:} & None. \newfunc

\textbf{bodyGet:} & \textbf{Input:} & Each bodyGet function accepts a Body pointer as input.  \\
& \textbf{Exceptions:} & None.\\
& \textbf{Transition:} & None. \\
& \textbf{Output:} & Each bodyGet function returns the value of their corresponding parameter.\newfunc

\textbf{bodySet:} & \textbf{Input:} & Each bodySet function accepts a Body pointer and their corresponding value as inputs.  \\
& \textbf{Exceptions:} & Various, see Section \ref{SecEAPBody}. The IllegalBody exception occurs when any invariant in \ref{SecSIBody} is violated. \\
& \textbf{Transition:} & Each bodySet function will modify the state of their corresponding parameter to the input value, if valid. bodySetMass and bodySetMoment will also modify the inverse values of the parameters. bodySetType will reset the Body's mass, moment and velocities if changed to a static type, or recalculate its mass from attached Shapes if changed to a dynamic type. It also updates any associated Space accordingly. \\
& \textbf{Output:} & None. \newfunc

\textbf{bodyAccumulate Mass FromShapes} & \textbf{Input:} & bodyAccumulateMassFromShapes accepts a Body pointer as input. \\
& \textbf{Exceptions:} & bodyAccumulateMassFromShapes may throw an IllegalBody exception if the Body violates any invariant in \ref{SecSIBody} after the transition is complete. \\
& \textbf{Transition:} & The function recalculates the mass, moment and centre of mass of the Body based on the masses, moments and centres of mass of Shapes associated with it. It will modify the mass and moment inverses accordingly, realign the Body's position in Space, and check that it satisfies all invariants. \\
& \textbf{Output:} & None. \newfunc

\textbf{bodyAddShape:} & \textbf{Input:} & bodyAddShape accepts a Body pointer and a Shape pointer as inputs. \\
& \textbf{Exceptions:} & None.\\
& \textbf{Transition:} & The function will add the input Shape to the input Body's list of Shapes and recalculate the Body's mass accordingly. \\
& \textbf{Output:} & None. \newfunc

\textbf{bodyRemove Shape:} & \textbf{Input:} & bodyRemoveShape accepts a Body pointer and a Shape pointer as inputs. \\
& \textbf{Exceptions:} & None.\\
& \textbf{Transition:} & The function will remove the input Shape from the Body's list of Shapes and, if the Body is dynamic, recalculate its mass accordingly. \\
& \textbf{Output:} & None. \newfunc

\textbf{bodyUpdate Position:} & \textbf{Input:} & bodyUpdatePosition accepts a Body pointer and a double value as inputs. \\
& \textbf{Exceptions:} & bodyUpdatePosition may throw an IllegalBody exception if the Body violates any invariant in \ref{SecSIBody} after the transition is complete. \\
& \textbf{Transition:} & bodyUpdatePosition will update the Body's position and angle based on its linear and angular velocities, respectively, their bias values, and the timestep, which is the second input value. It then resets the bias values and checks if any invariant has been violated. \\
& \textbf{Output:} & None. \newfunc

\textbf{bodyUpdate Velocity:} & \textbf{Input:} & bodyUpdateVelocity accepts a Body pointer, a Vector and a double value as its input. \\
& \textbf{Exceptions:} & bodyUpdateVelocity may throw an IllegalBody exception if the Body violates any invariant in \ref{SecSIBody} after the transition is complete. \\
& \textbf{Transition:} & bodyUpdateVelocity will update the Body's velocities using the input gravity Vector, forces and torques applied, and the input double value for the timestep. At the end, it resets the Body's force and torque and checks if any invariants have been violated.  \\
& \textbf{Output:} & None. \newfunc

\textbf{bodyKinetic Energy:} & \textbf{Input:} & bodyKineticEnergy accepts a Body pointer as input. \\
& \textbf{Exceptions:} & None.\\
& \textbf{Transition:} & bodyKineticEnergy will calculate the Body's kinetic energy based on its mass, moment, and linear and angular velocities. \\
& \textbf{Output:} & bodyKineticEnergy returns a double value representing the kinetic energy. \newfunc

\textbf{bodyEach:} & \textbf{Input:} & Each bodyEach function accepts a Body pointer, a function pointer to the corresponding iterator, and a void pointer as inputs. \\
& \textbf{Exceptions:} & None.\\
& \textbf{Transition:} & Each bodyEach function will iterate through the Body's Shapes or Arbiters, depending on the function's corresponding parameter, and apply the input function to each object in the list, using the data (void pointer) from the third input value. \\
& \textbf{Output:} & None.  \newfunc
\end{longtable*} 

\subsubsection{Local Functions} \label{SecLFBody}

\renewcommand*{\arraystretch}{\funcPadding}
\begin{longtable*}{@{} p{2.6cm} l p{\colDescrip}} 
\textbf{vectAssert NaN:} & \textbf{Input: } & vectAssertNaN accepts a Vector and a string as inputs. \\
& \textbf{Exceptions:} & vectAssertNaN throws an exception if the input Vector has NaN values for its fields. \\
& \textbf{Transition:} & vectAssertNaN checks if the fields of the input Vector are valid numbers. If this test fails, it prints the input string as an error message. Called by \hyperref[SecLFBody]{vectAssertSane}. \\
& \textbf{Output:} & None.  \newfunc

\textbf{vectAssert Infinite:} & \textbf{Input:} & vectAssertInfinite accepts a Vector and a string as inputs. \\
& \textbf{Exceptions:} & vectAssertInfinite throws an exception if the input Vector has infinite values for its fields. \\
& \textbf{Transition:} & vectAssertInfinite checks if the fields of the input Vector are finite. If this test fails, it prints the input string as an error message. Called by \hyperref[SecLFBody]{vectAssertSane}. \\
& \textbf{Output:} & None.  \newfunc

\textbf{vectAssert Sane:} & \textbf{Input:} & vectAssertSane accepts a Vector and a string as inputs. \\
& \textbf{Exceptions:} & vectAssertSane throws an exception if the input Vector has NaN or infinite values for its fields. \\
& \textbf{Transition:} & vectAssertSane checks if the fields of the input Vector are valid and finite double values. If this test fails, it prints the input string as an error message. Called by \hyperref[SecLFBody]{assertSaneBody}. \\
& \textbf{Output:} & None.  \newfunc

\textbf{assertSane Body:} & \textbf{Input:} & assertSaneBody accepts a Body pointer as input. \\
& \textbf{Exceptions:} & assertSaneBody may throw an IllegalBody exception if the Body violates any invariant in \ref{SecSIBody} after the transition is complete. \\
& \textbf{Transition:} & assertSaneBody checks if the input Body satisfies all state invariants, and prints various error messages depending on the first invariant found to be violated. Called by various functions in Section \ref{SecAPSBody}. \\
& \textbf{Output:} & None. \newfunc

\textbf{bodySet Transform:} & \textbf{Input:} & bodySetTransform accepts a Body pointer, a Vector, and a double value as inputs. \\
& \textbf{Exceptions:} & None.\\
& \textbf{Transition:} & bodySetTransform mutates the input Body's transformation matrix (used to obtain its local position) using the input position Vector and a rotation vector converted from the given angle (last input value). Called by \hyperref[SecAPSBody]{bodySetPosition and bodySetAngle}. \\
& \textbf{Output:} & None.  \newfunc
\end{longtable*}

%%%%%%%%%%%%%%%%%%%% SHAPE MODULE %%%%%%%%%%%%%%%%%%%%%%%

\section{MIS of the Shape Module} \label{MISShape}

\subsection{Module Name: Shape} 

\subsection{Uses} \label{SecUShape}
	 \Body, \Space, \Arbiter, \Control, \Vector, \BB, \Transform

\subsection{Interface Syntax}

\subsubsection{Exported Constants} \label{SecECShape}
	MAGIC_EPSILON: \R \\
	MAGIC_EPSILON := $1 \times 10^{-5}$ \\
	\newline
	POLY_SHAPE_INLINE_ALLOC: \UZ \\
	POLY_SHAPE_INLINE_ALLOC := $6$ 
	
\subsubsection{Exported Data Types} \label{SecEDTShape}
	ShapeType: enum \\
	ShapeMassInfo: struct \\
	ShapeClass: struct \\
	Shape: struct \\
	ShapeCacheDataImpl : Shape* $\times$ Transform $\to$ BB \\
	ShapeDestroyImpl : Shape* $\to$ void
	
\pagebreak % for pagebreak
	
\subsubsection{Exported Access Programs} \label{SecEAPShape}
	\renewcommand*{\arraystretch}{1.2}
	\begin{longtable}{| y | x{3.5cm} | y | x{3.5cm} |}
		\hline \textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions} \\ \hline 
		shapeInit & Shape*, ShapeClass*, Body*, ShapeMassInfo & Shape* & - \\ \hline
		shapeDestroy & Shape* & - & - \\ \hline
		shapeGetSpace & Shape* & Space* & - \\ \hline
		shapeGetBody & Shape* & Body* & - \\ \hline
		shapeGetMass & Shape* & double & - \\ \hline
		shapeGetDensity & Shape* & double & - \\ \hline
		shapeGetMoment & Shape* & double & - \\ \hline
		shapeGetArea & Shape* & double & - \\ \hline
		shapeGetCenterOfMass & Shape* & Vector & - \\ \hline
		shapeGetBB & Shape* & BB & - \\ \hline
		shapeGetElasticity & Shape* & double & - \\ \hline
		shapeGetFriction & Shape* & double & - \\ \hline
		shapeGetSurfaceVelocity & Shape* & Vector & - \\ \hline
		shapeGetCollisionType & Shape* & CollisionType & - \\ \hline
		shapeSetMass & Shape*, double & - & IllegalBody \\ \hline
		shapeSetDensity & Shape*, double & - & IllegalBody \\ \hline
		shapeSetElasticity & Shape*, double & - & NegativeElasticity \\ \hline
		shapeSetFriction & Shape*, double & - & NegativeFriction \\ \hline
		shapeSetSurfaceVelocity & Shape*, Vector & - & - \\ \hline
		shapeSetCollisionType & Shape*, CollisionType & - & - \\ \hline
		shapeCacheBB & Shape* & BB & - \\ \hline
		shapeUpdate & Shape*, Transform & BB & - \\ \hline
	\end{longtable}
	
\subsection{Interface Semantics}

\subsubsection{State Variables} \label{SecSVShape}
	\textbf{ShapeType} $\in$ \{CIRCLE_SHAPE, SEGMENT_SHAPE, POLY_SHAPE, NUM_SHAPES\} \\
	\newpage %BREAK
	\noindent \textbf{ShapeMassInfo:}
	\begin{multicols}{2}
		\noindent mass: \R \\
		moment: \R \\
		com: Vector \\
		area: \R
	\end{multicols}
	\noindent \textbf{ShapeClass:}
	\begin{multicols}{2}
		\noindent type: ShapeType \\
		cacheData: ShapeCacheDataImpl \\
		destroy: ShapeDestroyImpl \\
	\end{multicols}
	\noindent \textbf{Shape:}
	\begin{multicols}{2}
		\noindent klass: ShapeClass* \\
		space: Space* \\
		body: Body* \\
		massInfo: ShapeMassInfo \\
		bb: BB \\
		elast: \R \\
		fric: \R \\
		surfaceVel: Vector \\
		type: CollisionType \\
		next: Shape* \\
		prev: Shape* \\
		hashId: HashValue
	\end{multicols}
	
\subsubsection{State Invariants} \label{SecSIShape}
	$\text{Shape.elast} \ge 0 $ \\
	$\text{Shape.fric} \ge 0 $ 

\subsubsection{Assumptions} \label{SecAShape}
	All input pointers are assumed to be non-null. Also see \ref{SecACircle}, \ref{SecASegment} and \ref{SecAPoly}.
	
\subsubsection{Access Program Semantics} \label{SecAPSShape}
	\renewcommand*{\arraystretch}{\funcPadding}
	\begin{longtable*}{@{} p{3.3cm} l p{\colDescrip}} 
		\textbf{shapeInit:} & \textbf{Input:} & shapeInit accepts a Shape pointer, ShapeClass pointer, Body pointer and a ShapeMassInfo structure as inputs.\\
		& \textbf{Exceptions:} & None. \\
		& \textbf{Transition:} & shapeInit initializes the input Shape. It sets the Shape's class, body and mass information to the input parameters, and zero-initializes all other variables. \\
		& \textbf{Output:} & shapeInit returns a pointer to the initialized Shape as output.  \newfunc
		
		\textbf{shapeDestroy:} & \textbf{Input:} & shapeDestroy accepts a Shape pointer as input. \\
		& \textbf{Exceptions:} & None. \\ \pagebreak %stylebreak
		& \textbf{Transition:} & shapeDestroy frees the input Shape object. \\ 
		& \textbf{Output:} & None.  \newfunc 
		
		\textbf{shapeGet:} & \textbf{Input:} & Each shapeGet function accepts a Shape pointer as input. \\
		& \textbf{Exceptions:} & None.\\
		& \textbf{Transition:} & None. \\
		& \textbf{Output:} & Each shapeGet function returns the value of their corresponding parameter.  \newfunc
		
		\textbf{shapeSet:} & \textbf{Input:} & Each shapeSet function accepts a Shape pointer and their corresponding parameter as inputs.\\
		& \textbf{Exceptions:} & Various, see Section \ref{SecEAPShape}. \\
		& \textbf{Transition:} & Each shapeSet function will set the corresponding parameter to the input value. shapeSetMass sets the mass of the Shape's mass information and recalculates the mass of its associated Body accordingly. \\
		& \textbf{Output:} & None.  \newfunc
		
		\textbf{shapeCacheBB:} & \textbf{Input:} & shapeCacheBB accepts a Shape pointer as input. \\
		& \textbf{Exceptions:} & None.\\
		& \textbf{Transition:} & shapeCacheBB updates the input Shape using the Transform matrix of its associated Body and modifies its bounding box (BB). \\
		& \textbf{Output:} & shapeCacheBB returns the new BB as output.  \newfunc
		
		\textbf{shapeUpdate:} & \textbf{Input:} & shapeUpdate accepts a Shape pointer and a Transform matrix as inputs.\\
		& \textbf{Exceptions:} & None.\\
		& \textbf{Transition:} & shapeUpdate will call the cacheData function in the input Shape's class using the given parameters and modify the Shape's BB. \\
		& \textbf{Output:} & shapeUpdate returns the BB returned by the cacheData function as output.  \newfunc
	\end{longtable*}

\subsection{Submodule Name: CircleShape} \label{MISCircle}

\subsection{Uses} \label{SecUCircle}
	\Body, \Shape, \Control, \Vector, \BB, \Transform

\subsection{Interface Syntax}

\subsubsection{Exported Data Types} \label{SecEDTCircle}
	CircleShape: struct

\subsubsection{Exported Access Programs} \label{SecEAPCircle}
	\renewcommand*{\arraystretch}{1.2}
	\begin{longtable}{| y | x{3.5cm} | y | x{3.5cm} |} 
		\hline \textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions} \\ \hline 
		circleShapeAlloc & - & CircleShape* & - \\ \hline
		circleShapeInit & CircleShape*, Body*, double, Vector & CircleShape* & - \\ \hline
		circleShapeNew & Body*, double, Vector & Shape* & - \\ \hline
		circleShapeGetRadius & Shape* & double & NotCircleShape \\ \hline
		circleShapeGetOffset & Shape* & Vector & NotCircleShape \\ \hline
		circleShapeSetRadius & Shape*, double & - & NotCircleShape \vor IllegalBody \\ \hline
		circleShapeSetOffset & Shape*, Vector & - & NotCircleShape \vor IllegalBody \\ \hline
		momentForCircle & double, double, double, Vector & double & - \\ \hline
		areaForCircle & double, double & double & - \\ \hline
	\end{longtable}
	
\subsection{Interface Semantics}

\subsubsection{State Variables} \label{SecSVCircle}
	\textbf{CircleShape:}
	\begin{multicols}{2}
		\noindent shape: Shape \\
		center: Vector \\
		tcenter: Vector \\
		radius: \R
	\end{multicols}
	\noindent Note that \textit{center} is the centroid of the circle, and \textit{tcenter} is the transformed centroid in global coordinates.
	
\subsubsection{Assumptions} \label{SecACircle}
	circleShapeAlloc or circleShapeNew have been called before any other access programs. All input pointers are also assumed to be non-null.
	
\subsubsection{Access Program Semantics} \label{SecAPSCircle}
	\renewcommand*{\arraystretch}{\funcPadding}
	\begin{longtable*}{@{} p{3.5cm} l p{\colDescrip}} 
		\textbf{circleShapeAlloc:} & \textbf{Input:} & None. \\
		& \textbf{Exceptions:} & None.\\
		& \textbf{Transition:} & None. \\
		& \textbf{Output:} & circleShapeAlloc heap-allocates a new CircleShape object and returns a pointer to it as output.  \newfunc
		
		\textbf{circleShapeInit:} & \textbf{Input:} & circleShapeInit accepts a CircleShape pointer, a Body pointer, a double and a Vector as inputs. \\
		& \textbf{Exceptions:} & None.\\
		& \textbf{Transition:} & circleShapeInit initializes the input CircleShape. It sets the radius to the input double, the center to the input Vector, and then initializes the rest of the variables using shapeInit and the input Body. \\
		& \textbf{Output:} & circleShapeInit returns a pointer to the initialized CircleShape.  \newfunc
		
		\textbf{circleShapeNew:} & \textbf{Input:} & circleShapeNew accepts a Body pointer, a double and a Vector as inputs. \\
		& \textbf{Exceptions:} & None.\\
		& \textbf{Transition:} & circleShapeNew allocates and initializes a new CircleShape object using the input paramters. \\
		& \textbf{Output:} & circleShapeNew returns a pointer to the new CircleShape.  \newfunc
		
		\textbf{circleShapeGet:} & \textbf{Input:} & Each circleShapeGet function accepts a Shape pointer as input.\\
		& \textbf{Exceptions:} & Each circleShapeGet function may throw a NotCircleShape exception if the input Shape pointer is not of the CircleShape class. \\ \\ \\ % stylebreak
		& \textbf{Transition:} & None. \\
		& \textbf{Output:} & Each circleShapeGet function returns the value of their corresponding parameter.  \newfunc
		
		\textbf{circleShapeSet:} & \textbf{Input:} & Each circleShapeSet function accepts a Shape pointer and their corresponding parameter as inputs. \\
		& \textbf{Exceptions:} & Each circleShapeSet function may throw a NotCircleShape exception if the input Shape pointer is not of the CircleShape class, or if the Body associated with the Shape violates an invariant in \ref{SecSIBody} after the transitions are complete. \\
		& \textbf{Transition:} & Each circleShapeSet function sets their corresponding parameter with the input value, updates the mass information of the Shape and recalculates the mass of its associated Body. \\
		& \textbf{Output:} & None.  \newfunc
		
		\textbf{momentForCircle:} & \textbf{Input:} & momentForCircle accepts three doubles for mass, inner radius and outer radius, and a Vector as inputs.\\
		& \textbf{Exceptions:} & None.\\
		& \textbf{Transition:} & None. \\
		& \textbf{Output:} & momentForCircle returns the calculated moment from the input parameters as a double.  \newfunc
		
		\textbf{areaForCircle:} & \textbf{Input:} & areaForCircle accepts two double values for the inner radius and outer radius as inputs. \\
		& \textbf{Exceptions:} & None.\\
		& \textbf{Transition:} & None. \\
		& \textbf{Output:} & areaForCircle returns the calculated area from the input parameters as a double.  \newfunc
	\end{longtable*}
	
\subsubsection{Local Constants} \label{SecLCCircle}
CircleShapeClass: ShapeClass \\
CircleShapeClass := \{CIRCLE_SHAPE, circleShapeCacheData, NULL\}

\pagebreak % for pagebreak

\subsubsection{Local Functions} \label{SecLFCircle}
	\renewcommand*{\arraystretch}{\funcPadding}
	\begin{longtable*}{@{} p{3.3cm} l p{\colDescrip}}
		\textbf{circleShapeCache Data:} & \textbf{Input:} & circleShapeCacheData accepts a CircleShape pointer and a Transform matrix as inputs. \\
		& \textbf{Exceptions:} & None.\\
		& \textbf{Transition:} & circleShapeCacheData updates the transformed center of the input CircleShape using the input Transform matrix and generates a new BB with the CircleShape's properties. Default cacheData method of the \hyperref[SecLCCircle]{CircleShapeClass}. \\
		& \textbf{Output:} & circleShapeCacheData returns the new BB as output.  \newfunc
		
		\textbf{circleShapeMass Info:} & \textbf{Input:} & circleShapeMassInfo accepts two double values for mass and radius and a Vector as inputs. \\
		& \textbf{Exceptions:} & None.\\
		& \textbf{Transition:} & None. \\
		& \textbf{Output:} & circleShapeMassInfo is a convenience constructor which returns a new ShapeMassInfo structure for CircleShapes, initialized using the input values.  \newfunc
	\end{longtable*}
	
\subsection{Submodule Name: SegmentShape} \label{MISSegment}

\subsection{Uses} \label{SecUSegment}
	\Body, \Shape, \Poly, \Vector, \BB, \Transform

\subsection{Interface Syntax}

\subsubsection{Exported Data Types} \label{SecEDTSegment}
	SegmentShape: struct

\subsubsection{Exported Access Programs} \label{SecEAPSegment}
	\renewcommand*{\arraystretch}{1.2}
	\begin{longtable}{| y | x{3.5cm} | y | x{3.5cm} |}
	\hline \textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions} \\ \hline 
	segmentShapeAlloc & - & SegmentShape* & - \\ \hline
	segmentShapeInit & SegmentShape*, Body*, Vector, Vector, double & SegmentShape* & - \\ \hline
	segmentShapeNew & Body*, Vector, Vector, double & Shape* & - \\ \hline
	segmentShapeGetA & Shape* & Vector & NotSegmentShape \\ \hline
	segmentShapeGetB & Shape* & Vector & NotSegmentShape \\ \hline
	segmentShapeGetNormal & Shape* & Vector & NotSegmentShape \\ \hline
	segmentShapeGetRadius & Shape* & double & NotSegmentShape \\ \hline
	segmentShapeSetNeighbors & Shape*, Vector, Vector & - & NotSegmentShape \\ \hline
	segmentShapeSetEndpoints & Shape*, Vector, Vector & - & NotSegmentShape \vor IllegalBody \\ \hline
	segmentShapeSetRadius & Shape*, double & - & NotSegmentShape \vor IllegalBody \\ \hline
	momentForSegment & double, Vector, Vector, double & double & - \\ \hline
	areaForSegment & Vector, Vector, double & double & - \\ \hline
\end{longtable}

\subsection{Interface Semantics}

\subsubsection{State Variables} \label{SecSVSegment}
	\textbf{SegmentShape:}
	\begin{multicols}{2}
		\noindent shape: Shape \\
		a: Vector \\
		b: Vector \\
		n: \R \\
		ta: Vector \\
		tb: Vector \\
		tn: Vector \\
		radius: \R \\
		aTangent: Vector \\
		bTangent: Vector \\
	\end{multicols}
	\noindent Note that \textit{a} and \textit{b} are the endpoints of the segment, and \textit{n} is the normal. \textit{ta}, \textit{tb} and \textit{tn} are the transformed endpoints in global coordinates.

\subsubsection{Assumptions} \label{SecASegment}
	segmentShapeAlloc or segmentShapeNew, have been called before any other access programs. All input pointers are also assumed to be non-null.
	
\pagebreak % for pagebreak

\subsubsection{Access Program Semantics} \label{SecAPSSegment}
	\renewcommand*{\arraystretch}{\funcPadding}
	\begin{longtable*}{@{} p{3.3cm} l p{\colDescrip}} 
	\textbf{segmentShape Alloc:} & \textbf{Input:} & None. \\
	& \textbf{Exceptions:} & None.\\
	& \textbf{Transition:} & None. \\
	& \textbf{Output:} & segmentShapeAlloc heap-allocates a new SegmentShape object and returns a pointer to it as output.  \newfunc
	
	\textbf{segmentShape Init:} & \textbf{Input:} & segmentShapeInit accepts a SegmentShape pointer, a Body pointer, two Vectors and a double as inputs. \\
	& \textbf{Exceptions:} & None.\\
	& \textbf{Transition:} & segmentShapeInit initializes the input SegmentShape. It sets the endpoints to the given Vectors, the radius to the given double, and initializes the rest with shapeInit and the input Body. \\
	& \textbf{Output:} & segmentShapeInit returns a pointer to the initialized SegmentShape.  \newfunc
	
	\textbf{segmentShape New:} & \textbf{Input:} & segmentShapeNew accepts a Body pointer, two Vectors and a double as inputs. \\
	& \textbf{Exceptions:} & None.\\
	& \textbf{Transition:} & segmentShapeNew allocates and initializes a new SegmentShape object using the input parameters.  \\
	& \textbf{Output:} & segmentShapeNew returns a pointer to the new SegmentShape.  \newfunc
	
	\textbf{segmentShape Get:} & \textbf{Input:} & Each segmentShapeGet function accepts a Shape pointer as input.\\
	& \textbf{Exceptions:} & Each segmentShapeGet function may throw a NotSegmentShape exception if the input Shape pointer is not of the SegmentShape class. \\
	& \textbf{Transition:} & None. \\
	& \textbf{Output:} & Each segmentShapeGet function returns the value of their corresponding parameter.  \newfunc
	
	\textbf{segmentShape Set:} & \textbf{Input:} & Each segmentShapeSet function accepts a Shape pointer and their corresponding parameter as inputs. In particular, segmentShapeSetNeighbors and segmentShapeSetEndpoints accept two Vectors as inputs. \\
	& \textbf{Exceptions:} & Each segmentShapeSet function may throw a NotSegmentShape exception if the input Shape pointer is not of the SegmentShape class. segmentShapeSetEndpoints and segmentShapeSetRadius may throw an IllegalBody exception if the Body associated with the Shape violates an invariant in \ref{SecSIBody} after the transitions are complete. \\
	& \textbf{Transition:} & Each segmentShapeSet function sets their corresponding parameter with the input value. In addition, segmentShapeSetEndpoints and segmentShapeSetRadius update the mass information of the Shape and recalculate the mass of the associated Body. \\
	& \textbf{Output:} & None.  \newfunc
	
	\textbf{momentFor Segment:} & \textbf{Input:} & momentForSegment accepts a double for mass, two Vectors for endpoints, and another double for radius as inputs.\\
	& \textbf{Exceptions:} & None.\\
	& \textbf{Transition:} & None. \\
	& \textbf{Output:} & momentForSegment returns the calculated moment from the input parameters as a double.  \newfunc
	
	\textbf{areaForSegment:} & \textbf{Input:} & areaForSegment accepts two Vectors for endpoints and a double for radius as inputs. \\
	& \textbf{Exceptions:} & None.\\
	& \textbf{Transition:} & None. \\
	& \textbf{Output:} & areaForSegment returns the calculated area from the input parameters as a double.  \newfunc
	\end{longtable*}
	
\subsubsection{Local Constants} \label{SecLCSegment}
SegmentShapeClass: ShapeClass \\
SegmentShapeClass := \{SEGMENT_SHAPE, segmentShapeCacheData, NULL\}

\pagebreak % for pagebreak

\subsubsection{Local Functions} \label{SecLFSegment}
	\renewcommand*{\arraystretch}{\funcPadding}
	\begin{longtable*}{@{} p{3.3cm} l p{\colDescrip}}
	\textbf{segmentShape CacheData:} & \textbf{Input:} & segmentShapeCacheData accepts a SegmentShape pointer and a Transform matrix as inputs. \\
	& \textbf{Exceptions:} & None.\\
	& \textbf{Transition:} & segmentShapeCacheData updates the transformed endpoints and normal for the input SegmentShape using the input Transform matrix and generates a new BB with the SegmentShape's properties. Default cacheData method for the \hyperref[SecLCSegment]{SegmentShapeClass}.  \\
	& \textbf{Output:} & segmentShapeCacheData returns the new BB as output.  \newfunc
	
	\textbf{segmentShape MassInfo:} & \textbf{Input:} & segmentShapeMassInfo accepts a double for mass, two Vectors for endpoints and a double for radius as inputs. \\
	& \textbf{Exceptions:} & None.\\
	& \textbf{Transition:} & None. \\
	& \textbf{Output:} & segmentShapeMassInfo is a convenience constructor that returns a new ShapeMassInfo structure for SegmentShapes, initialized using the input values.  \newfunc
	\end{longtable*}
	
\subsection{Submodule Name: PolyShape} \label{MISPoly}

\subsection{Uses} \label{SecUPoly}
	\Body, \Shape, \Segment, \Control, \Vector, \BB, \Transform

\subsection{Interface Syntax}

\subsubsection{Exported Data Types} \label{SecEDTPoly}
SplittingPlane: struct \\
PolyShape: struct

\subsubsection{Exported Access Programs} \label{SecEAPPoly}
	\renewcommand*{\arraystretch}{1.2}
	\begin{longtable}{| y | x{3.5cm} | y | x{3.5cm} |} 
	\hline \textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions} \\ \hline 
	polyShapeAlloc & - & PolyShape* & - \\ \hline
	Raw & PolyShape*, Body*, int, Vector*, double & PolyShape* & - \\ \hline
	polyShapeInit & PolyShape*, Body*, int, Vector*, double, Transform & PolyShape* & - \\ \hline
	boxShapeInit & PolyShape*, Body*, double, double, double & PolyShape* & - \\ \hline
	boxShapeInit2 & PolyShape*, Body*, double, BB & PolyShape* & - \\ \hline
	polyShapeNew & Body*, int, Vector*, double & Shape* & - \\ \hline
	polyShapeNewRaw & Body*, int, Vector*, double, Transform & Shape* & - \\ \hline
	boxShapeNew & Body*, double, double, double & Shape* & - \\ \hline
	boxShapeNew2 & Body*, double, BB & Shape* & - \\ \hline
	polyShapeGetCount & Shape* & int & NotPolyShape \\ \hline
	polyShapeGetVert & Shape*, int & Vector & NotPolyShape \vor IndexOutOfBounds \\ \hline
	polyShapeGetRadius & Shape* & double & NotPolyShape \\ \hline
	polyShapeSetVerts & Shape*, int, Vector*, Transform & - & NotPolyShape \vor IllegalBody \\ \hline
	polyShapeSetVertsRaw & Shape*, int, Vector* & - & NotPolyShape \vor IllegalBody \\ \hline
	polyShapeSetRadius & Shape*, double & - & NotPolyShape \\ \hline
	momentForPoly & double, int, Vector*, Vector, double & double & - \\ \hline
	areaForPoly & int, Vector*, double & double & - \\ \hline
	centroidForPoly & int, Vector* & Vector & - \\ \hline
\end{longtable}

\subsection{Interface Semantics}

\subsubsection{State Variables} \label{SecSVPoly}
	\textbf{SplittingPlane:}
	\begin{multicols}{2}
		\noindent v0: Vector \\
		n: Vector 
	\end{multicols}
	\noindent \textbf{PolyShape:}
	\begin{multicols}{2}
		\noindent shape: Shape \\
		radius: \R \\
		count: \Z \\
		planes: SplittingPlane* \\
		_planes: array(SplittingPlane)
	\end{multicols}
	
	\iffalse %% Unsure if this detail is necessary in the MIS.
	\noindent Note that \textit{count} is the number of vertices of the PolyShape, and both \textit{planes} and \textit{_planes} store the vertices of the PolyShape. \textit{_planes} are used if the PolyShape has at most \hyperref[SecECShape]{POLY_SHAPE_INLINE_ALLOC} vertices; otherwise, \textit{planes} are used.
	\fi

\subsubsection{Assumptions} \label{SecAPoly}
	polyShapeAlloc, or polyShapeNew/polyShapeNewRaw, or boxShapeNew/boxShapeNew2, have been called before any other access programs. All input pointers are also assumed to be non-null.

\subsubsection{Access Program Semantics} \label{SecAPSPoly}
\renewcommand*{\arraystretch}{\funcPadding}
	\begin{longtable*}{@{} p{3.3cm} l p{\colDescrip}} 
	\textbf{polyShapeAlloc:} & \textbf{Input:} & None. \\
	& \textbf{Exceptions:} & None.\\
	& \textbf{Transition:} & None. \\
	& \textbf{Output:} & polyShapeAlloc heap-allocates a new PolyShape object and returns a pointer to it as output.  \newfunc
	
	\textbf{polyShapeInit:} & \textbf{Input:} & polyShapeInit accepts a PolyShape pointer, a Body pointer, an integer, a pointer to a Vector array, a double and a Transform matrix as inputs. \\
	& \textbf{Exceptions:} & None.\\
	& \textbf{Transition:} & polyShapeInit transforms each vertex from the input array with the input Transform matrix, places the resultant vertices in a new array, calculates the size of the convex hull containing the new vertices and initializes the input PolyShape using this array, the hull size and the remaining parameters. \\
	& \textbf{Output:} & polyShapeInit returns a pointer to the initialized PolyShape.  \newfunc
	
	\textbf{polyShapeInit Raw:} & \textbf{Input:} & polyShapeInitRaw accepts a PolyShape pointer, a Body pointer, an integer, a pointer to a Vector array and a double as inputs. \\
	& \textbf{Exceptions:} & None.\\
	& \textbf{Transition:} & polyShapeInitRaw initializes the input PolyShape using shapeInit and the input parameters, sets its vertices to the given array and integer (which represents the length of the array), and sets its radius to the input double. \\
	& \textbf{Output:} & polyShapeInitRaw returns a pointer to the initialized PolyShape.  \newfunc
	
	\textbf{boxShapeInit:} & \textbf{Input:} & boxShapeInit accepts a PolyShape pointer, Body pointer and three doubles as inputs. \\
	& \textbf{Exceptions:} & None.\\
	& \textbf{Transition:} & boxShapeInit calculates values for half-width and half-height using the last two input doubles as width and height, respectively. It then initializes the input PolyShape using a new BB generated from the calculated half-dimensions and the remaining parameters. \\
	& \textbf{Output:} & boxShapeInit returns a pointer to the initialized PolyShape.  \newfunc
	
	\textbf{boxShapeInit2:} & \textbf{Input:} & boxShapeInit2 accepts a PolyShape pointer, Body pointer, a double and a BB as inputs. \\
	& \textbf{Exceptions:} & None.\\
	& \textbf{Transition:} & boxShapeInit2 creates a Vector array containing the vertices of the box, determined from the input BB. It then initializes the input PolyShape as a box using the array and number of vertices, as well as the remaining parameters. \\
	& \textbf{Output:} & boxShapeInit2 returns a pointer to the initialized PolyShape.  \newfunc
	
	\textbf{polyShapeNew:} & \textbf{Input:} & Each polyShapeNew function accepts a Body pointer, an integer, a pointer to a Vector array and a double as inputs. In addition, polyShapeNew (not Raw) accepts a Transform matrix as its last input. \\
	& \textbf{Exceptions:} & None.\\
	& \textbf{Transition:} & Each polyShapeNew function allocates and initializes a new PolyShape object using the input parameters. \\
	& \textbf{Output:} & Each polyShapeNew function returns a pointer to the new PolyShape.  \newfunc
	
	\textbf{boxShapeNew:} & \textbf{Input:} & Each boxShapeNew function accepts a Body pointer and a double as inputs. In addition, boxShapeNew accepts two additional doubles, while boxShapeNew2 accepts an additional BB as input. \\
	& \textbf{Exceptions:} & None.\\
	& \textbf{Transition:} & Each boxShapeNew function allocates and initializes a new PolyShape object as a box using the input parameters. \\
	& \textbf{Output:} & Each boxShapeNew function returns a pointer to the new PolyShape.  \newfunc
	
	\textbf{polyShapeGet:} & \textbf{Input:} & Each polyShapeGet function accepts a Shape pointer as input. polyShapeGetVert also accepts an additional integer as input. \\
	& \textbf{Exceptions:} & Each polyShapeGet function may throw a NotPolyShape exception if the input Shape pointer is not of the PolyShape class. polyShapeGetVert may also throw an exception if the input integer is greater than or equal to the number of vertices of the input Shape. \\
	& \textbf{Transition:} & None. \\
	& \textbf{Output:} & Each polyShapeGet function returns the value of their corresponding parameter.  \newfunc
	
	\textbf{polyShapeSet:} & \textbf{Input:} & Each polyShapeSet function accepts a Shape pointer and their corresponding parameter as inputs. Specifically, each polyShapeSetVerts function accepts an integer (for the number of vertices) and a pointer to a Vector array (holding the vertices) as inputs, and polyShapeSetVerts (not Raw) accepts an additional Transform matrix. \\
	& \textbf{Exceptions:} & Each polyShapeSet function may throw a NotPolyShape exception if the input Shape pointer is not of the PolyShape class. Each polyShapeSetVerts function may throw an IllegalBody exception if the Body associated with the Shape violates an invariant in \ref{SecSIBody} after the transitions are complete. \\
	& \textbf{Transition:} & Each polyShapeSet function sets their corresponding parameter with the input value. More specifically, polyShapeVerts transforms the vertices in the input array with the input Transform matrix, places the resultant vertices in a new array, determines the size of the convex hull containing these vertices, and calls polyShapeSetVertsRaw with the new array and hull size. polyShapeVertsRaw frees the current vertices of the input PolyShape, sets its new vertices, updates the mass information of the Shape and recalculates the mass of the associated Body. \\
	& \textbf{Output:} & None.  \newfunc
	
	\textbf{momentForPoly:} & \textbf{Input:} & momentForPoly accepts a double for mass, an integer for number of vertices, a pointer to a Vector array containing these vertices, a Vector for offset, and a double for radius as inputs.\\
	& \textbf{Exceptions:} & None.\\
	& \textbf{Transition:} & None. \\
	& \textbf{Output:} & momentForPoly returns the calculated moment from the input parameters as a double.  \newfunc
	
	\textbf{areaForPoly:} & \textbf{Input:} & areaForPoly accepts an integer for number of vertices, a pointer to a Vector array containing these vertices, and a double for radius as inputs. \\
	& \textbf{Exceptions:} & None.\\
	& \textbf{Transition:} & None. \\
	& \textbf{Output:} & areaForPoly returns the calculated area from the input parameters as a double.  \newfunc
	
	\textbf{centroidForPoly:} & \textbf{Input:} & centroidForPoly accepts an integer for number of vertices and a pointer to a Vector array containing these vertices as inputs. \\
	& \textbf{Exceptions:} & None.\\
	& \textbf{Transition:} & None. \\
	& \textbf{Output:} & centroidForPoly returns the calculated centroid from the input parameters as a Vector.  \newfunc
\end{longtable*}

\subsubsection{Local Constants} \label{SecLCPoly}
PolyShapeClass: ShapeClass \\
PolyShapeClass := \{POLY_SHAPE, polyShapeCacheData, polyShapeDestroy\}

\subsubsection{Local Functions} \label{SecLFPoly}
\renewcommand*{\arraystretch}{\funcPadding}
	\begin{longtable*}{@{} p{2.9cm} l p{\colDescrip}}
	\textbf{polyShape Destroy:} & \textbf{Input:} & polyShapeDestroy accepts a PolyShape pointer as input. \\
	& \textbf{Exceptions:} & None.\\
	& \textbf{Transition:} & polyShapeDestroy frees the input PolyShape and its associated array of vertices. Default destroy method for the \hyperref[SecLCPoly]{PolyShapeClass}. \\
	& \textbf{Output:} & None.  \newfunc
	
	\textbf{polyShape CacheData:} & \textbf{Input:} & polyShapeCacheData accepts a PolyShape pointer and a Transform matrix as inputs. \\
	& \textbf{Exceptions:} & None.\\
	& \textbf{Transition:} & polyShapeCacheData transforms each vertex of the input PolyShape using the input matrix, calculates the extreme points of the shape, and updates the PolyShape's BB to a new BB generated from the calculated extremes. Default cacheData method for the \hyperref[SecLCPoly]{PolyShapeClass}. \\
	& \textbf{Output:} & polyShapeCacheData returns the new BB as output.  \newfunc
	
	\textbf{setVerts:} & \textbf{Input:} & setVerts accepts a PolyShape pointer, an integer, and a pointer to a Vector array as inputs. \\
	& \textbf{Exceptions:} & None.\\
	& \textbf{Transition:} & setVerts sets the input PolyShape's number of vertices to the input integer. If this is less than or equal to \hyperref[SecECShape]{POLY_SHAPE_INLINE_ALLOC}, the PolyShape uses its default _planes array for its vertices. Otherwise, it heap-allocates a new array with the length of the input integer. Finally, the function iterates through the planes array and sets the vertices and their calculated edge normals from the input array. Called by \hyperref[SecAPSPoly]{polyShapeInitRaw and polyShapeSetVertsRaw} to mutate vertices.  \\
	& \textbf{Output:} & None.  \newfunc
	
	\textbf{polyShape MassInfo:} & \textbf{Input:} & polyShapeMassInfo accepts a double for mass, an integer for number of vertices, a pointer to a Vector array containing these vertices, and a double for radius as inputs. \\
	& \textbf{Exceptions:} & None.\\
	& \textbf{Transition:} & None. \\
	& \textbf{Output:} & polyShapeMassInfo is a convenience constructor that returns a new ShapeMassInfo structure for PolyShapes, initialized using the input values.  \newfunc
\end{longtable*}
	
%%%%%%%%%%%%%%%%%%%% SPACE MODULE %%%%%%%%%%%%%%%%%%%%%%%

\section{MIS of the Space Module} \label{MISSpace}

\subsection{Module Name: Space}

\subsection{Uses} \label{SecUSpace}
	\Body, \Shape, \Arbiter, \Control, \Vector, \SpatialIndex, \Sequence, \Linked, \Assoc

\subsection{Interface Syntax}

\subsubsection{Exported Constants} \label{SecECSpace}
	collisionHandlerDoNothing: CollisionHandler \\
	collisionHandlerDoNothing := \{\hyperref[SecECControl]{WILDCARD_COLLISION_TYPE}, WILDCARD_COLLISION_TYPE, \hyperref[SecLFSpace]{alwaysCollide}, alwaysCollide, \hyperref[SecLFSpace]{doNothing}, doNothing, NULL\} \\
	\newline
	CONTACTS_BUFFER_SIZE: \UZ \\
	CONTACTS_BUFFER_SIZE := (\hyperref[SecECControl]{BUFFER_BYTES} - sizeof(ContactBufferHeader)) / sizeof(Contact)
	
\subsubsection{Exported Data Types} \label{SecEDTSpace}
	Space: struct \\
	PostStepCallback: struct \\
	CollisionHandler: struct \\
	ArbiterFilterContext: struct \\
	SpaceShapeContext: struct \\
	ContactBufferHeader: struct \\
	ContactBuffer: struct \\
	SpaceArbiterApplyImpulseFunc : Arbiter* $\to$ void \\
	CollisionBeginFunc : Arbiter* $\times$ Space* $\times$ void* $\to \mathbb{B}$ \\
	CollisionPreSolveFunc : Arbiter* $\times$ Space* $\times$ void* $\to \mathbb{B}$ \\
	CollisionPostSolveFunc : Arbiter* $\times$ Space* $\times$ void* $\to$ void \\
	CollisionSeparateFunc : Arbiter* $\times$ Space* $\times$ void* $\to$ void \\
	PostStepFunc : Space* $\times$ void* $\times$ void* $\to$ void \\
	SpaceBodyIteratorFunc : Body* $\times$ void* $\to$ void \\
	SpaceShapeIteratorFunc : Shape* $\times$ void* $\to$ void

\subsubsection{Exported Access Programs} \label{SecEAPSpace}
	\renewcommand*{\arraystretch}{1.2}
	\begin{longtable}{| y | x{3.5cm} | y | x{3.5cm} |}
	\hline \textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions} \\ \hline 
	spaceAlloc & - & Space* & - \\ \hline
	spaceInit & Space* & Space* & - \\ \hline
	spaceNew & - & Space* & - \\ \hline
	spaceDestroy & Space* & - & - \\ \hline
	spaceFree & Space* & - & - \\ \hline
	spaceGetIterations & Space* & int & - \\ \hline
	spaceGetGravity & Space* & Vector & - \\ \hline
	spaceGetCollisionSlop & Space* & double & - \\ \hline
	spaceGetCollisionBias & Space* & double & - \\ \hline
	spaceGetCollisionPersistence & Space* & Timestamp & - \\ \hline
	spaceGetCurrentTimeStep & Space* & double & - \\ \hline
	spaceGetStaticBody & Space* & Body* & - \\ \hline
	spaceSetIterations & Space*, int & - & InvalidIter \\ \hline
	spaceSetGravity & Space*, Vector & - & - \\ \hline
	spaceSetCollisionSlop & Space*, double & - & - \\ \hline
	spaceSetCollisionBias & Space*, double & - & - \\ \hline
	spaceSetCollisionPersistence & Space*, Timestamp & - & - \\ \hline
	spaceSetStaticBody & Space*, Body* & - & AttachedStaticBody \\ \hline
	spaceIsLocked & Space* & Boolean & - \\ \hline
	spaceAddDefaultCollisionHandler & Space* & CollisionHandler* & - \\ \hline
	spaceAddCollisionHandler & Space*, CollisionType, CollisionType & CollisionHandler* & - \\ \hline
	spaceAddWildcardHandler & Space*, CollisionType & CollisionHandler* & - \\ \hline
	spaceAddShape & Space*, Shape* & Shape* & DuplicateShape \vor AttachedShape \vor SpaceLocked \\ \hline
	spaceAddBody & Space*, Body* & Body* & DuplicateBody \vor AttachedBody \vor SpaceLocked \\ \hline
	spaceFilterArbiters & Space*, Body*, Shape* & - & - \\ \hline
	spaceRemoveShape & Space*, Shape* & - & ShapeNotFound \vor SpaceLocked \\ \hline
	spaceRemoveBody & Space*, Body* & - & MainStaticBody \vor BodyNotFound \vor SpaceLocked \\ \hline
	spaceContainsShape & Space*, Shape* & Boolean & - \\ \hline
	spaceContainsBody & Space*, Body* & Boolean & - \\ \hline
	spaceEachBody & Space*, SpaceBodyIteratorFunc, void* & - & - \\ \hline
	spaceEachShape & Space*, SpaceShapeIteratorFunc, void* & - & - \\ \hline
	spaceReindexStatic & Space* & - & SpaceLocked \\ \hline
	spaceReindexShape & Space*, Shape* & - & SpaceLocked \\ \hline
	spaceReindexShapesForBody & Space*, Body* & - & SpaceLocked \\ \hline
	spacePushFreshContactBuffer & Space* & - & - \\ \hline
	contactBufferGetArray & Space* & Contact & - \\ \hline
	spaceCollideShapes & Shape*, Shape*, CollisionID, Space* & CollisionID & - \\ \hline
	spaceArbiterSetFilter & Arbiter*, Space* & Boolean & - \\ \hline
	spaceLock & Space* & - & - \\ \hline
	spaceUnlock & Space*, Boolean & - & SpaceLockUnderflow \\ \hline
	spaceArrayForBodyType & Space*, BodyType & Array* & - \\ \hline
	shapeUpdateFunc & Shape*, void* & - & - \\ \hline
	spaceStep & Space*, double & - & - \\ \hline
\end{longtable}

\subsection{Interface Semantics}

\subsubsection{State Variables} \label{SecSVSpace}
	\textbf{Space:} 
	\begin{multicols}{2}
		\noindent iterations: \Z \\
		gravity: Vector \\
		collisionSlop: \R \\
		collisionBias: \R \\
		collisionPersistence: Timestamp \\
		stamp: Timestamp \\
		curr_dt: \R \\
		dynamicBodies: Array* \\
		staticBodies: Array* \\
		shapeIDCounter: HashValue \\
		staticShapes: SpatialIndex* \\
		dynamicShapes: SpatialIndex* \\
		arbiters: Array* \\
		contactBuffersHead: ContactBufferHeader* \\
		cachedArbiters: HashSet* \\
		pooledArbiters: Array* \\
		allocatedBuffers: Array* \\
		locked: \UZ \\
		usesWildcards: \B \\
		collisionHandlers: HashSet* \\
		defaultHandler: CollisionHandler \\
		skipPostStep: \B \\
		postStepCallbacks: Array* \\
		staticBody: Body* \\
		_staticBody: Body 
	\end{multicols}

	\noindent \textbf{PostStepCallback:}
	\begin{multicols}{3}
		\noindent func: PostStepFunc \\
		key: void* \\
		data: void* 
	\end{multicols}
	
	\noindent \textbf{CollisionHandler:}
	\begin{multicols}{3}
		\noindent typeA: CollisionType \\
		typeB: CollisionType \\
		beginFunc: CollisionBeginFunc \\
		preSolveFunc: CollisionPreSolveFunc \\
		postSolveFunc: CollisionPostSolveFunc \\
		separateFunc: CollisionSeparateFunc \\
		userData: DataPointer
	\end{multicols}
	
	\noindent \textbf{ArbiterFilterContext:}
	\begin{multicols}{3}
		\noindent space: Space* \\
		body: Body* \\
		shape: Shape* 
	\end{multicols}
	
	\noindent \textbf{SpaceShapeContext:}
	\begin{multicols}{2}
		\noindent func: SpaceShapeIteratorFunc \\
		data: void*
	\end{multicols}
	
	\noindent \textbf{ContactBufferHeader:}
	\begin{multicols}{3}
		\noindent stamp: Timestamp \\
		next: ContactBufferHeader* \\
		numContacts: \UZ
	\end{multicols}
	
	\noindent \textbf{ContactBuffer:}
	\begin{multicols}{2}
		\noindent header: ContactBufferHeader \\
		contacts: array(Contact) 
	\end{multicols}
	

%\subsubsection{State Invariant} 

\subsubsection{Assumptions} \label{SecASpace}
	spaceAlloc or spaceNew are called before any other access programs.

\subsubsection{Access Program Semantics}  \label{SecAPSSpace}

\renewcommand*{\arraystretch}{\funcPadding}
	\begin{longtable*}{@{} p{3.0cm} l p{\colDescrip}} 
	\textbf{spaceAlloc:} & \textbf{Input:} & None. \\
	& \textbf{Exceptions:} & None.\\
	& \textbf{Transition:} & None. \\
	& \textbf{Output:} & spaceAlloc heap-allocates a new Space object and returns a pointer to it as output.  \newfunc
	
	\textbf{spaceInit:} & \textbf{Input:} & spaceInit accepts a Space pointer as input. \\
	& \textbf{Exceptions:} & None.\\
	& \textbf{Transition:} & spaceInit initializes the input Space, allocating new data structures accordingly and zero-initializing all other variables. \\
	& \textbf{Output:} & spaceInit returns a pointer to the initialized Space.  \newfunc
	
	\textbf{spaceNew:} & \textbf{Input:} & None.. \\
	& \textbf{Exceptions:} & None.\\
	& \textbf{Transition:} & spaceNew allocates and initializes a new Space object. \\
	& \textbf{Output:} & spaceNew returns a pointer to the new Space.  \newfunc	
	
	\textbf{spaceDestroy:} & \textbf{Input:} & spaceDestroy accepts a Space pointer as input. \\
	& \textbf{Exceptions:} & None.\\
	& \textbf{Transition:} & spaceDestroy frees all dynamically-allocated data structures in the input Space and their contents, if necessary. \\
	& \textbf{Output:} & None.  \newfunc
	
	\textbf{spaceFree:} & \textbf{Input:} & spaceFree accepts a Space pointer as input. \\
	& \textbf{Exceptions:} & None.\\
	& \textbf{Transition:} & spaceFree frees the input Space and all of its dynamically-allocated variables. \\
	& \textbf{Output:} & None.  \newfunc
	
	\textbf{spaceGet:} & \textbf{Input:} & Each spaceGet function accepts a Space pointer as input. \\
	& \textbf{Exceptions:} & None. \\
	& \textbf{Transition:} & None. \\
	& \textbf{Output:} & Each spaceGet function returns the value of their corresponding parameter.  \newfunc
	
	\textbf{spaceSet:} & \textbf{Input:} & Each spaceSet function accepts a Space pointer and their corresponding parameter as input. \\
	& \textbf{Exceptions:} & Various, see \ref{SecEAPSpace}. spaceSetStaticBody may throw an AttachedStaticBody exception if the user attempts to change the designated static body while the existing body still has shapes attached to it. \\
	& \textbf{Transition:} & Each spaceSet function sets the value of the corresponding field with the input parameter. For spaceSetStaticBody, it also changes the Body's associated Space to the input Space.\\
	& \textbf{Output:} & None.  \newfunc
	
	\textbf{spaceIsLocked:} & \textbf{Input:} & spaceIsLocked accepts a Space pointer as input.\\
	& \textbf{Exceptions:} & None.\\
	& \textbf{Transition:} & None. \\
	& \textbf{Output:} & spaceIsLocked returns true if the value of the locked variable is positive, and false otherwise.  \newfunc
	
	\textbf{spaceAdd:} & \textbf{Input:} & Each spaceAdd function accepts a Space pointer as input. spaceAddCollisionHandler accepts two additional CollisionTypes, while spaceAddWildcardHandler only accepts one additional CollisionType. spaceAddShape and spaceAddBody accepts additional Shape and Body pointers as input, respectively. \\
	& \textbf{Exceptions:} & Various, see \ref{SecEAPSpace}. spaceAddShape and spaceAddBody may throw a DuplicateShape/DuplicateBody exception if the object being added already exists in the input Space, an AttachedShape/AttachedBody exception if it is already attached to another Space, or a SpaceLocked exception if the input Space is locked.\\
	& \textbf{Transition:} & Functions that add CollisionHandlers will initialize new handlers depending on the function and input CollisionTypes (or use the default), hash the handler, and add it to the input Space's collision handlers. spaceAddShape and spaceAddBody will add the body to the appropriate spatial index and array of the input Space, respectively, and the former will update the input Shape accordingly. \\
	& \textbf{Output:} & Each spaceAdd function returns the object that has been added as output.  \newfunc
	
	\textbf{spaceFilter Arbiters:} & \textbf{Input:} &  spaceFilterArbiters accepts Space, Body and Shape pointers as input.\\
	& \textbf{Exceptions:} & None.\\
	& \textbf{Transition:} & spaceFilterArbiters will remove Arbiters that are associated with the input Body and/or Shape from the Space's cached Arbiters. \\
	& \textbf{Output:} & None.  \newfunc
	
	\textbf{spaceRemove:} & \textbf{Input:} & Each spaceRemove function accepts a Space pointer and a pointer to the corresponding object as input.\\
	& \textbf{Exceptions:} & Each spaceRemove function may throw a Shape/BodyNotFound exception if the object to be removed does not exist within the input Space or a SpaceLocked exception if the Space is locked. Additionally, spaceRemoveBody will throw a MainStaticBody exception if the user attempts to remove the Space's designated static Body. \\
	& \textbf{Transition:} & Each spaceRemove function will detach the object and the input Space from each other. Additionally, spaceRemoveShape will detach the Shape from its Body. \\
	& \textbf{Output:} & None.  \newfunc
	
	\textbf{spaceContains:} & \textbf{Input:} & Each spaceContains function accepts a Space pointer and a pointer to the corresponding object as input.\\
	& \textbf{Exceptions:} & None.\\
	& \textbf{Transition:} & None. \\
	& \textbf{Output:} & Each spaceContains function returns true if the input Space contains the input object, and false otherwise.  \newfunc
	
	\textbf{spaceEach:} & \textbf{Input:} & Each spaceEach function accepts a Space pointer, a function pointer to the corresponding iterator, and a void pointer as inputs. \\
	& \textbf{Exceptions:} & None.\\
	& \textbf{Transition:} & Each spaceEach function will iterate through the Space's Bodies or Shapes, depending on the function's corresponding parameter, and apply the given function to each object using the data in the input void pointer. \\
	& \textbf{Output:} & None.  \newfunc
	
	\textbf{spaceReindex:} & \textbf{Input:} & Each spaceReindex function accepts a Space pointer as input. spaceReindexShape and spaceReindexShapesForBody accepts an additional Shape and Body pointer, respectively.\\
	& \textbf{Exceptions:} & Each spaceReindex function may throw a SpaceLocked exception if the input Space is locked. \\
	& \textbf{Transition:} & spaceReindexStatic reindexes all the static Shapes for the Space. spaceReindexShape will only reindex the input Shape in its spatial index, and spaceReindexShapesForBody will reindex all the shapes attached to the input Body in their respective spatial indices. \\
	& \textbf{Output:} & None.  \newfunc
	
	\textbf{spacePushFresh Contact Buffer:} & \textbf{Input:} & spacePushFreshContactBuffer accepts a Space pointer as input. \\
	& \textbf{Exceptions:} & None.\\
	& \textbf{Transition:} & spacePushFreshContactBuffer allocates a new ContactBufferHeader, initializes it and sets it to the input Space's contact buffer head. \\
	& \textbf{Output:} & None.  \newfunc
	
	\textbf{contactBuffer GetArray:} & \textbf{Input:} & contactBufferGetArray accepts a Space pointer as input. \\
	& \textbf{Exceptions:} & None.\\
	& \textbf{Transition:} & contactBufferGetArray pushes a fresh ContactBufferHeader if the contact buffer is about to overflow. \\
	& \textbf{Output:} & contactBufferGetArray returns a pointer to an array of Contact structures as output.  \newfunc
	
	\textbf{spaceCollide Shapes:} & \textbf{Input:} & spaceCollideShapes accepts two Shape pointers, a Collision ID and a Space pointer as inputs. \\
	& \textbf{Exceptions:} & None.\\
	& \textbf{Transition:} & spaceCollideShapes tests if the input Shapes can be collided using \hyperref[SecLFSpace]{queryReject}. If it fails, it returns the input ID. Otherwise, it performs collision detection and makes a new CollisionInfo structure. If a collision occurs, the function modifies the number of Contacts for the input Space, updates the Arbiter for the input Shapes, calls the Arbiter's collision handler functions and updates the Arbiter's timestamp. Otherwise, no further transitions are made. In either case, the function returns the ID of the generated CollisionInfo structure. \\
	& \textbf{Output:} & spaceCollideShapes returns a CollisionID as output.  \newfunc
	
	\textbf{spaceArbiter SetFilter:} & \textbf{Input:} & spaceArbiterSetFilter accepts one Arbiter and one Space pointer as inputs. \\
	& \textbf{Exceptions:} & None.\\
	& \textbf{Transition:} & spaceArbiterSetFilter caches the input Arbiter if it was uncached and used recently. If the time since the Arbiter was last used exceeds the Space's collision persistence, the function will also remove the Arbiter from the Space and recycle it. \\
	& \textbf{Output:} & spaceArbiterSet returns true if both Bodies attached to the Arbiter are static bodies or if the Arbiter was cached. It returns false if the Arbiter is removed.  \newfunc
	
	\textbf{spaceLock:} & \textbf{Input:} & spaceLock accepts a Space pointer as input. \\
	& \textbf{Exceptions:} & None.\\
	& \textbf{Transition:} & spaceLock locks the input Space by modifying its locked variable. \\
	& \textbf{Output:} & None.  \newfunc
	
	\textbf{spaceUnlock:} & \textbf{Input:} & spaceUnlock accepts a Space pointer and a Boolean value as input. \\
	& \textbf{Exceptions:} & spaceUnlock may throw a SpaceLockUnderflow exception if the locked field of the input Space falls to a negative value during the function's transition. \\
	& \textbf{Transition:} & spaceUnlock will unlock the input Space by modifying its locked variable. If the input Boolean is true, and the Space is set to not skip post-step callbacks, the function will also run those callbacks. \\
	& \textbf{Output:} & None.  \newfunc
	
	\textbf{spaceArrayFor BodyType:} & \textbf{Input:} & spaceArrayForBodyType accepts a Space pointer and a BodyType value as inputs. \\
	& \textbf{Exceptions:} & None.\\
	& \textbf{Transition:} & None. \\
	& \textbf{Output:} & spaceArrayForBodyType returns an Array pointer to the input Space's array of bodies, corresponding to the input BodyType.  \newfunc
	
	\textbf{shapeUpdate Func:} & \textbf{Input:} & shapeUpdateFunc accepts a Shape and a void pointer as inputs. \\
	& \textbf{Exceptions:} & None.\\
	& \textbf{Transition:} & shapeUpdateFunc calls updates and caches the input Shape's BB. \\
	& \textbf{Output:} & None.  \newfunc
	
	\textbf{spaceStep:} & \textbf{Input:} & spaceStep accepts a Space pointer and a double as inputs. \\
	& \textbf{Exceptions:} & None.\\
	& \textbf{Transition:} & spaceStep updates the input Space following the specified timestep (input double). If the timestep is zero, the function exits immediately. Otherwise, it updates the Space's timestamp and current timestep, resets Arbiter lists and locks the Space. While the Space is locked, the function calculates new positions of Bodies in the Space and collides Shapes as necessary, before unlocking the Space without running post-step callbacks. Next, it locks the Space once again, clears cached Arbiters, pre-processes the Arbiters, updates the velocities of Bodies in the Space, applies cached impulses, runs the impulse solver, and then runs post-solve callbacks on the Arbiters. Finally, it unlocks the Space and runs post-step callbacks. \\
	& \textbf{Output:} & None.  \newfunc
\end{longtable*}

\subsubsection{Local Constants} \label{SecLCSpace}
	collisionHandlerDefault: CollisionHandler \\
	collisionHandlerDefault := \{\hyperref[SecECControl]{WILDCARD_COLLISION_TYPE}, WILDCARD_COLLISION_TYPE, \hyperref[SecLFSpace]{defaultBegin}, \hyperref[SecLFSpace]{defaultPreSolve}, \hyperref[SecLFSpace]{defaultPostSolve}, \hyperref[SecLFSpace]{defaultSeparate}, NULL\}

\subsubsection{Local Functions} \label{SecLFSpace}

\renewcommand*{\arraystretch}{\funcPadding}
	\begin{longtable*}{@{} p{3.0cm} l p{\colDescrip}}
	\iffalse
	% Default equality function for Arbiter HashSets. Used in space initialization.
	\textbf{arbiterSetEql:} & \textbf{Input:} & arbiterSetEql accepts a pointer to an array of Shape pointers and an Arbiter pointer as inputs.\\
	& \textbf{Exceptions:} & None.\\
	& \textbf{Transition:} & None. \\
	& \textbf{Output:} & arbiterSetEql returns true if the Shapes in the input array are equal to the input Arbiter's Shapes, and false otherwise.  \newfunc
	
	% Default equality function for CollisionHandler HashSets. Used in space initialization.
	\textbf{handlerSetEql:} & \textbf{Input:} & handlerSetEql accepts two CollisionHandler pointers as inputs. \\
	& \textbf{Exceptions:} & None.\\
	& \textbf{Transition:} & None. \\
	& \textbf{Output:} & handlerSetEql returns true if the CollisionTypes of both handlers are equal, and false otherwise.  \newfunc
	
	% Transformation function used to insert CollisionHandlers into a HashSet. Used in functions that add handlers.
	\textbf{handlerSet Trans:} & \textbf{Input:} & handlerSetTrans accepts a CollisionHandler pointer and a void pointer as inputs. \\
	& \textbf{Exceptions:} & None.\\
	& \textbf{Transition:} & handlerSetTrans clones the input CollisionHandler. \\
	& \textbf{Output:} & handlerSetTrans returns a void pointer to the cloned handler.  \newfunc
	\fi
	
	\textbf{default:} & \textbf{Input:} & Each default function accepts an Arbiter pointer, a Space pointer and a void pointer as inputs. \\
	& \textbf{Exceptions:} & None.\\
	& \textbf{Transition:} & Each default function calls their respective wildcard functions for Shape A and B of the Arbiter. For example, defaultBegin calls arbiterCallWildcardBeginA and arbiterCallWildcardBeginB with the input Arbiter and Space, defaultPreSolve calls arbiterCallWildcardPreSolveA and arbiterCallWildcardPreSolveB, and so on. Part of the default collision handler, \hyperref[SecLCSpace]{collisionHandlerDefault}. \\
	& \textbf{Output:} & defaultBegin and defaultPreSolve applies Boolean AND on the result of both wildcard calls and returns the result. defaultPostSolve and defaultSeparate do not return any values.  \newfunc
	
	\textbf{alwaysCollide:} & \textbf{Input:} & alwaysCollide takes an Arbiter pointer, a Space pointer and a void pointer as inputs. \\
	& \textbf{Exceptions:} & None.\\
	& \textbf{Transition:} & None. \\
	& \textbf{Output:} & alwaysCollide always returns true. Part of \hyperref[SecECSpace]{collisionHandlerDoNothing} that does nothing.  \newfunc
	
	\textbf{doNothing:} & \textbf{Input:} & doNothing takes an Arbiter pointer, a Space pointer and a void pointer as inputs. \\
	& \textbf{Exceptions:} & None.\\
	& \textbf{Transition:} & None. Part of \hyperref[SecECSpace]{collisionHandlerDoNothing} that does nothing. \\
	& \textbf{Output:} & None.  \newfunc \pagebreak %stylebreak
	
	\iffalse
	% An internal helper function that automatically retrieves the velocity functions for Shapes in BBTrees. Used in space initialization.
	\textbf{shapeVelocity Func:} & \textbf{Input:} & shapeVelocityFunc accepts a Shape pointer as input. \\
	& \textbf{Exceptions:} & None.\\
	& \textbf{Transition:} & None. \\
	& \textbf{Output:} & shapeVelocityFunc returns the velocity function of the Body associated to the input Shape.  \newfunc 
	
	% A binary wrapper of the standard unary free function. Used for individually freeing HashSet elements.
	\textbf{freeWrap:} & \textbf{Input:} & freeWrap accepts two void pointers as inputs. \\
	& \textbf{Exceptions:} & None.\\
	& \textbf{Transition:} & freeWrap frees the first input pointer. \\
	& \textbf{Output:} & None.  \newfunc
	\fi
	
	\textbf{spaceUse WildcardDefaultHandler:} & \textbf{Input:} & spaceUseWildcardDefaultHandler accepts a Space pointer as input. \\
	& \textbf{Exceptions:} & None.\\
	& \textbf{Transition:} & The function sets the Space to use wildcards and copies \hyperref[SecLCSpace]{collisionHandlerDefault} to the Space's default handler. Called by \hyperref[SecAPSSpace]{spaceAddDefaultCollisionHandler}. \\
	& \textbf{Output:} & None.  \newfunc
	
	\iffalse
	% HashSet filtering function for Arbiters matching the Body and Shape in the filtering context. Called by spaceFilterArbiters, but commented out because it doesn't really add detail to that function.
	\textbf{cachedArbiters Filter:} & \textbf{Input:} & cachedArbitersFilter accepts an Arbiter pointer and a pointer to an ArbiterFilterContext structure. \\
	& \textbf{Exceptions:} & None.\\
	& \textbf{Transition:} & cachedArbitersFilter is the filtering function used by \hyperref[SecAPSSpace]{spaceFilterArbiters} to remove and recycle cached Arbiters that are associated with the Body and/or Shape defined in the input ArbiterFilterContext structure. \\
	& \textbf{Output:} & cachedArbitersFilter returns true if no Arbiters were removed, and false otherwise.  \newfunc
	
	% Spatial index iterator for Shapes. Called by spaceEachShape, but doesn't add detail to the behavior so commented out.
	\textbf{spaceEachShape Iterator:} & \textbf{Input:} & spaceEachShapeIterator accepts a Shape pointer and a pointer to a SpaceShapeContext structure as inputs. \\
	& \textbf{Exceptions:} & None.\\
	& \textbf{Transition:} & spaceEachShapeIterator calls the function in the input SpaceShapeContext structure with the input Shape and the data pointer defined in the structure. \\
	& \textbf{Output:} & None.  \newfunc
	\fi
	
	\textbf{spaceAlloc ContactBuffer:} & \textbf{Input:} & spaceAllocContactBuffer accepts a Space pointer as input. \\
	& \textbf{Exceptions:} & None.\\
	& \textbf{Transition:} & spaceAllocContactBuffer heap-allocates a new contact buffer and adds it to the input Space's allocated buffers. Called by \hyperref[SecAPSSpace]{spacePushFreshContactBuffer} to allocate a new ContactBufferHeader. \\
	& \textbf{Output:} & spaceAllocContactBuffer returns a pointer to the allocated ContactBuffer as output, cast as a ContactBufferHeader pointer.  \newfunc
	
	\textbf{contactBuffer HeaderInit:} & \textbf{Input:} & contactBufferHeaderInit accepts a ContactBufferHeader pointer, a Timestamp and another ContactBufferHeader pointer as input. \\
	& \textbf{Exceptions:} & None.\\
	& \textbf{Transition:} & contactBufferHeaderInit initializes the first input ContactBufferHeader. It modifies its timestamp to the given Timestamp, its next header to be the next header of the second input ContactBufferHeader  (or to the first input header if the second one is null), and its number of Contacts to zero. Called by \hyperref[SecAPSSpace]{spacePushFreshContactBuffer} to initialize a ContactBufferHeader. \\
	& \textbf{Output:} & contactBufferHeaderInit returns a pointer to the initialized ContactBufferHeader. \newfunc \pagebreak %stylebreak
	
	\textbf{spacePush Contacts:} & \textbf{Input:} & spacePushContacts accepts a Space pointer and an integer as input. \\
	& \textbf{Exceptions:} & spacePushContacts may throw a BufferOverflow exception if the input integer exceeds the \hyperref[SecECArbiter]{MAX_CONTACTS_PER_ARBITER}. Called by \hyperref[SecAPSSpace]{spaceCollideShapes} to process collisions. \\
	& \textbf{Transition:} & spacePushContacts increases the number of Contacts of the input Space's contact buffer head by the given integer. \\
	& \textbf{Output:} & None.  \newfunc
	
	\textbf{spacePop Contacts:} & \textbf{Input:} & spacePopContacts accepts a Space pointer and an integer as inputs. \\
	& \textbf{Exceptions:} & None.\\
	& \textbf{Transition:} & spacePopContacts decrements the number of Contacts of the input Space's contact buffer head by the input integer. Called by \hyperref[SecAPSSpace]{spaceCollideShapes} to process collisions. \\
	& \textbf{Output:} & None.  \newfunc
	
	\textbf{queryReject:} & \textbf{Input:} & queryReject accepts two Shape pointers as input. \\
	& \textbf{Exceptions:} & None.\\
	& \textbf{Transition:} & None. \\
	& \textbf{Output:} & queryReject tests for collision conditions; in particular, it tests if the bounding boxes of both input Shapes overlap and if they belong to different Bodies. If all tests pass, the function returns true. Otherwise, it returns false. Called by \hyperref[SecAPSSpace]{spaceCollideShapes} to validate collision. \newfunc
	
	\textbf{spaceArbiter SetTrans:} & \textbf{Input:} & spaceArbiterSetTrans accepts a pointer to an array of Shape pointers and a Space pointer. \\
	& \textbf{Exceptions:} & spaceArbiterSetTrans may throw an InsufficientBufferSize exception if the input Space has no pooled Arbiters and the size of an Arbiter object exceeds the buffer size (\hyperref[SecECControl]{BUFFER_BYTES}). \\
	& \textbf{Transition:} & If the input Space has no pooled Arbiters, the function heap-allocates a new buffer, adds it to the Space's allocated buffers and adds new Arbiters to the Space's list of pooled Arbiters. It then obtains an Arbiter from the list and initializes it with the Shapes in the input array. Called by \hyperref[SecAPSSpace]{spaceCollideShapes} to create Arbiters for colliding Shapes from pooled ones. \\
	& \textbf{Output:} & spaceArbiterSetTrans returns a pointer to the initialized Arbiter.  \newfunc
\end{longtable*}
	
%%%%%%%%%%%%%%%%%%%% ARBITER MODULE %%%%%%%%%%%%%%%%%%%%%%%

\section{MIS of the Arbiter Module} \label{MISArbiter}

\subsection{Module Name: Arbiter}

\subsection{Uses} \label{SecUArbiter}
	\Body, \Shape, \Space, \Control, \Vector

\subsection{Interface Syntax}

\subsubsection{Exported Constants} \label{SecECArbiter}
	MAX_CONTACTS_PER_ARBITER: \UZ \\
	MAX_CONTACTS_PER_ARBITER := 2
	
%\subsubsection{Exported Variables}

\subsubsection{Exported Data Types} \label{SecEDTArbiter}
	ArbiterState: enum \\
	ArbiterThread: struct \\
	Contact: struct \\
	CollisionInfo: struct \\
	Arbiter: struct \\
	ContactPointSet: struct
	
\pagebreak % for pagebreak

\subsubsection{Exported Access Programs} \label{SecEAPArbiter}
	\renewcommand*{\arraystretch}{1.2}
	\begin{longtable}{| y | x{3.5cm} | y | x{3.5cm} |}
	\hline \textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions} \\ \hline 
	arbiterInit & Arbiter*, Shape*, Shape* & Arbiter* & - \\ \hline
	arbiterThreadForBody & Arbiter*, Body* & ArbiterThread & - \\ \hline
	arbiterUnthread & Arbiter* & - & - \\ \hline
	arbiterUpdate & Arbiter*, CollisionInfo*, Space* & - & - \\ \hline
	arbiterPreStep & Arbiter*, double, double, double & - & - \\ \hline
	arbiterApplyCachedImpulse & Arbiter*, double & - & - \\ \hline
	arbiterApplyImpulse & Arbiter* & - & - \\ \hline
	arbiterNext & Arbiter*, Body* & Arbiter* & - \\ \hline
	arbiterGetRestitution & Arbiter* & double & - \\ \hline
	arbiterGetFriction & Arbiter* & double & - \\ \hline
	arbiterGetSurfaceVelocity & Arbiter* & Vector & - \\ \hline
	arbiterGetCount & Arbiter* & int & - \\ \hline
	arbiterGetNormal & Arbiter* & Vector & - \\ \hline
	arbiterGetPointA & Arbiter*, int & Vector & ContactIndexOutOf Bounds \\ \hline
	arbiterGetPointB & Arbiter*, int & Vector & ContactIndexOutOf Bounds \\ \hline
	arbiterGetDepth & Arbiter*, int & double & ContactIndexOutOf Bounds \\ \hline
	arbiterGetContactPointSet & Arbiter* & ContactPointSet & - \\ \hline
	arbiterGetShapes & Arbiter*, Shape**, Shape** & - & \\ \hline
	arbiterGetBodies & Arbiter*, Body**, Body** & - & \\ \hline
	arbiterSetRestitution & Arbiter*, double & - & - \\ \hline
	arbiterSetFriction & Arbiter*, double & - & - \\ \hline
	arbiterSetSurfaceVelocity & Arbiter*, Vector & - & - \\ \hline
	arbiterSetContactPointSet & Arbiter*, ContactPointSet* & - & ImmutableNum Contacts \\ \hline
	arbiterIsFirstContact & Arbiter* & Boolean & - \\ \hline
	arbiterIsRemoval & Arbiter* & Boolean & - \\ \hline
	arbiterIgnore & Arbiter* & Boolean & - \\ \hline
	arbiterTotalImpulse & Arbiter* & Vector & - \\ \hline
	arbiterTotalKE & Arbiter* & double & - \\ \hline
	arbiterCallWildcardBeginA & Arbiter*, Space* & Boolean & - \\ \hline
	arbiterCallWildcardBeginB & Arbiter*, Space* & Boolean & - \\ \hline
	arbiterCallWildcardPreSolveA & Arbiter*, Space* & Boolean & - \\ \hline
	arbiterCallWildcardPreSolveB & Arbiter*, Space* & Boolean & - \\ \hline
	arbiterCallWildcardPostSolveA & Arbiter*, Space* & - & - \\ \hline
	arbiterCallWildcardPostSolveB & Arbiter*, Space* & - & - \\ \hline
	arbiterCallWildcardSeparateA & Arbiter*, Space* & - & - \\ \hline
	arbiterCallWildcardSeparateB & Arbiter*, Space* & - & - \\ \hline
\end{longtable}

\subsection{Interface Semantics}

\subsubsection{State Variables} \label{SecSVArbiter}
	$\mathbf{ArbiterState} \in \{\text{ARBITER_STATE_FIRST_COLLISION}, \text{ARBITER_STATE_NORMAL}, \\ \text{ARBITER_STATE_IGNORE}, \text{ARBITER_STATE_CACHED}, \text{ARBITER_STATE_INVALIDATED}\}$ 
	~\newline
	\textbf{ArbiterThread:} 
	\begin{multicols}{2}
		\noindent next: Arbiter* \\
		prev: Arbiter*
	\end{multicols}
	\noindent \textbf{Contact:}
	\begin{multicols}{3}
		\noindent r1: Vector \\
		r2: Vector \\
		nMass: \R \\
		tMass: \R \\
		bounce: \R \\
		jnAcc: \R \\
		jtAcc: \R \\
		jBias: \R \\
		bias: \R \\
		hash: HashValue
	\end{multicols}
	
	\noindent \textbf{CollisionInfo:}
	\begin{multicols}{3}
		\noindent a: Shape* (constant) \\
		b: Shape* (constant) \\
		id: CollisionID \\
		normal: Vector \\
		count: int \\
		arr: Contact*
	\end{multicols}
	
	\pagebreak % for pagebreak
	
	\noindent \textbf{Arbiter:}
	\begin{multicols}{3}
		\noindent elast: \R \\
		fric: \R \\
		surfaceVel: Vector \\
		a: Shape* (constant) \\
		b: Shape* (constant) \\
		bodyA: Body* \\
		bodyB: Body* \\
		threadA: ArbiterThread \\
		threadB: ArbiterThread \\
		count: \Z \\
		contacts: Contact* \\
		normal: Vector \\
		handler: CollisionHandler* \\
		handlerA: CollisionHandler* \\
		handlerB: CollisionHandler* \\
		swapped: \B \\
		stamp: Timestamp \\
		state: ArbiterState
	\end{multicols}
	\noindent \textbf{ContactPointSet:} \\
	~\newline
		\noindent count: \Z \\
		normal: Vector \\
		points: array(\{pointA: Vector, pointB: Vector, distance: \R\}: struct)
		
%\subsubsection{State Invariant} 	

\subsubsection{Assumptions} \label{SecAArbiter}
	All input pointers are assumed to be non-null.

\subsubsection{Access Program Semantics} \label{SecAPSArbiter}

\renewcommand*{\arraystretch}{\funcPadding}
	\begin{longtable*}{@{} p{3.3cm} l p{\colDescrip}} 
	\textbf{arbiterInit:} & \textbf{Input:} & arbiterInit accepts an Arbiter pointer and two Shape pointers as input. \\
	& \textbf{Exceptions:} & None.\\
	& \textbf{Transition:} & arbiterInit initializes the input Arbiter. Its state is set to \hyperref[SecSVArbiter]{ARBITER_STATE_FIRST_COLLISION}. Its Shapes and Bodies are set to the input Shapes and their associated Bodies, and all other fields are zero-initialized. \\
	& \textbf{Output:} & arbiterInit returns a pointer to the initialized Arbiter as output.  \newfunc
	
	\textbf{arbiterThread ForBody:} & \textbf{Input:} & arbiterThreadForBody accepts an Arbiter pointer and a Body pointer as inputs. \\
	& \textbf{Exceptions:} & None.\\
	& \textbf{Transition:} & None. \\
	& \textbf{Output:} & arbiterThreadForBody returns the input Arbiter's ArbiterThread which corresponds to the input Body.  \newfunc \pagebreak %stylebreak
	
	\textbf{arbiterUnthread:} & \textbf{Input:} & arbiterUnthread accepts an Arbiter pointer as input. \\
	& \textbf{Exceptions:} & None.\\
	& \textbf{Transition:} & arbiterUnthread calls \hyperref[SecLFArbiter]{unthreadHelper} on the input Arbiter's Bodies to remove this Arbiter from the thread. \\
	& \textbf{Output:} & None.  \newfunc
	
	\textbf{arbiterUpdate:} & \textbf{Input:} & arbiterUpdate accepts an Arbiter pointer, a CollisionInfo pointer and a Space pointer as inputs. \\
	& \textbf{Exceptions:} & None.\\
	& \textbf{Transition:} & arbiterUpdate updates the Arbiter's state after a collision using the input CollisionInfo and Space. If the Arbiter had been cached, it changes the state to \hyperref[SecSVArbiter]{ARBITER_STATE_FIRST_COLLISION}. \\
	& \textbf{Output:} & None.  \newfunc
	
	\textbf{arbiterPreStep:} & \textbf{Input:} & arbiterPreStep accepts an Arbiter pointer and three doubles as inputs. \\
	& \textbf{Exceptions:} & None.\\
	& \textbf{Transition:} & arbiterPreStep calculates the mass normal, mass tangent, bias velocity and bounce velocity for each of the input Arbiter's contacts, using the three input doubles which represent the timestep, collision slop and collision bias, respectively. \\
	& \textbf{Output:} & None.  \newfunc
	
	\textbf{arbiterApply CachedImpulse:} & \textbf{Input:} & arbiterApplyCachedImpulse accepts an Arbiter pointer and a double as inputs. \\
	& \textbf{Exceptions:} & None.\\
	& \textbf{Transition:} & arbiterApplyCachedImpulse applies the impulses stored in the input Arbiter's contacts to its Bodies, using the input double as a timestep coefficient. \\
	& \textbf{Output:} & None.  \newfunc \pagebreak % stylebreak
	
	\textbf{arbiterApply Impulse:} & \textbf{Input:} & arbiterApplyImpulse accepts an Arbiter pointer as input. \\
	& \textbf{Exceptions:} & None.\\
	& \textbf{Transition:} & arbiterApplyImpulse applies all impulses stored in the input Arbiter's contacts to its Bodies. \\
	& \textbf{Output:} & None.  \newfunc
	
	\textbf{arbiterNext:} & \textbf{Input:} & arbiterNext accepts an Arbiter pointer and a Body pointer as inputs. \\
	& \textbf{Exceptions:} & None.\\
	& \textbf{Transition:} & None. \\
	& \textbf{Output:} & arbiterNext returns a pointer to the next Arbiter from the input Arbiter's ArbiterThread which corresponds to the input Body.  \newfunc
	
	\textbf{arbiterGet:} & \textbf{Input:} & Each arbiterGet function accepts an Arbiter pointer as input. arbiterGetPointA, arbiterGetPointB and arbiterGetDepth accept an additional integer. arbiterGetShapes accepts two additional pointers to Shape pointers, while arbiterGetBodies accepts two additional pointers to Body pointers. \\
	& \textbf{Exceptions:} & arbiterGetPointA, arbiterGetPointB and arbiterGetDepth may throw a ContactIndexOutOfBounds exception when the input integer exceeds the number of contact points for the input Arbiter. \\
	& \textbf{Transition:} & arbiterGetContactPointSet initializes a new ContactPointSet for the input Arbiter using its array of Contacts. arbiterGetShapes and arbiterGetBodies retrieve the input Arbiter's Shapes and Bodies, respectively, and store them in the input pointers. All other arbiterGet functions make no transition. \\
	& \textbf{Output:} & Each arbiterGet function, except for arbiterGetShapes and arbiterGetBodies, returns the value of their corresponding parameter.  \newfunc
	
	\textbf{arbiterSet:} & \textbf{Input:} & Each arbiterSet function accepts an Arbiter pointer and their corresponding parameter as inputs. In particular, arbiterSetContactPointSet accepts a ContactPointSet pointer as input. \\
	& \textbf{Exceptions:} & arbiterSetContactPointSet may throw an ImmutableNumContacts exception if the number of contact points in the input ContactPointSet differs from the current number of contact points of the input Arbiter. \\
	& \textbf{Transition:} & Each arbiterSet function sets the value of their corresponding parameter with the input value. In particular, arbiterSetContactPointSet modifies the contents of the input Arbiter's array of Contacts according to the input ContactPointSet. \\
	& \textbf{Output:} & None.  \newfunc
	
	\textbf{arbiterIs:} & \textbf{Input:} & Each arbiterIs function accepts an Arbiter pointer as input.  \\
	& \textbf{Exceptions:} & None.\\
	& \textbf{Transition:} & None. \\
	& \textbf{Output:} & Each arbiterIs function checks the state of the input Arbiter and returns a Boolean value according to the result.  \newfunc
	
	\textbf{arbiterIgnore:} & \textbf{Input:} & arbiterIgnore accepts an Arbiter pointer as input. \\
	& \textbf{Exceptions:} & None.\\
	& \textbf{Transition:} & arbiterIgnore sets the state of the input Arbiter to \hyperref[SecSVArbiter]{ARBITER_STATE_IGNORE}.\\
	& \textbf{Output:} & arbiterIgnore always returns false.  \newfunc
	
	\textbf{arbiterTotal:} & \textbf{Input:} & each arbiterTotal function accepts an Arbiter pointer as input. \\
	& \textbf{Exceptions:} & None.\\
	& \textbf{Transition:} & None. \\
	& \textbf{Output:} & Each arbiterTotal computes the total quantity of the corresponding parameter (impulse or kinetic energy) and returns the value as a double.  \newfunc
	
	\textbf{arbiterCall Wildcard:} & \textbf{Input:} & Each arbiterCallWildcard function accepts an Arbiter pointer and a Space pointer as inputs. \\
	& \textbf{Exceptions:} & None.\\
	& \textbf{Transition:} & Each arbiterCallWildcard function calls the corresponding function from the input Arbiter's CollisionHandlers. The input arguments will be the input Arbiter, the input Space and the user data contained in the handler. \\
	& \textbf{Output:} & Each arbiterCallWildcard returns the same value as that returned by the called function; PostSolve and Separate return a Boolean value, while Begin and PreSolve return nothing.  \newfunc
\end{longtable*}

\subsubsection{Local Functions} \label{SecLFArbiter}

\renewcommand*{\arraystretch}{\funcPadding}
	\begin{longtable*}{@{} p{3.0cm} l p{\colDescrip}}
	\textbf{unthread Helper:} & \textbf{Input:} & unthreadHelper accepts an Arbiter pointer and a Body pointer as inputs. \\
	& \textbf{Exceptions:} & None.\\
	& \textbf{Transition:} & unthreadHelper removes the input Arbiter from the ArbiterThread corresponding to the input Body, and may also remove the Arbiter from the Body. Called by \hyperref[SecAPSArbiter]{arbiterUnthread}. \\
	& \textbf{Output:} & None.  \newfunc
	
	\iffalse
	% Helper function that gets the appropriate handler for updating Arbiters after collision. Called by arbiterUpdate.
	\textbf{spaceLookup Handler:} & \textbf{Input:} & spaceLookupHandler accepts a Space pointer, two CollisionType values and a CollisionHandler pointer as inputs. \\
	& \textbf{Exceptions:} & None.\\
	& \textbf{Transition:} & spaceLookupHandler searches the input Space's collision handlers for a handler corresponding to the input CollisionTypes. \\
	& \textbf{Output:} & spaceLookupHandler returns a pointer to the retrieved CollisionHandler. If not found, it returns the input CollisionHandler pointer.  \newfunc \fi
\end{longtable*}

%%%%%%%%%%%%%%%%%%%% CONTROL MODULE %%%%%%%%%%%%%%%%%%%%%%%

\section{MIS of the Control Module} \label{MISControl}

\subsection{Module Name: Chipmunk}

\subsection{Uses} \label{SecUControl}
	This module only uses standard libraries.

\subsection{Interface Syntax}

\subsubsection{Exported Constants} \label{SecECControl}
	M_PI: \R \\
	M_PI := 3.14159265358979323846 \\
	\newline
	VOID_ERR is an empty macro definition. \\
	\newline
	PTR_ERR: void* \\
	PTR_ERR := NULL \\
	\newline
	INT_ERR: \Z \\
	INT_ERR := INT_MIN := -2147483648 \\
	\newline
	DBL_ERR: \R \\
	DBL_ERR := DBL_MIN := $1 \times 10^{-37}$ \\
	\newline
	BUFFER_BYTES: \UZ \\
	BUFFER_BYTES := $32 \times 1024$ = 32678 \\
	\newline
	WILDCARD_COLLISION_TYPE: CollisionType \\
	WILDCARD_COLLISION_TYPE := 0 
	
%\subsubsection{Exported Variables}

\subsubsection{Exported Data Types} \label{SecEDTControl}
	HashValue: pointer-compatible \UZ \\
	DataPointer: void* \\
	CollisionType: pointer-compatible \UZ \\
	Timestamp: \UZ \\
	CollisionID: 32-bit \UZ

\subsubsection{Exported Access Programs} \label{SecEAPControl}
	\iffalse
	% Move this to README?
	Due to the way strings are represented in C, all strings in the following table are equivalent to a pointer to a constant character array (const char*).
	\fi

	\begin{ThreePartTable}
		\centering
		
		\begin{TableNotes}
			\footnotesize
			\item[1] These assertions are defined as macros. They accept a Boolean expression, an error value (see \ref{SecECControl}), and an arbitrary number of arguments consisting of an error message and format parameters.
		\end{TableNotes}
		
	\renewcommand*{\arraystretch}{1.2}
	\begin{longtable}{| y | x{3.5cm} | y | x{3.5cm} |}
			\hline \textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions} \\ \hline 
			message & string, string, int, int, int, string & - & - \\ \hline
			assertSoft & See note \tnote{1} & - & - \\ \hline
			assertWarn & See note \tnote{1} & - & - \\ \hline
			assertHard & See note \tnote{1} & - & - \\ \hline
			fclamp & double, double, double & double & - \\ \hline
			fclamp01 & double & double & - \\ \hline
			flerp & double, double, double & double & - \\ \hline
			flerpconst & double, double, double & double & - \\ \hline
			loopIndices & Vector*, int, int*, int* & - & - \\ \hline
			convexHull & int, Vector*, Vector*, int*, double & int & - \\ \hline
			\insertTableNotes
		\end{longtable}
	\end{ThreePartTable}

\subsection{Interface Semantics}

%\subsubsection{State Variables}
%\textbf{:} 
%\begin{multicols}{2}
	
%\end{multicols}

%\subsubsection{State Invariant} 

%\subsubsection{Assumptions}

\subsubsection{Access Program Semantics} \label{SecAPSControl}

\renewcommand*{\arraystretch}{\funcPadding}
	\begin{longtable*}{@{} p{3.3cm} l p{\colDescrip}} 
	\textbf{message:} & \textbf{Input:} & message accepts two strings, three integers and a third string, followed by an arbitrary number of format arguments for this string. \\
	& \textbf{Exceptions:} & None.\\
	& \textbf{Transition:} & message will print a warning or error message to standard error, depending on the value of the second input integer (which should be non-zero for errors). It will then print the error message (third input string), with all the formatted data, to standard error, followed by the failed condition (first input string) and the source of the error, which includes the filename (second input string) and line number (first input integer). \\
	& \textbf{Output:} & None.  \newfunc
	
	\textbf{assert:} & \textbf{Input:} & Each assert macro accepts a Boolean expression, an error value (see \ref{SecECControl}) and an arbitrary number of arguments including an error message and its format arguments. \\
	& \textbf{Exceptions:} & None.\\
	& \textbf{Transition:} & Each assert macro tests the input Boolean expression. If the test fails, each macro will print the input error message and its formatted message to standard error, and assertSoft and assertHard will abort the program immediately. In UNIT_TEST mode, each assert macro will return the input error value instead of aborting the program. \\
	& \textbf{Output:} & None, normally. In UNIT_TEST mode, they may return the input error value.  \newfunc
	
	\textbf{fclamp:} & \textbf{Input:} & Each fclamp function accepts a double as input. The regular fclamp accepts two additional doubles as inputs. \\
	& \textbf{Exceptions:} & None.\\
	& \textbf{Transition:} & None. \\
	& \textbf{Output:} & fclamp restricts the first input double between the second and third input doubles, which are the min and max thresholds, respectively. It returns the first double if it falls within the specified range, the second double if it falls below the range, and the third double if it falls above the range. Similarly, fclamp01 restricts the input double between 0 and 1. Each fclamp function returns a double.  \newfunc
	
	\textbf{flerp:} & \textbf{Input:} & Each flerp function accepts three doubles as inputs. \\
	& \textbf{Exceptions:} & None.\\
	& \textbf{Transition:} & None. \\
	& \textbf{Output:} & flerp linearly interpolates between the first two input doubles for a percentage specified by the third input double. Similarly, flerpconst linearly interpolates between the first two doubles by no more than a constant specified in the third input double. Each flerp function returns a double.  \newfunc
	
	\textbf{loopIndices:} & \textbf{Input:} & loopIndices accepts a pointer to a Vector array, an integer and two integer pointers as inputs.  \\
	& \textbf{Exceptions:} & None.\\
	& \textbf{Transition:} & loopIndices iterates through the points contained in the input Vector array; the length of the array should be equal to the input integer. The function will determine the 'starting' (leftmost, bottommost) and 'ending' (rightmost, topmost) points in the array. It stores the indices of these starting and ending points in the first and second input integer pointers, respectively. \\
	& \textbf{Output:} & None.  \newfunc
	
	\textbf{convexHull:} & \textbf{Input:} & convexHull accepts an integer, two pointers to Vector arrays, an integer pointer and a double as inputs. \\
	& \textbf{Exceptions:} & None.\\
	& \textbf{Transition:} & convexHull calculates the hull size given by the set of points contained in the first input Vector array. If a valid integer pointer is provided, it will store the index of the first hull point. \\
	& \textbf{Output:} & convexHull returns an integer for the number of points in the convex hull.  \newfunc
\end{longtable*}

\subsubsection{Local Functions} \label{SecLFControl}

\renewcommand*{\arraystretch}{\funcPadding}
	\begin{longtable*}{@{} p{3.3cm} l p{\colDescrip}}
	\textbf{QHullPartition:} & \textbf{Input:} & QHullPartition accepts a pointer to a Vector array, an integer, two Vectors and a double as inputs. \\
	& \textbf{Exceptions:} & None.\\
	& \textbf{Transition:} & QHullPartition partitions the set of points in the convex hull for reduction. Called by \hyperref[SecLFControl]{QHullReduce}. \\
	& \textbf{Output:} & QHullPartition returns an integer as output.  \newfunc
	
	\textbf{QHullReduce:} & \textbf{Input:} & QHullReduce accepts a double, a pointer to a Vector array, an integer, three Vectors and another pointer to a Vector array. \\
	& \textbf{Exceptions:} & None.\\
	& \textbf{Transition:} & QHullReduce simplifies (shrinks) the convex hull by a certain tolerance, which is specified by the input double. Called as a helper for \hyperref[SecLFControl]{convexHull}'s divide-and-conquer approach. \\
	& \textbf{Output:} & QHullReduce returns an integer as output.  \newfunc
\end{longtable*}

%%%%%%%%%%%%%%%%%%%% VECTOR MODULE %%%%%%%%%%%%%%%%%%%%%%%

\section{MIS of the Vector Module} \label{MISVector}

\subsection{Module Name: Vector}

\subsection{Uses} \label{SecUVector}
	This module only uses standard libraries.

\subsection{Interface Syntax}

\subsubsection{Exported Constants} \label{SecECVector}
	VECT_ERR, zeroVect: Vector \\
	VECT_ERR := \{INT_MAX, INT_MIN\} \\
	zeroVect := \{0.0, 0.0\}
	
%\subsubsection{Exported Variables}

\subsubsection{Exported Data Types} \label{SecEDTVector}
	Vector: struct 

\subsubsection{Exported Access Programs} \label{SecEAPVector}
	\renewcommand*{\arraystretch}{1.2}
	\begin{longtable}{| y | x{3.5cm} | y | x{3.5cm} |}
	\hline \textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions} \\ \hline 
	vect & double, double & Vector & - \\ \hline
	vectEqual & Vector, Vector & Boolean & - \\ \hline
	vectAdd & Vector, Vector & Vector & - \\ \hline
	vectSub & Vector, Vector & Vector & - \\ \hline
	vectMult & Vector, double & Vector & - \\ \hline
	vectNeg & Vector & Vector & - \\ \hline
	vectDot & Vector, Vector & double & - \\ \hline
	vectCross & Vector, Vector & double & - \\ \hline
	vectPerp & Vector & Vector & - \\ \hline
	vectRPerp & Vector & Vector & - \\ \hline
	vectProject & Vector, Vector & Vector & - \\ \hline
	vectForAngle & double & Vector & - \\ \hline
	vectToAngle & Vector & double & - \\ \hline
	vectRotate & Vector, Vector & Vector & - \\ \hline
	vectUnrotate & Vector, Vector & Vector & - \\ \hline
	vectLengthSq & Vector & double & - \\ \hline
	vectLength & Vector & double & - \\ \hline
	vectNormalize & Vector & Vector & - \\ \hline
	vectClamp & Vector, double & Vector & - \\ \hline
	vectLerp & Vector, Vector, double & Vector & - \\ \hline
	vectDistSq & Vector, Vector & double & - \\ \hline
	vectDist & Vector, Vector & double & - \\ \hline
	vectNear & Vector, Vector, double & Boolean & - \\ \hline
\end{longtable}

\subsection{Interface Semantics}

\subsubsection{State Variables} \label{SecSVVector}
\textbf{Vector:} 
\begin{multicols}{2}
	\noindent x: \R \\
	y: \R
\end{multicols}

%\subsubsection{State Invariant} 

%\subsubsection{Assumptions}

\subsubsection{Access Program Semantics} \label{SecAPSVector}

\renewcommand*{\arraystretch}{\funcPadding}
	\begin{longtable*}{@{} p{3.3cm} l p{\colDescrip}} 
	\textbf{vect:} & \textbf{Input:} & vect accepts two doubles as input. \\
	& \textbf{Exceptions:} & None.\\
	& \textbf{Transition:} & None. \\
	& \textbf{Output:} & vect returns a new Vector created from the input doubles.  \newfunc
	
	\textbf{vectEqual:} & \textbf{Input:} & vectEqual accepts two Vectors as input. \\
	& \textbf{Exceptions:} & None.\\
	& \textbf{Transition:} & None. \\
	& \textbf{Output:} & vectEqual compares the values of the input Vectors and returns true if they are equal, and false otherwise.  \newfunc
	
	\textbf{vectAdd:} & \textbf{Input:} & vectAdd accepts two Vectors as input. \\
	& \textbf{Exceptions:} & None.\\
	& \textbf{Transition:} & None. \\
	& \textbf{Output:} & vectAdd returns the sum of the input Vectors.  \newfunc
	
	\textbf{vectSub:} & \textbf{Input:} & vectSub accepts two Vectors as input. \\
	& \textbf{Exceptions:} & None.\\
	& \textbf{Transition:} & None. \\
	& \textbf{Output:} & vectSub returns the difference of the input Vectors.  \newfunc
	
	\textbf{vectMult:} & \textbf{Input:} & vectMult accepts a Vector and a double as inputs. \\
	& \textbf{Exceptions:} & None.\\
	& \textbf{Transition:} & None. \\
	& \textbf{Output:} & vectMult returns the scalar multiple of the input Vector with the input double.  \newfunc
	
	\textbf{vectNeg:} & \textbf{Input:} & vectNeg accepts a Vector as input. \\
	& \textbf{Exceptions:} & None.\\
	& \textbf{Transition:} & None. \\
	& \textbf{Output:} & vectNeg returns the negative of the input Vector.  \newfunc
	
	\textbf{vectDot:} & \textbf{Input:} & vectDot accepts two Vectors as inputs. \\
	& \textbf{Exceptions:} & None.\\
	& \textbf{Transition:} & None. \\
	& \textbf{Output:} & vectDot returns the dot product of the input Vectors.  \newfunc
	
	\textbf{vectCross:} & \textbf{Input:} & vectCross accepts two Vectors as inputs. \\
	& \textbf{Exceptions:} & None.\\
	& \textbf{Transition:} & None. \\
	& \textbf{Output:} & vectCross calculates the cross product of the input Vectors and returns the \textit{z}-component of the product as a double.  \newfunc
	
	\textbf{vectPerp:} & \textbf{Input:} & vectPerp accepts a Vector as input. \\
	& \textbf{Exceptions:} & None.\\
	& \textbf{Transition:} & None.  \\
	& \textbf{Output:} & vectPerp rotates the input Vector by 90 degrees clockwise and returns the resultant Vector as output.  \newfunc
	
	\textbf{vectRPerp:} & \textbf{Input:} & vectRPerp accepts a Vector as input. \\
	& \textbf{Exceptions:} & None.\\
	& \textbf{Transition:} & None. \\
	& \textbf{Output:} & vectRPerp rotates the input Vector by 90 degrees anticlockwise and returns the resultant Vector as output.  \newfunc
	
	\textbf{vectProject:} & \textbf{Input:} & vectProject accepts two Vectors as inputs. \\
	& \textbf{Exceptions:} & None.\\
	& \textbf{Transition:} & None. \\
	& \textbf{Output:} & vectProject projects the first input Vector onto the second and returns the resultant Vector as output.  \newfunc
	
	\textbf{vectForAngle:} & \textbf{Input:} & vectForAngle accepts a double as input. \\
	& \textbf{Exceptions:} & None.\\
	& \textbf{Transition:} & None. \\
	& \textbf{Output:} & vectForAngle computes the Vector corresponding to the input angle (double), measured from the \textit{x}-axis, and returns the result.  \newfunc
	
	\textbf{vectToAngle:} & \textbf{Input:} & vectToAngle accepts a Vector as input. \\
	& \textbf{Exceptions:} & None.\\
	& \textbf{Transition:} & None. \\
	& \textbf{Output:} & vectToAngle calculates the angle between the input Vector and the \textit{x}-axis and returns the result as a double.  \newfunc
	
	\textbf{vectRotate:} & \textbf{Input:} & vectRotate accepts two Vectors as inputs. \\
	& \textbf{Exceptions:} & None.\\
	& \textbf{Transition:} & None. \\
	& \textbf{Output:} & vectRotate rotates the first input Vector by the second using complex multiplication returns the resultant Vector as output.  \newfunc
	
	\textbf{vectUnrotate:} & \textbf{Input:} & vectUnrotate accepts two Vectors as inputs. \\
	& \textbf{Exceptions:} & None.\\
	& \textbf{Transition:} & None. \\
	& \textbf{Output:} & vectUnrotate is the inverse operation of vectRotate; it returns the original Vector before it was rotated by another Vector using vectRotate.  \newfunc
	
	\textbf{vectLength:} & \textbf{Input:} & Each vectLength function accepts a Vector as input. \\
	& \textbf{Exceptions:} & None.\\
	& \textbf{Transition:} & None. \\
	& \textbf{Output:} & vectLength and vectLengthSq calculates the regular and squared length of the input Vector, respectively, and returns the result as a double.  \newfunc
	
	\textbf{vectNormalize:} & \textbf{Input:} & vectNormalize accepts a Vector as input. \\
	& \textbf{Exceptions:} & None.\\
	& \textbf{Transition:} & None. \\
	& \textbf{Output:} & vectNormalize converts the input Vector into a unit vector and returns the normalized Vector as output.  \newfunc
	
	\textbf{vectClamp:} & \textbf{Input:} & vectClamp accepts a Vector and a double as inputs. \\
	& \textbf{Exceptions:} & None.\\
	& \textbf{Transition:} & None. \\
	& \textbf{Output:} & vectClamp restricts the input Vector to a length specified by the input double. If the length of the input Vector is less than the input length, vectClamp returns the input Vector. Otherwise, it shrinks the Vector to the specified length and returns the resultant Vector.  \newfunc
	
	\textbf{vectLerp:} & \textbf{Input:} & vectLerp accepts two Vectors and a double as inputs. \\
	& \textbf{Exceptions:} & None.\\
	& \textbf{Transition:} & None. \\
	& \textbf{Output:} & vectLerp linearly interpolates between the two input Vectors for a percentage specified by the input double, and returns the new interpolated Vector as output.   \newfunc
	
	\textbf{vectDist:} & \textbf{Input:} & Each vectDist function accepts two Vectors as input. \\
	& \textbf{Exceptions:} & None.\\
	& \textbf{Transition:} & None.  \\
	& \textbf{Output:} & vectDist and vectDistSq calculates the regular and squared distance, respectively, between the two input Vectors and returns the result as a double.  \newfunc
	
	\textbf{vectNear:} & \textbf{Input:} & vectNear accepts two Vectors and a double as input. \\
	& \textbf{Exceptions:} & None.\\
	& \textbf{Transition:} & None. \\
	& \textbf{Output:} & vectNear returns true if the distance between the input Vectors is less than the distance specified by the input double, and false otherwise.  \newfunc
\end{longtable*}

%%%%%%%%%%%%%%%%%%%% BOUNDING BOX MODULE %%%%%%%%%%%%%%%%%%%%%%%

\section{MIS of the Bounding Box Module} \label{MISBB}

\subsection{Module Name: BB}

\subsection{Uses} \label{SecUBB}
	\Control, \Vector

\subsection{Interface Syntax}

\subsubsection{Exported Constants} \label{SecECBB}
	BB_ERR: BB \\
	BB_ERR := \{INT_MAX, INT_MAX, INT_MIN, INT_MIN\}

%\subsubsection{Exported Variables}

\subsubsection{Exported Data Types} \label{SecEDTBB}
	BB: struct

\subsubsection{Exported Access Programs} \label{SecEAPBB}
	\renewcommand*{\arraystretch}{1.2}
	\begin{longtable}{| y | x{3.5cm} | y | x{3.5cm} |}
	\hline \textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions} \\ \hline 
	 BBNew & double, double, double, double & BB & - \\ \hline
	 BBNewForExtents & Vector, double, double & BB & NegativeHalf Dimensions \\ \hline
	 BBNewForCircle & Vector, double & BB & NegativeRadius \\ \hline
	 BBIntersects & BB, BB & Boolean & - \\ \hline
	 BBContainsBB & BB, BB & Boolean & - \\ \hline
	 BBContainsVect & BB, Vector & Boolean & - \\ \hline
	 BBMerge & BB, BB & BB & - \\ \hline
	 BBCenter & BB & Vector & - \\ \hline
	 BBArea & BB & double & - \\ \hline
	 BBMergedArea & BB, BB & double & - \\ \hline
	 BBClampVect & BB, Vector & Vector & - \\ \hline
	 BBWrapVect & BB, Vector & Vector & - \\ \hline
	 BBOffset & BB, Vector & BB & - \\ \hline
\end{longtable}

\subsection{Interface Semantics}

\subsubsection{State Variables} \label{SecSVBB}
\textbf{BB:} 
\begin{multicols}{2}
	\noindent left: \R \\
	bottom: \R \\
	right: \R \\
	top: \R
\end{multicols}

%\subsubsection{State Invariant} 

%\subsubsection{Assumptions}s

\subsubsection{Access Program Semantics} \label{SecAPSBB}

\renewcommand*{\arraystretch}{\funcPadding}
	\begin{longtable*}{@{} p{3.1cm} l p{\colDescrip}} 
	\textbf{BBNew:} & \textbf{Input:} & BBNew accepts four doubles as input. \\
	& \textbf{Exceptions:} & None.\\
	& \textbf{Transition:} & BBNew allocates a new BB and initializes its left, bottom, right and top values with the input doubles, in that order. \\
	& \textbf{Output:} & BBNew returns the allocated BB as output.  \newfunc
	
	\textbf{BBNewFor Extents:} & \textbf{Input:} & BBNewForExtents accepts a Vector and two doubles as inputs. \\
	& \textbf{Exceptions:} & BBNewForExtents may raise a warning if the input doubles are negative.  \\
	& \textbf{Transition:} & BBNewForExtents creates a new BB centered on the input Vector. Its dimensions are calculated from the input doubles, which provide the half-width and half-height. \\
	& \textbf{Output:} & BBNewForExtents returns the new BB as output.  \newfunc
	
	\textbf{BBNewFor Circle:} & \textbf{Input:} & BBNewForCircle accepts a Vector and a double as input. \\
	& \textbf{Exceptions:} & BBNewForCircle may raise a warning if the input double is negative. \\
	& \textbf{Transition:} & BBNewForCircle creates a new BB centered on the input Vector. Its radius is specified by the input double. \\
	& \textbf{Output:} & BBNewForCircle returns the new BB as output.  \newfunc
	
	\textbf{BBIntersects:} & \textbf{Input:} & BBIntersects accepts two BBs as inputs. \\
	& \textbf{Exceptions:} & None.\\
	& \textbf{Transition:} & None. \\
	& \textbf{Output:} & BBIntersects returns true if the input BBs intersect on another, and false otherwise. \newfunc
	
	\textbf{BBContainsBB:} & \textbf{Input:} & BBContainsBB accepts two BBs as inputs. \\
	& \textbf{Exceptions:} & None.\\
	& \textbf{Transition:} & None. \\
	& \textbf{Output:} & BBContainsBB returns true if the first input BB contains the second, and false otherwise.  \newfunc
	
	\textbf{BBContains Vect:} & \textbf{Input:} & BBContainsVect accepts a BB and a Vector as inputs. \\
	& \textbf{Exceptions:} & None.\\
	& \textbf{Transition:} & None. \\
	& \textbf{Output:} & BBContainsVect returns true if the input Vector is within the bounds of the input BB, and false otherwise.  \newfunc
	
	\textbf{BBMerge:} & \textbf{Input:} & BBMerge accepts two BBs as inputs. \\
	& \textbf{Exceptions:} & None.\\
	& \textbf{Transition:} & BBMerge creates a new BB containing the two input BBs. \\
	& \textbf{Output:} & BBMerge returns the new BB as output.  \newfunc
	
	\textbf{BBCenter:} & \textbf{Input:} & BBCenter accepts a BB as input. \\
	& \textbf{Exceptions:} & None.\\
	& \textbf{Transition:} & None. \\
	& \textbf{Output:} & BBCenter returns the centroid of the input BB as a Vector.  \newfunc
	
	\textbf{BBArea:} & \textbf{Input:} & BBArea accepts a BB as input. \\
	& \textbf{Exceptions:} & None.\\
	& \textbf{Transition:} & None. \\
	& \textbf{Output:} & BBArea returns the area of the input BB as a double.  \newfunc
	
	\textbf{BBMergedArea:} & \textbf{Input:} & BBMergedArea accepts two BBs as inputs. \\
	& \textbf{Exceptions:} & None.\\
	& \textbf{Transition:} & None. \\
	& \textbf{Output:} & BBMergedArea returns the area of the region containing both input BBs as a double.  \newfunc 
	
	\textbf{BBClampVect:} & \textbf{Input:} & BBClampVect accepts a BB and a Vector as inputs. \\
	& \textbf{Exceptions:} & None.\\
	& \textbf{Transition:} & None. \\
	& \textbf{Output:} & BBClampVect restricts the input Vector to the dimensions of the input BB and returns the clamped Vector as output.  \newfunc
	
	\textbf{BBWrapVect:} & \textbf{Input:} & BBWrapVect accepts a BB and a Vector as inputs. \\
	& \textbf{Exceptions:} & None.\\
	& \textbf{Transition:} & None. \\
	& \textbf{Output:} & BBWrapVect wraps the input Vector to the input BB and returns the wrapped Vector as output.  \newfunc
	
	\textbf{BBOffset:} & \textbf{Input:} & BBOffset accepts a BB and a Vector as inputs. \\
	& \textbf{Exceptions:} & None.\\
	& \textbf{Transition:} & None. \\
	& \textbf{Output:} & BBOffset translates the input BB by the specified Vector and returns the shifted BB as output.  \newfunc
\end{longtable*}

%\subsubsection{Local Functions}

%\begin{longtable*}{@{} p{2.6cm} l p{\colDescrip}}
%	\textbf{:} & \textbf{Input:} & \\
%	& \textbf{Exceptions:} & \\
%	& \textbf{Transition:} & \\
%	& \textbf{Output:} &  \newfunc
%\end{longtable*}

%%%%%%%%%%%%%%%%%%%% TRANSFORM MATRIX MODULE %%%%%%%%%%%%%%%%%%%%%%%

\section{MIS of the Transform Matrix Module} \label{MISTransform}

\subsection{Module Name: Transform}

\subsection{Uses} \label{SecUTransform}
	\Vector, \BB

\subsection{Interface Syntax}

\subsubsection{Exported Constants} \label{SecECTransform}
	identity: Transform \\
	identity := \{1.0, 0.0, 0.0, 1.0, 0.0, 0.0\}

%\subsubsection{Exported Variables}

\subsubsection{Exported Data Types} \label{SecEDTTransform}
	Transform: struct \\ % for pagebreak

\subsubsection{Exported Access Programs} \label{SecEAPTransform}
	\renewcommand*{\arraystretch}{1.2}
	\begin{longtable}{| y | x{3.5cm} | y | x{3.5cm} |}
	\hline \textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions} \\ 
	\hline 
	transformNew & double, double, double, double, double, double & Transform & - \\ \hline
	transformNewTranspose & double, double, double, double, double, double & Transform & - \\ \hline
	transformInverse & Transform & Transform & - \\ \hline
	transformMult & Transform, Transform & Transform & - \\ \hline
	transformPoint & Transform, Vector & Vector & - \\ \hline
	transformVect & Transform, Vector & Vector & - \\ \hline
	transformBB & Transform, BB & BB & - \\ \hline
	transformTranslate & Vector & Transform & - \\ \hline
	transformScale & double, double & Transform & - \\ \hline
	transformRotate & double & Transform & - \\ \hline
	transformRigid & Vector, double & Transform & - \\ \hline
	transformRigidInverse & Transform & Transform & - \\ \hline
	%% Undocumented
	\iffalse
	transformWrap & Transform, Transform & Transform & - \\ \hline
	transformWrapInverse & Transform, Transform & Transform & - \\ \hline
	transformOrtho & BB & Transform & - \\ \hline
	transformBoneScale & Vector, Vector & Transform & - \\ \hline
	transformAxialScale & Vector, Vector, double & Transform & - \\ \hline
	\fi
\end{longtable}

\pagebreak %stylebreak

\subsection{Interface Semantics}

\subsubsection{State Variables} \label{SecSVTransform}
\textbf{Transform:} 
\begin{multicols}{2}
	\noindent a: \R \\
	c: \R \\
	tx: \R \\
	b: \R \\
	d: \R \\
	ty: \R
\end{multicols}

%\subsubsection{State Invariant} 

%\subsubsection{Assumptions}

\subsubsection{Access Program Semantics} \label{SecAPSTransform}

\renewcommand*{\arraystretch}{\funcPadding}
	\begin{longtable*}{@{} p{3.3cm} l p{\colDescrip}} 
	\textbf{transformNew:} & \textbf{Input:} & Each transformNew function accepts six doubles as inputs. \\
	& \textbf{Exceptions:} & None.\\
	& \textbf{Transition:} & None. \\
	& \textbf{Output:} & transformNew and transformNewTranspose creates and returns a new Transform matrix from the input doubles in regular and transposed order, respectively.  \newfunc
	
	\textbf{transformInverse:} & \textbf{Input:} & transformInverse accepts a Transform matrix as input. \\
	& \textbf{Exceptions:} & None.\\
	& \textbf{Transition:} & None. \\
	& \textbf{Output:} & transformInverse calculates the inverse of the input Transform matrix and returns the result as output.  \newfunc
	
	\textbf{transformMult:} & \textbf{Input:} & transformMult accepts two Transform matrices as inputs. \\
	& \textbf{Exceptions:} & None.\\
	& \textbf{Transition:} & None. \\
	& \textbf{Output:} & transformMult multiplies the two input Transform matrices together and returns the result as output.  \newfunc
	
	\textbf{transformPoint:} & \textbf{Input:} & transformPoint accepts a Transform matrix and a Vector as inputs. \\
	& \textbf{Exceptions:} & None.\\
	& \textbf{Transition:} & None. \\
	& \textbf{Output:} & transformPoint applies the affine transformation from the input Transform matrix to the input Vector and returns the resultant Vector.  \newfunc
	
	\textbf{transformVect:} & \textbf{Input:} & transformVect accepts a Transform matrix and a Vector as inputs. \\
	& \textbf{Exceptions:} & None.\\
	& \textbf{Transition:} & None. \\
	& \textbf{Output:} & transformVect applies the linear transformation from the input Transform matrix to the input Vector and returns the resultant Vector.  \newfunc
	
	\textbf{transformBB:} & \textbf{Input:} & transformBB accepts a Transform matrix and a BB as inputs.\\
	& \textbf{Exceptions:} & None.\\
	& \textbf{Transition:} & transformBB calculates the half-dimensions of the input BB, applies the input Transform matrix to calculate the transformed dimensions, computes the new transformed half-dimensions, and creates a new BB from the new half-dimensions. The center of this new BB is obtained by applying the input Transform matrix to the centroid of the old BB.  \\
	& \textbf{Output:} & transformBB returns the new, transformed BB as output.  \newfunc
	
	\textbf{transform Translate:} & \textbf{Input:} & transformTranslate accepts a Vector as input. \\
	& \textbf{Exceptions:} & None.\\
	& \textbf{Transition:} & transformTranslate creates a translation matrix from the input Vector. \\
	& \textbf{Output:} & transformTranslate returns the new Transform matrix as output.  \newfunc
	
	\textbf{transformScale:} & \textbf{Input:} & transformScale accepts two doubles as inputs. \\
	& \textbf{Exceptions:} & None.\\
	& \textbf{Transition:} & transformScale creates a scaling matrix from the input doubles, which represent the horizontal and vertical scale factors, respectively. \\
	& \textbf{Output:} & transformScale returns the new Transform matrix as output.  \newfunc
	
	\textbf{transformRotate:} & \textbf{Input:} & transformRotate accepts a double as input. \\
	& \textbf{Exceptions:} & None.\\
	& \textbf{Transition:} & transformRotate calculates a Vector from the angle specified by the input double and creates a rotation matrix from the Vector. \\
	& \textbf{Output:} & transformRotate returns the new Transform matrix as output.  \newfunc
	
	\textbf{transformRigid:} & \textbf{Input:} & transformRigid accepts a Vector and a double as inputs. \\
	& \textbf{Exceptions:} & None.\\
	& \textbf{Transition:} & transformRigid calculates a Vector from the angle specified by the input double and creates a rigid transformation matrix from the input parameters, using the computed Vector for the rotation components and the input Vector for the translation components. \\
	& \textbf{Output:} & transformRigid returns the new Transform matrix as output.  \newfunc
	
	\textbf{transformRigid Inverse:} & \textbf{Input:} & transformRigidInverse accepts a Transform matrix as input. \\
	& \textbf{Exceptions:} & None.\\
	& \textbf{Transition:} & None. \\
	& \textbf{Output:} & transformRigidInverse returns the inverse of a rigid Transform matrix.  \newfunc
	
	\iffalse
	\textbf{transformWrap:} & \textbf{Input:} & transformWrap accepts two Transform matrices as inputs. \\
	& \textbf{Exceptions:} & None.\\
	& \textbf{Transition:} & None. \\
	& \textbf{Output:} &  \newfunc
	
	\textbf{transformWrapInverse:} & \textbf{Input:} & transformWrap accepts two Transform matrices as inputs. \\
	& \textbf{Exceptions:} & None.\\
	& \textbf{Transition:} & None. \\
	& \textbf{Output:} &  \newfunc
	
	\textbf{transformOrtho:} & \textbf{Input:} & transformOrtho accepts a BB as input. \\
	& \textbf{Exceptions:} & None.\\
	& \textbf{Transition:} & None. \\
	& \textbf{Output:} &  \newfunc
	
	\textbf{transformBoneScale:} & \textbf{Input:} & transformBoneScale accepts two Vectors as inputs. \\
	& \textbf{Exceptions:} & None.\\
	& \textbf{Transition:} & None. \\
	& \textbf{Output:} &  \newfunc
	
	\textbf{transformAxialScale:} & \textbf{Input:} & transformAxialScale accepts two Vectors and a double as inputs. \\
	& \textbf{Exceptions:} & None.\\
	& \textbf{Transition:} & None. \\
	& \textbf{Output:} &  \newfunc
	\fi
\end{longtable*}

%\subsubsection{Local Functions}

%\begin{longtable*}{@{} p{2.6cm} l p{\colDescrip}}
%	\textbf{:} & \textbf{Input:} & \\
%	& \textbf{Exceptions:} & \\
%	& \textbf{Transition:} & \\
%	& \textbf{Output:} &  \newfunc
%\end{longtable*}

%%%%%%%%%%%%%%%%%%%%  SPATIAL INDEX MODULE %%%%%%%%%%%%%%%%%%%%%%%

\section{MIS of the Spatial Index Module} \label{MISSpatial}

\subsection{Module Name: SpatialIndex} 

\subsection{Uses} \label{SecUSpatial}
	\Control, \Vector, \BB, \Linked

\subsection{Interface Syntax}

%\subsubsection{Exported Constants}

%\subsubsection{Exported Variables}

\subsubsection{Exported Data Types} \label{SecEDTSpatial}
	SpatialIndex: struct \\
	SpatialIndexClass: struct \\
	DynamicToStaticContext: struct \\
	SpatialIndexBBFunc : void* $\to$ BB \\
	SpatialIndexIteratorFunc : void* $\times$ void* $\to$ void \\
	SpatialIndexQueryFunc : void* $\times$ void* $\times$ CollisionID $\times$ void* $\to$ CollisionID \\
	SpatialIndexDestroyImpl : SpatialIndex* $\to$ void \\
	SpatialIndexCountImpl : SpatialIndex* $\to \mathbb{Z}$ \\
	SpatialIndexEachImpl : SpatialIndex* $\times$ SpatialIndexIteratorFunc $\times$ void* $\to$ void \\
	SpatialIndexContainsImpl : SpatialIndex* $\times$ void* $\times$ HashValue $\to \mathbb{B}$ \\
	SpatialIndexInsertImpl : SpatialIndex* $\times$ void* $\times$ HashValue $\to$ void \\
	SpatialIndexRemoveImpl : SpatialIndex* $\times$ void* $\times$ HashValue $\to$ void \\
	SpatialIndexReindexImpl : SpatialIndex* $\to$ void \\
	SpatialIndexReindexObjectImpl : SpatialIndex* $\times$ void* $\times$ HashValue $\to$ void \\
	SpatialIndexReindexQueryImpl : SpatialIndex* $\times$ SpatialIndexQueryFunc $\times$ void* $\to$ void \\
	SpatialIndexQueryImpl : SpatialIndex* $\times$ void* $\times$ BB $\times$ SpatialIndexQueryFunc $\times$ void* $\to$ void

\subsubsection{Exported Access Programs} \label{SecEAPSpatial}
	\renewcommand*{\arraystretch}{1.2}
	\begin{longtable}{| y | x{3.5cm} | y | x{3.5cm} |}
	\hline \textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions} \\ \hline 
	spatialIndexInit & SpatialIndex*, SpatialIndexClass*, SpatialIndexBBFunc, SpatialIndex* & SpatialIndex* & AttachedStaticIndex \\ \hline
	spatialIndexFree & SpatialIndex* & - & - \\ \hline
	spatialIndexCollideStatic & SpatialIndex*, SpatialIndex*, SpatialIndexQueryFunc, void* & - & - \\ \hline
	spatialIndexDestroy & SpatialIndex* & - & - \\ \hline
	spatialIndexCount & SpatialIndex* & int & - \\ \hline
	spatialIndexEach & SpatialIndex*, SpatialIndexIteratorFunc, void* & - & - \\ \hline
	spatialIndexContains & SpatialIndex*, void*, HashValue & Boolean & - \\ \hline
	spatialIndexInsert & SpatialIndex*, void*, HashValue & - & - \\ \hline
	spatialIndexRemove & SpatialIndex*, void*, HashValue & - & - \\ \hline
	spatialIndexReindex & SpatialIndex* & - & - \\ \hline
	spatialIndexReindexObject & SpatialIndex*, void*, HashValue & - & - \\ \hline
	spatialIndexQuery & SpatialIndex*, void*, BB, SpatialIndexQueryFunc, void* & - & - \\ \hline
	spatialIndexReindexQuery & SpatialIndex*, SpatialIndexQueryFunc, void* & - & - \\ \hline
\end{longtable}

\subsection{Interface Semantics}

\subsubsection{State Variables} \label{SecSVSpatial}
\textbf{SpatialIndex:} 
\begin{multicols}{2}
	\noindent klass: SpatialIndexClass* \\
	bbfunc: SpatialIndexBBFunc \\
	staticIndex: SpatialIndex* \\
	dynamicIndex: SpatialIndex*
\end{multicols}

\noindent \textbf{SpatialIndexClass:} 
\begin{multicols}{2}
	\noindent destroy: SpatialIndexDestroyImpl \\
	count: SpatialIndexCountImpl \\
	each: SpatialIndexEachImpl \\
	contains: SpatialIndexContainsImpl \\
	insert: SpatialIndexInsertImpl \\
	remove: SpatialIndexRemoveImpl \\
	reindex: SpatialIndexReindexImpl \\
	reindexObject: SpatialIndexReindexObjectImpl \\
	reindexQuery: SpatialIndexReindexQueryImpl \\
	query: SpatialIndexQueryImpl
\end{multicols}

\pagebreak %stylebreak

\noindent \textbf{DynamicToStaticContext:} 
\begin{multicols}{2}
	\noindent bbfunc: SpatialIndexBBFunc \\
	staticIndex: SpatialIndex* \\
	queryFunc: SpatialIndexQueryFunc \\
	data: void*
\end{multicols}

%\subsubsection{State Invariant} 

\subsubsection{Assumptions} \label{SecASpatial}
	spatialIndexInit is called before any other access program. All input pointers are also assumed to be non-null.

\subsubsection{Access Program Semantics} \label{SecAPSSpatial}

\renewcommand*{\arraystretch}{\funcPadding}
	\begin{longtable*}{@{} p{3.2cm} l p{\colDescrip}} 
	\textbf{spatialIndex Init:} & \textbf{Input:} & spatialIndexInit accepts a SpatialIndex pointer, a SpatialIndexClass pointer, a SpatialIndexBBFunc function pointer, and another SpatialIndex pointer as inputs. \\
	& \textbf{Exceptions:} & spatialIndexInit may throw an AttachedStaticIndex exception if the last input SpatialIndex pointer for the staticIndex is already associated to another dynamicIndex. \\
	& \textbf{Transition:} & spatialIndexInit initializes the first input SpatialIndex with the input parameters and zero-initializes other fields. \\
	& \textbf{Output:} & spatialIndexInit returns a pointer to the initialized SpatialIndex as output.  \newfunc
	
	\textbf{spatialIndex Free:} & \textbf{Input:} & spatialIndexFree accepts a SpatialIndex pointer as input. \\
	& \textbf{Exceptions:} & None.\\
	& \textbf{Transition:} & spatialIndexFree frees the input SpatialIndex. \\
	& \textbf{Output:} & None.  \newfunc
	
	\textbf{spatialIndex CollideStatic:} & \textbf{Input:} & spatialIndexCollideStatic accepts two SpatialIndex pointers, a SpatialIndexQueryFunc function pointer, and a void pointer as inputs. \\
	& \textbf{Exceptions:} & None.\\
	& \textbf{Transition:} & If the input static index (second SpatialIndex) is valid and non-empty, the function creates a new DynamicToStaticContext using the input parameters, sets its bbfunc to the bbfunc of the input dynamic index (first SpatialIndex). \\ \\ %stylebreak
	& & Afterwards, it iterates through the dynamic index using \hyperref[SecLFSpatial]{dynamicToStaticIter} and the new context. \\ 
	& \textbf{Output:} & None.  \newfunc
	
	\textbf{spatialIndex Destroy:} & \textbf{Input:} & spatialIndexDestroy accepts a SpatialIndex pointer as input. \\
	& \textbf{Exceptions:} & None.\\
	& \textbf{Transition:} & spatialIndexDestroy calls the internal destroying function from the input SpatialIndex's class with the index itself. \\
	& \textbf{Output:} & None.  \newfunc \\ % for pagebreak
	
	\textbf{spatialIndex Count:} & \textbf{Input:} & spatialIndexCount accepts a SpatialIndex pointer as input. \\
	& \textbf{Exceptions:} & None.\\
	& \textbf{Transition:} & spatialIndexCount calls the internal counting function from the input SpatialIndex's class with the index itself. \\
	& \textbf{Output:} & spatialIndexCount returns the integer result of the counting function as output. \newfunc
	
	\textbf{spatialIndex Each:} & \textbf{Input:} & spatialIndexEach accepts a SpatialIndex pointer, a SpatialIndexIteratorFunc function pointer and a void pointer as inputs. \\
	& \textbf{Exceptions:} & None.\\
	& \textbf{Transition:} & spatialIndexEach calls the internal iterator function from the SpatialIndex's class with the input parameters. \\
	& \textbf{Output:} & None.  \newfunc
	
	\textbf{spatialIndex Contains:} & \textbf{Input:} & spatialIndexContains accepts a SpatialIndex pointer, a void pointer and a HashValue as inputs.\\
	& \textbf{Exceptions:} & None.\\
	& \textbf{Transition:} & spatialIndexContains calls the internal existence-checking function from the input SpatialIndex's class with the input parameters. \\
	& \textbf{Output:} & spatialIndexContains returns true if the input index contains the object in the input void pointer, and false otherwise.  \newfunc
	
	\textbf{spatialIndex Insert:} & \textbf{Input:} & spatialIndexInsert accepts a SpatialIndex pointer, a void pointer and a HashValue as inputs. \\
	& \textbf{Exceptions:} & None.\\
	& \textbf{Transition:} & spatialIndexInsert calls the internal insertion function from the input SpatialIndex's class with the input parameters. \\
	& \textbf{Output:} & None.  \newfunc
	
	\textbf{spatialIndex Remove:} & \textbf{Input:} & spatialIndexRemove accepts a SpatialIndex pointer, a void pointer and a HashValue as inputs. \\
	& \textbf{Exceptions:} & None.\\
	& \textbf{Transition:} & spatialIndexRemove calls the internal removal function from the input SpatialIndex's class with the input parameters. \\
	& \textbf{Output:} & None.  \newfunc
	
	\textbf{spatialIndex Reindex:} & \textbf{Input:} & spatialIndexReindex accepts a SpatialIndex pointer as input. \\
	& \textbf{Exceptions:} & None.\\
	& \textbf{Transition:} & spatialIndexReindex calls the internal reindexing function from the input SpatialIndex's class with the index itself.\\
	& \textbf{Output:} & None.  \newfunc
	
	\textbf{spatialIndex ReindexObject:} & \textbf{Input:} & spatialIndexReindexObject accepts a SpatialIndex pointer, a void pointer and a HashValue as inputs. \\
	& \textbf{Exceptions:} & None.\\
	& \textbf{Transition:} & spatialIndexReindexObject calls the internal object-reindexing function from the input SpatialIndex's class with the input parameters.\\
	& \textbf{Output:} & None.  \newfunc
	
	\textbf{spatialIndex Query:} & \textbf{Input:} & spatialIndexQuery accepts a SpatialIndex pointer, a void pointer, a BB and a SpatialIndexQueryFunc function pointer. \\
	& \textbf{Exceptions:} & None.\\
	& \textbf{Transition:} & spatialIndexQuery calls the internal querying function from the input SpatialIndex's class with the input parameters. \\
	& \textbf{Output:} & None.  \newfunc
	
	\textbf{spatialIndex ReindexQuery:} & \textbf{Input:} & spatialIndexReindexQuery accepts a SpatialIndex pointer, a SpatialIndexQueryFunc function pointer and a void pointer as inputs.\\
	& \textbf{Exceptions:} & None.\\
	& \textbf{Transition:} & spatialIndexReindexQuery calls the internal query-based reindexing function from the input SpatialIndex's class with the input parameters.\\
	& \textbf{Output:} & None.  \newfunc
\end{longtable*}

\subsubsection{Local Functions} \label{SecLFSpatial}

\renewcommand*{\arraystretch}{\funcPadding}
	\begin{longtable*}{@{} p{2.6cm} l p{\colDescrip}}
	\textbf{dynamicTo StaticIter:} & \textbf{Input:} & dynamicToStaticIter accepts a void pointer and a DynamicToStaticContext pointer as inputs. \\
	& \textbf{Exceptions:} & None.\\
	& \textbf{Transition:} & dynamicToStaticIter queries the index by calling \hyperref[SecAPSSpatial]{spatialIndexQuery} with the input void pointer and the fields of the input DynamicToStaticContext. \\
	& \textbf{Output:} & None.  \newfunc
\end{longtable*}

%%%%%%%%%%%%%%%%%%%%  COLLISION SOLVER MODULE %%%%%%%%%%%%%%%%%%%%%%%

\section{MIS of the Collision Solver Module} \label{MISCollision}

\subsection{Module Name: Collision}

\subsection{Uses} \label{SecUCollision}
	\Body, \Shape, \Arbiter, \Control, \Vector, \BB

\subsection{Interface Syntax}

\subsubsection{Exported Constants} \label{SecECCollision}
	POINTS_ERR: ClosestPoints \\
	POINTS_ERR := \{VECT_ERR, VECT_ERR, DBL_MIN, UINT32_MAX\} \\
	\newline
	MAX_GJK_ITERATIONS, MAX_EPA_ITERATIONS, WARN_GJK_ITERATIONS, WARN_EPA_ITERATIONS: \Z \\
	MAX_GJK_ITERATIONS := 30 \\
	MAX_EPA_ITERATIONS := 30 \\
	WARN_GJK_ITERATIONS := 20 \\
	WARN_EPA_ITERATIONS := 20

%\subsubsection{Exported Variables}

\subsubsection{Exported Data Types} \label{SecEDTCollision}
	SupportPoint: struct \\
	MinkowskiPoint: struct \\
	SupportContext: struct \\
	EdgePoint: struct \\
	Edge: struct \\
	ClosestPoints: struct \\
	CollisionFunc : Shape* $\times$ Shape* $\times$ CollisionInfo* $\to$ void \\
	SupportPointFunc : Shape* $\times$ Vector $\to$ SupportPoint

\subsubsection{Exported Access Programs} \label{SecEAPCollision}
	\renewcommand*{\arraystretch}{1.2}
	\begin{longtable}{| y | x{3.5cm} | y | x{3.5cm} |}
	\hline \textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions} \\ \hline 
	relative_velocity & Body*, Body*, Vector, Vector & Vector & - \\ \hline
	normal_relative_velocity & Body*, Body*, Vector, Vector, Vector & double & - \\ \hline
	apply_impulse & Body*, Vector, Vector & - & - \\ \hline
	apply_impulses & Body*, Body*, Vector, Vector, Vector & - & - \\ \hline
	apply_bias_impulse & Body*, Vector, Vector & - & - \\ \hline
	apply_bias_impulses & Body*, Body*, Vector, Vector, Vector & - & - \\ \hline
	k_scalar_body & Body*, Vector, Vector & double & - \\ \hline
	k_scalar & Body*, Body*, Vector, Vector, Vector & double & UnsolvableCollision \\ \hline
	collide & Shape*, Shape*, CollisionID, Contact* & CollisionInfo & - \\ \hline
	shapesCollide & Shape*, Shape* & ContactPointSet & - \\ \hline
\end{longtable}

\subsection{Interface Semantics}

\subsubsection{State Variables} \label{SecSVCollision}
\textbf{SupportPoint:} 
\begin{multicols}{2}
	\noindent p: Vector \\
	index: CollisionID
\end{multicols}
	
\noindent \textbf{MinkowskiPoint:} 
\begin{multicols}{2}
	\noindent a: Vector \\
	b: Vector \\
	ab: Vector \\
	id: CollisionID
\end{multicols}

\noindent \textbf{SupportContext:} 
\begin{multicols}{2}
	\noindent shape1: Shape* \\
	shape2: Shape* \\
	func1: SupportPointFunc \\
	func2: SupportPointFunc
\end{multicols}

\noindent \textbf{EdgePoint:} 
\begin{multicols}{2}
	\noindent p: Vector \\
	hash: HashValue
\end{multicols}

\noindent \textbf{Edge:} 
\begin{multicols}{2}
	\noindent a: EdgePoint \\
	b: EdgePoint \\
	radius: \R \\
	normal: Vector
\end{multicols}

\pagebreak % stylebreak

\noindent \textbf{ClosestPoints:} 
\begin{multicols}{3}
	\noindent a: Vector \\
	b: Vector \\
	n: Vector \\
	d: \R \\
	id: CollisionID
\end{multicols}

%\subsubsection{State Invariant} 

%\subsubsection{Assumptions}

\subsubsection{Access Program Semantics} \label{SecAPSCollision}

\renewcommand*{\arraystretch}{\funcPadding}
	\begin{longtable*}{@{} p{3.3cm} l p{\colDescrip}} 
	\textbf{relative_velocity:} & \textbf{Input:} & relative_velocity accepts two Body pointers and two Vectors as inputs. \\
	& \textbf{Exceptions:} & None.\\
	& \textbf{Transition:} & None. \\
	& \textbf{Output:} &  relative_velocity calculates the relative velocity of the second input Body relative to the first input Body with the input parameters and returns the result as a Vector. \newfunc
	
	\textbf{normal_relative_velocity:} & \textbf{Input:} & normal_relative_velocity accepts two Body pointers and three Vectors as inputs. \\
	& \textbf{Exceptions:} & None.\\
	& \textbf{Transition:} & None. \\
	& \textbf{Output:} &  normal_relative_velocity calculates the dot product of the relative velocity between the two input Bodies and the normal (third input Vector) and returns the result as a double. \newfunc
	
	\textbf{apply_impulse:} & \textbf{Input:} & apply_impulse accepts a Body pointer and two Vectors as inputs. \\
	& \textbf{Exceptions:} & None.\\
	& \textbf{Transition:} & apply_impulse recalculates the input Body's linear and angular velocity using the impulse (first input Vector) and point of application (second input Vector). \\
	& \textbf{Output:} & None. \newfunc
	
	\textbf{apply_impulses:} & \textbf{Input:} & apply_impulses accepts two Body pointers and three Vectors as inputs. \\
	& \textbf{Exceptions:} & None.\\
	& \textbf{Transition:} & apply_impulses applies the input impulse (third input Vector) to the two input Bodies, in opposite directions, to recalculate their linear and angular velocities, using their points of application (first and second input Vectors). \\
	& \textbf{Output:} & None. \newfunc
	
	\textbf{apply_bias_impulse:} & \textbf{Input:} & apply_bias_impulse accepts a Body pointer and two Vectors as inputs. \\
	& \textbf{Exceptions:} & None.\\
	& \textbf{Transition:} & apply_bias_impulse recalculates the input Body's linear and angular bias velocities using the impulse (first input Vector) and point of application (second input Vector). \\
	& \textbf{Output:} & None. \newfunc \\ % for pagebreak
	
	\textbf{apply_bias_impulses:} & \textbf{Input:} & apply_bias_impulses accepts two Body pointers and three Vectors as inputs. \\
	& \textbf{Exceptions:} & None.\\
	& \textbf{Transition:} & apply_bias_impulses applies the input impulse (third input Vector) to the two input Bodies, in opposite directions, to recalculate their linear and angular bias velocities, using their points of application (first and second input Vectors). \\
	& \textbf{Output:} & None. \newfunc
	
	\textbf{k_scalar_body:} & \textbf{Input:} & k_scalar_body accepts a Body pointer and two Vectors as inputs. \\
	& \textbf{Exceptions:} & None.\\
	& \textbf{Transition:} & None. \\
	& \textbf{Output:} & k_scalar_body first calculates the cross product of the two input Vectors. Then, it computes the product of the inverse momentum of the input Body and the squared cross product of the input Vectors. Finally, it calculates the sum of this quantity and the Body's inverse mass, and returns the final result as a double. \newfunc 
	
	\textbf{k_scalar:} & \textbf{Input:} & k_scalar accepts two Body pointers and three Vectors as inputs. \\
	& \textbf{Exceptions:} & k_scalar may throw an UnsolvableCollision exception if the calculated value is equal to zero. \\
	& \textbf{Transition:} & None. \\
	& \textbf{Output:} &  k_scalar calculates \hyperref[SecAPSCollision]{k_scalar_body} for the first input Body with the first and last input Vector, and for the second input Body with the second and last input Vector. It then calculates the sum of these results and returns the above sum as a double. \newfunc
	
	\textbf{collide:} & \textbf{Input:} & collide accepts two Shape pointers, a CollisionID and a Contact pointer as inputs. \\
	& \textbf{Exceptions:} & None.\\
	& \textbf{Transition:} & collide creates a new CollisionInfo structure with the input parameters and other fields zero-initialized. The function will then reorder the structure's Shape types as necessary, and apply the appropriate collision function from \hyperref[SecLCCollision]{CollisionFuncs} to it.\\
	& \textbf{Output:} & collide returns the new CollisionInfo structure as output. \newfunc
	
	\textbf{shapesCollide:} & \textbf{Input:} & shapesCollide accepts two Shape pointers as inputs. \\
	& \textbf{Exceptions:} & None.\\
	& \textbf{Transition:} & shapesCollide declares a new Contact array and generates a CollisionInfo structure for the input Shapes using the collide function and the Contact array, modifying the array in the process. Next, it declares a new ContactPointSet structure for the collision and sets the number of points and normal accordingly. Finally, the function will iterate through the Contact array to set the points for the ContactPointSet. \\
	& \textbf{Output:} & shapesCollide returns the new ContactPointSet as output. \newfunc
\end{longtable*}

\subsubsection{Local Constants} \label{SecLCCollision}
	BuiltinCollisionFuncs: array(CollisionFunc) \\
	BuiltinCollisionFuncs := \{CircleToCircle, CollisionError, CollisionError, CircleToSegment, SegmentToSegment, CollisionError, CircleToPoly, SegmentToPoly, PolyToPoly\} \\
	CollisionFuncs := BuiltinCollisionFuncs

\subsubsection{Local Functions} \label{SecLFCollision}

\renewcommand*{\arraystretch}{\funcPadding}
	\begin{longtable*}{@{} p{3.3cm} l p{\colDescrip}}
	\iffalse
	% Checks the area and signed area between the points. The original Chipmunk did
	% not mathematically specify the significance of these functions, so I'm actually
	% not 100% sure on that. They are used in EPA and GJK, seemingly to determine the
	% relative distance and positions of points from each other.
	
	\textbf{checkArea:} & \textbf{Input:} & checkArea accepts two Vectors as inputs. \\
	& \textbf{Exceptions:} & None.\\
	& \textbf{Transition:} & None. \\
	& \textbf{Output:} &  checkArea calculates the product of the first Vector's $x$-component with the second's $y$-component, and the product of the first Vector's $y$-component with the second's $x$-component. It returns true if the first result is greater than the second, and false otherwise. Called by \hyperref[SecLFCollision]{GJKRecurse}. \newfunc
	
	\textbf{checkSignedArea:} & \textbf{Input:} & checkSignedArea accepts three Vectors as inputs. \\
	& \textbf{Exceptions:} & None.\\
	& \textbf{Transition:} & None. \\
	& \textbf{Output:} & checkSignedArea calculates the signed area of a triangle using the three input Vectors as its vertices. It returns true if the signed area is positive, and false otherwise. Called by \hyperref[SecLFCollision]{EPARecurse}. \newfunc
	
	\fi
	
	\textbf{collisionInfo PushContact:} & \textbf{Input:} & collisionInfoPushContact accepts a CollisionInfo pointer, two Vectors and a HashValue as inputs. \\
	& \textbf{Exceptions:} & collisionInfoPushContact may throw a CollisionContactOverflow exception when the number of Contacts of the input CollisionInfo exceeds \hyperref[SecECArbiter]{MAX_CONTACTS_PER_ARBITER}. \\
	& \textbf{Transition:} & collisionInfoPushContact pushes a new Contact structure into the input CollisionInfo's Contacts array with the other input parameters and updates its number of Contacts accordingly. Called by the \hyperref[SecLFCollision]{ShapeToShape} collision functions to add new contact points and by \hyperref[SecLFCollision]{closestPoints} in the collision functions for SegmentShapes and PolyShapes. \\
	& \textbf{Output:} & None. \newfunc
	
	\iffalse
	% Used to find the vertex index for a PolyShape's support point.
	\textbf{polySupport PointIndex:} & \textbf{Input:} & polySupportPointIndex accepts an integer, a pointer to a SplittingPlane array and a Vector as inputs. \\
	& \textbf{Exceptions:} & None.\\
	& \textbf{Transition:} & polySupportPointIndex iterates through the input array. For each point in the array, the function calculates the dot product of the point's Vector with the input Vector, and computes the index of the point that maximizes this quantity. Used by \hyperref[SecLFCollision]{polySupportPoint and supportEdgeForPoly}. \\
	& \textbf{Output:} & polySupportPointIndex returns the index as an integer. \newfunc
	
	% Straightforward constructor for SupportPoints.
	\textbf{supportPoint New:} & \textbf{Input:} & supportPointNew accepts a Vector and a CollisionID as inputs. \\
	& \textbf{Exceptions:} & None.\\
	& \textbf{Transition:} & None. \\
	& \textbf{Output:} &  supportPointNew allocates a new SupportPoint structure with the input parameters and returns it as output. \newfunc 
	\fi
	
	\textbf{SupportPoint:} & \textbf{Input:} & Each SupportPoint function accepts a Shape pointer of the Shape type corresponding to the function's prefix and a Vector as inputs. \\
	& \textbf{Exceptions:} & None.\\
	& \textbf{Transition:} & None. \\
	& \textbf{Output:} &  Each SupportPoint creates a new SupportPoint with the input Shape's transformed center (CircleShapes), endpoint (SegmentShape) or vertex (PolyShape), with the appropriate index of the point as its CollisionID. Each corresponding function is used by the appropriate \hyperref[SecLFCollision]{ShapeToShape} function in generating the SupportPointContext to be passed to \hyperref[SecLFCollision]{GJK}. \newfunc
	
	\iffalse
	% Merged into a general shapeSupportPoint function.
	\textbf{circleSupport Point:} & \textbf{Input:} & circleSupportPoint accepts a CircleShape pointer and a Vector as inputs. \\
	& \textbf{Exceptions:} & None.\\
	& \textbf{Transition:} & None. \\
	& \textbf{Output:} &  circleSupportPoint creates a new SupportPoint with the input CircleShape's transformed center and zero as the ID, and returns it as output.\newfunc
	
	\textbf{segmentSupport Point:} & \textbf{Input:} & segmentSupportPoint accepts a SegmentShape pointer and a Vector as inputs. \\
	& \textbf{Exceptions:} & None.\\
	& \textbf{Transition:} & None. \\
	& \textbf{Output:} & segmentSupportPoint calculates the dot product of the input SegmentShape's endpoints with the input Vector. It creates a new SupportPoint with the endpoint that maximizes the product and either zero or one as the ID, depending on the endpoint used, and returns it as output. \newfunc
	
	\textbf{polySupport Point:} & \textbf{Input:} & polySupportPoint accepts a PolyShape pointer and a Vector as input. \\
	& \textbf{Exceptions:} & None.\\
	& \textbf{Transition:} & None. \\
	& \textbf{Output:} & polySupportPoint finds the index of the input PolyShape's support point with polySupportPointIndex and creates a new SupportPoint, using the vertex corresponding to the index and the index itself as the ID, and returns the new SupportPoint as output. \newfunc
	
	% Creates a new MinkowskiPoint containing the Minkowski difference of two SupportPoints.
	\textbf{minkowskiPoint New:} & \textbf{Input:} & minkowskiPointNew accepts two SupportPoints as input.\\
	& \textbf{Exceptions:} & None.\\
	& \textbf{Transition:} & None. \\
	& \textbf{Output:} & minkowskiPointNew allocates a new MinkowskiPoint structure using the input SupportPoints, their difference, and the concatenated index of both SupportPoints (calculated through bitwise operations). The new MinkowskiPoint is then returned as output. \newfunc
	\fi
	
	\textbf{support:} & \textbf{Input:} & support accepts a SupportContext pointer and a Vector as inputs. \\
	& \textbf{Exceptions:} & None.\\
	& \textbf{Transition:} & support calculates the maximal point on the Minkowski difference of two shapes along a particular axis. It generates two SupportPoints using the SupportPointFunc functions and Shapes contained in the input SupportContext and the input Vector, and creates a new MinkowskiPoint with these SupportPoints. Used in the calculations of \hyperref[SecLFCollision]{GJK and EPA}. \\
	& \textbf{Output:} &  support returns the new MinkowskiPoint as output. \newfunc
	
	\textbf{supportEdgeFor:} & \textbf{Input:} & Each supportEdgeFor function accepts a Shape pointer of the corresponding Shape type and a Vector as inputs. \\
	& \textbf{Exceptions:} & None.\\
	& \textbf{Transition:} & Each supportEdgeFor function computes the dot products of the input Shape's vertices (for PolyShapes) or normal (for SegmentShapes) with the input Vector to calculate a support edge for the input Shape, which is an edge of a SegmentShape or PolyShape that is in contact with another Shape. Called by some \hyperref[SecLFCollision]{ShapeToShape} functions to determine contact points for SegmentShapes and PolyShapes.  \\
	& \textbf{Output:} & Each supportEdgeFor function generates a new Edge structure containing information about the calculated support edge and returns it as output. \newfunc
	
	\iffalse
	
	% Merged into supportEdgeFor with a more general description.
	\textbf{supportEdgeFor Poly:} & \textbf{Input:} & supportEdgeForPoly accepts a PolyShape pointer and a Vector as inputs. \\
	& \textbf{Exceptions:} & None.\\
	& \textbf{Transition:} & supportEdgeForPoly finds the vertices adjacent to the input PolyShape's support point and calculates the dot product of the vertices and the input Vector. The function then creates a new Edge with the support point and the vertex that maximized the product. \\
	& \textbf{Output:} & supportEdgeForPoly returns the new Edge as output. \newfunc
	
	\textbf{supportEdgeFor Segment:} & \textbf{Input:} & supportEdgeForSegment accepts a SegmentShape pointer and a Vector as inputs. \\
	& \textbf{Exceptions:} & None.\\
	& \textbf{Transition:} & supportEdgeForSegment calculates the dot product of the input SegmentShape's transformed normal and the input Vector. If the result is positive, the function creates a new Edge using the SegmentShape's endpoints and other properties. Otherwise, it creates a new Edge using the endpoints in reversed order and a negative transformed normal. \\
	& \textbf{Output:} &  supportEdgeForSegment returns the new Edge as output. \newfunc 
	\fi
	
	\textbf{closestT:} & \textbf{Input:} & closestT accepts two Vectors as inputs. \\
	& \textbf{Exceptions:} & None.\\
	& \textbf{Transition:} & closestT finds the closest $\mathbf{p}(t)$ to the origin $(0, 0)$, where $\mathbf{p}(t) = \frac{a(1-t)+b(1+t)}{2}$, $a$ and $b$ are the two input Vectors and $t \in [-1, 1]$. The function clamps the result to this interval. Used for the computation of closest points in \hyperref[SecLFCollision]{closestPointsNew}. \\
	& \textbf{Output:} &  closestT returns a double as output. \newfunc
	
	\textbf{lerpT:} & \textbf{Input:} & lerpT accepts two Vectors and a double as inputs. \\
	& \textbf{Exceptions:} & None.\\
	& \textbf{Transition:} & lerpT functions similarly to \hyperref[SecAPSVector]{vectLerp}, except the parameter $t$, the last input double, is constrained to the interval $[-1, 1]$. Used for the computation of closest points in \hyperref[SecLFCollision]{closestPointsNew}. \\
	& \textbf{Output:} & lerpT returns a Vector as output. \newfunc
	
	\textbf{closestPoints New:} & \textbf{Input:} & closestPointsNew accepts two MinkowskiPoint structures as inputs. \\
	& \textbf{Exceptions:} & None.\\
	& \textbf{Transition:} & closestPointsNew finds the closest edge to the origin (0, 0) on the Minkowski difference of two Shapes, which is obtained by using \hyperref[SecLFCollision]{closestT and lerpT} with the input MinkowskiPoints. This is used to calculate the closest points on the surface of two Shapes, as well as the distance and the minimum separating axis between them. The function then generates a new ClosestPoints structure using the calculated data and the concatenated IDs of the input MinkowskiPoints. Used to compute closest points in \hyperref[SecLFCollision]{EPA and GJK}. \\
	& \textbf{Output:} &  closestPointsNew returns the new ClosestPoints as output.\newfunc
	
	\iffalse
	% Finds the closest distance between two points for EPA.
	\textbf{closestDist:} & \textbf{Input:} & closestDist accepts two Vectors as inputs. \\
	& \textbf{Exceptions:} & None.\\
	& \textbf{Transition:} & closestDist calls closestT with the input Vectors, and uses the result to linearly interpolate the two Vectors with lerpT. The function then calculates the squared length of the resultant Vector. \\
	& \textbf{Output:} & closestDist returns the result as a double. \newfunc
	
	% Decided to merge EPA and EPARecurse.
	\textbf{EPARecurse:} & \textbf{Input:} & EPARecurse accepts a SupportContext pointer, an integer, a pointer to a MinkowskiPoint array and another integer as inputs. \\
	& \textbf{Exceptions:} & EPARecurse may throw a SameVertices exception when the EPA vertices are the same. It may also raise HighIterWarning when the iteration number (last input integer) is greater than or equal to the \hyperref[SecECCollision]{WARN_EPA_ITERATIONS} threshold. \\
	& \textbf{Transition:} & EPARecurse is a recursive implementation of the EPA (Expanding Polytope Algorithm), where each recursion adds a point to the convex hull until the function obtains the closest point on the surface. 
	%\green{TODO: Elaborate more on the algorithm.} 
	\\
	& \textbf{Output:} & EPARecurse returns the new ClosestPoints structure as output. \newfunc
	\fi
	
	\textbf{EPA:} & \textbf{Input:} & EPA accepts a SupportContext pointer, and three MinkowskiPoint structures as inputs. \\
	& \textbf{Exceptions:} & EPA may throw a SameVertices exception when the EPA vertices are the same. It may also raise HighIterWarning when the number of iterations reaches the \hyperref[SecECCollision]{WARN_EPA_ITERATIONS} threshold. \\
	& \textbf{Transition:} & EPA recursively finds the closest points on the surface of two overlapping Shapes using the EPA (Expanding Polytope Algorithm). The function initializes a convex hull array of vertices and each recursion adds a point to the hull until the function obtains the closest points on the surfaces of the Shapes. \\
	& \textbf{Output:} & EPA generates a new ClosestPoints structure containing information about the computed closest points and returns it as output. \newfunc
	
	\iffalse
	% Decided to merge GJK and GJKRecurse together.
	\textbf{GJKRecurse:} & \textbf{Input:} & GJKRecurse accepts a SupportContext pointer, two MinkowskiPoint structures and an integer as inputs.\\
	& \textbf{Exceptions:} & GJKRecurse may raise a HighIterWarning when the iteration number (last input integer) is greater than or equal to the \hyperref[SecECCollision]{WARN_GJK_ITERATIONS} threshold, or \hyperref[SecECCollision]{WARN_EPA_ITERATIONS} when EPARecurse needs to be called. \\
	& \textbf{Transition:} & GJKRecurse is a recursive implementation of the GJK (Gilbert-Johnson-Keerthi) algorithm. If the collision Shapes are found to overlap, the function will execute EPA to find the closest points.
	%\green{TODO: Elaborate more on the algorithm?}. 
	\\
	& \textbf{Output:} & GJKRecurse returns the new ClosestPoints structure as output. \newfunc
	
	% Convenience constructor that calls the appropriate support point-generating function for the input Shape.
	\textbf{shapePoint:} & \textbf{Input:} & shapePoint accepts a Shape pointer and an integer as inputs. \\
	& \textbf{Exceptions:} & None.\\
	& \textbf{Transition:} & shapePoint creates a new SupportPoint depending on the type of the input Shape and index (the input integer). \\
	& \textbf{Output:} & shapePoint returns the new SupportPoint as output. \newfunc
	\fi
	
	\textbf{GJK:} & \textbf{Input:} & GJK accepts a SupportContext pointer and a CollisionID pointer as inputs. \\
	& \textbf{Exceptions:} & GJK may raise a HighIterWarning when the number of iterations reaches the \hyperref[SecECCollision]{WARN_GJK_ITERATIONS} threshold, or \hyperref[SecECCollision]{WARN_EPA_ITERATIONS} when \hyperref[SecLCCollision]{EPA} needs to be called. \\
	& \textbf{Transition:} & GJK recursively finds the closest points between two shapes using the (Gilbert-Johnson-Keerthi) algorithm. If the collision Shapes are found to overlap at some iteration of the algorithm, the function will then execute \hyperref[SecLCCollision]{EPA} to find the closest points. \\
	& \textbf{Output:} & GJK generates a new ClosestPoints structure containing information about the computed closest points and returns it as output. \newfunc
	
	\textbf{contactPoints:} & \textbf{Input:} & contactPoints accepts two Edge structures, a ClosestPoints structure and a CollisionInfo pointer as inputs. \\
	& \textbf{Exceptions:} & None.\\
	& \textbf{Transition:} & contactPoints finds contact point pairs on the surfaces of the input support Edges and pushes a new Contact structure into the input CollisionInfo's Contacts array. This is used in \hyperref[SecLFCollision]{ShapeToShape} functions involving SegmentShapes and PolyShapes (except for CircleToPoly). \\
	& \textbf{Output:} & None. \newfunc
	
	\textbf{ShapeToShape:} & \textbf{Input:} & Each ShapeToShape function 
	accept two pointers to the corresponding Shape types and a CollisionInfo pointer as inputs. \\
	& \textbf{Exceptions:} & None.\\
	& \textbf{Transition:} & Each ShapeToShape function calls \hyperref[SecLFCollision]{GJK} to find the ClosestPoints for the two input Shapes and uses it to check if the current distance between the two Shapes is less than the minimum collision distance (usually determined by the sum of the Shapes' radii). If so, the function pushes a new Contact structure containing information about the Shapes' contact points into the Contacts array of the input CollisionInfo. These functions are stored in the exported \hyperref[SecLCCollision]{CollisionFuncs} array, and the appropriate function will be called by \hyperref[SecAPSCollision]{collide}. \\
	& \textbf{Output:} & None. \newfunc
	
	\iffalse
	% These are the specific shape-to-shape collision functions. They are originally
	% documented in the MIS, but I've decided to abstract them into a general
	% 'ShapeToShape' function instead.
	
	\textbf{CircleToCircle:} & \textbf{Input:} & CircleToCircle accepts two CircleShape pointers and a CollisionInfo pointer as inputs. \\
	& \textbf{Exceptions:} & None.\\
	& \textbf{Transition:} & CircleToCircle checks if the current distance between the input CircleShapes is less than the minimum collision distance, which is the sum of the Shapes' radii. If so, the function pushes a new Contact structure to the Contacts array of the input CollisionInfo. \\
	& \textbf{Output:} & None. \newfunc
	
	\textbf{CircleToSegment:} & ~~\textbf{Input:} & CircleToSegment accepts a CircleShape pointer, a SegmentShape pointer and a CollisionInfo pointer as inputs. \\
	& ~~\textbf{Exceptions:} & None.\\
	& ~~\textbf{Transition:} & CircleToSegment finds the closest point on the input SegmentShape to the input Circle and checks if the current distance between the point and the CircleShape's center is less than the minimum collision distance, which is the sum of the Shapes' radii. If so, the function pushes a new Contact structure to the Contacts array of the input CollisionInfo. Coincident (completely overlapping) Shapes are taken into account and end-cap collisions are rejected if tangents are provided.
	\\
	& ~~\textbf{Output:} & None. \newfunc
	
	\textbf{SegmentTo Segment:} & \textbf{Input:} & SegmentToSegment accepts two SegmentShape pointers and a CollisionInfo pointer as inputs. \\
	& \textbf{Exceptions:} & None.\\
	& \textbf{Transition:} & SegmentToSegment creates a new SupportContext structure with the input SegmentShapes and the segmentSupportPoint function. It then generates a ClosestPoints structure with GJK, using pointers to the context structure and the ID of the input CollisionInfo. Afterwards, it will check if the closest points are nearer than the minimum collision distance, which is the sum of the Shapes' radii, and if so, push a new Contact structure to the Contacts array of the input CollisionInfo. End-cap collisions are rejected if tangents are provided. \\
	& \textbf{Output:} & None. \newfunc 
	
	\textbf{PolyToPoly:} & \textbf{Input:} & PolyToPoly accepts two PolyShape pointers and a CollisionInfo pointer as inputs. \\
	& \textbf{Exceptions:} & None.\\
	& \textbf{Transition:} & PolyToPoly creates a new SupportContext structure with the input PolyShapes and the polySupportPoint function. It then generates a ClosestPoints structure with GJK, using pointers to the context structure and the ID of the input CollisionInfo. Afterwards, it will check if the closest points are nearer than the minimum collision distance, which is the sum of the Shapes' radii, and if so, push a new Contact structure to the Contacts array of the input CollisionInfo. \\
	& \textbf{Output:} & None. \newfunc
	
	\textbf{SegmentTo Poly:} & \textbf{Input:} & SegmentToPoly accepts a SegmentShape pointer, a PolyShape pointer and a CollisionInfo pointer as inputs. \\
	& \textbf{Exceptions:} & None.\\
	& \textbf{Transition:} & SegmentToPoly creates a new SupportContext structure with the input Shapes and their corresponding SupportPointFuncs. It then generates a ClosestPoints structure with GJK, using pointers to the context structure and the ID of the input CollisionInfo. Afterwards, it will check if the closest points are nearer than the minimum collision distance, which is the sum of the Shapes' radii, and if so, push a new Contact structure to the Contacts array of the input CollisionInfo. End-cap collisions are rejected if tangents are provided. \\\\
	& \textbf{Output:} & None. \newfunc
	
	\textbf{CircleToPoly:} & \textbf{Input:} & CircleToPoly accepts a CircleShape pointer, a PolyShape pointer and a CollisionInfo pointer as inputs. \\
	& \textbf{Exceptions:} & None.\\
	& \textbf{Transition:} & CircleToPoly creates a new SupportContext structure with the input Shapes and their corresponding SupportPointFuncs. It then generates a ClosestPoints structure with GJK, using pointers to the context structure and the ID of the input CollisionInfo. Afterwards, it will check if the closest points are nearer than the minimum collision distance, which is the sum of the Shapes' radii, and if so, push a new Contact structure to the Contacts array of the input CollisionInfo. \\
	& \textbf{Output:} & None. \newfunc 
	\fi
	
	\textbf{CollisionError:} & \textbf{Input:} & CollisionError accepts two Shape pointers and a CollisionInfo pointer as inputs. \\
	& \textbf{Exceptions:} & CollisionError throws an eponymous exception when the types of the input Shapes are not in sorted order. \\
	& \textbf{Transition:} & CollisionError throws an exception and aborts the program. This function is stored in the exported \hyperref[SecLCCollision]{CollisionFuncs} array and called by \hyperref[SecAPSCollision]{collide} when the colliding Shape types are not in order. \\
	& \textbf{Output:} & None. \newfunc
\end{longtable*}

%%%%%%%%%%%%%%%%%%%% SEQUENCE DATA STRUCTURE MODULE %%%%%%%%%%%%%%%%%%%%%%%

\section{MIS of the Sequence Data Structure Module} \label{MISSequence}

\subsection{Module Name: Array}

\subsection{Uses} \label{SecUSequence}
	This module only uses standard libraries.

\subsection{Interface Syntax}

%\subsubsection{Exported Constants}

%\subsubsection{Exported Variables}

\subsubsection{Exported Data Types} \label{SecEDTSequence}
	Array: struct

\subsubsection{Exported Access Programs} \label{SecEAPSequence}
	\renewcommand*{\arraystretch}{1.2}
	\begin{longtable}{| y | x{3.5cm} | y | x{3.5cm} |}
	\hline \textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions} \\ \hline 
	arrayNew & int & Array* & - \\ \hline
	arrayFree & Array* & - & - \\ \hline
	arrayPush & Array*, void* & - & - \\ \hline
	arrayPop & Array* & void* & EmptyArray \\ \hline
	arrayDeleteObj & Array*, void* & - & - \\ \hline
	arrayContains & Array*, void* & Boolean & - \\ \hline
	arrayFreeEach & Array*, void* $\to$ void & - & - \\ \hline
\end{longtable}

\subsection{Interface Semantics}

\subsubsection{State Variables} \label{SecSVSequence}
\textbf{Array:} 
\begin{multicols}{3}
	\noindent num: \Z \\
	max: \Z \\
	arr: void**
\end{multicols}

\subsubsection{State Invariant} \label{SecSISequence}
	$\text{Array.num} \le \text{Array.max}$

\subsubsection{Assumptions} \label{SecASequence}
	arrayNew is called before any other access program, and all input pointers are assumed to be non-null.

\subsubsection{Access Program Semantics} \label{SecAPSSequence}

\renewcommand*{\arraystretch}{\funcPadding}
	\begin{longtable*}{@{} p{3.3cm} l p{\colDescrip}} 
	\textbf{arrayNew:} & \textbf{Input:} & arrayNew accepts an integer as input. \\
	& \textbf{Exceptions:} & None.\\
	& \textbf{Transition:} & arrayNew heap-allocates a new Array object. It sets the Array's length and maximum length to the input integer (unless the input is zero, in which case the default maximum is 4), and heap-allocates a maximum-length void pointer array for the internal array. \\
	& \textbf{Output:} & arrayNew returns the newly-created Array as output.  \newfunc
	
	\textbf{arrayFree:} & \textbf{Input:} & arrayFree accepts an Array pointer as input. \\
	& \textbf{Exceptions:} & None.\\
	& \textbf{Transition:} & arrayFree frees the internal array of the input Array, and then frees the Array itself. \\
	& \textbf{Output:} & None.  \newfunc
	
	\textbf{arrayPush:} & \textbf{Input:} & arrayPush accepts an Array pointer and a void pointer as inputs. \\
	& \textbf{Exceptions:} & None.\\
	& \textbf{Transition:} & arrayPush inserts the specified element into the input Array and increments the number of elements accordingly. If the Array is at capacity, the function will double the maximum length and resize the internal array accordingly. \\
	& \textbf{Output:} & None.  \newfunc
	
	\textbf{arrayPop:} & \textbf{Input:} & arrayPop accepts an Array pointer as input.\\
	& \textbf{Exceptions:} & arrayPop may throw an EmptyArray exception if the user attempts to pop items from an empty Array. \\
	& \textbf{Transition:} & arrayPop will remove the last element of the input Array and decrements the number of elements accordingly. \\
	& \textbf{Output:} & arrayPop returns the retrieved void pointer as output.  \newfunc
	
	\textbf{arrayDeleteObj:} & \textbf{Input:} & arrayDeleteObj accepts an Array pointer and a void pointer as inputs. \\
	& \textbf{Exceptions:} & None.\\
	& \textbf{Transition:} & arrayDeleteObj deletes the specified element (void pointer) from the input Array and decrements the number of elements accordingly.  \\
	& \textbf{Output:} & None.  \newfunc
	
	\textbf{arrayContains:} & \textbf{Input:} & arrayContains accepts an Array pointer and a void pointer as inputs. \\
	& \textbf{Exceptions:} & None.\\
	& \textbf{Transition:} & None. \\
	& \textbf{Output:} & arrayContains iterates through the input Array and returns true if the Array contains the input void pointer, and false otherwise.  \newfunc
	
	\textbf{arrayFreeEach:} & \textbf{Input:} & arrayFreeEach accepts an Array pointer and a pointer to a freeing function that accepts a void pointer and returns nothing (void* $\to$ void). \\
	& \textbf{Exceptions:} & None.\\
	& \textbf{Transition:} & arrayFreeEach iterates through the internal array of the input Array and applies the input function to each element. \\
	& \textbf{Output:} & None.  \newfunc
\end{longtable*}

%\subsubsection{Local Functions}

%\begin{longtable*}{@{} p{2.6cm} l p{\colDescrip}}
%	\textbf{:} & \textbf{Input:} & \\
%	& \textbf{Exceptions:} & \\
%	& \textbf{Transition:} & \\
%	& \textbf{Output:} &  \newfunc
%\end{longtable*}

%%%%%%%%%%%%%%%%%%%% LINKED DATA STRUCTURE MODULE %%%%%%%%%%%%%%%%%%%%%%%

\section{MIS of the Linked Data Structure Module} \label{MISLinked}

\subsection{Module Name: BBTree}

\subsection{Uses} \label{SecULinked}
	\Control, \Vector, \BB, \SpatialIndex, \Sequence, \Assoc

\subsection{Interface Syntax}

\subsubsection{Exported Constants} \label{SecECLinked}
	NODE_ERR: Node \\
	NODE_ERR := \{NULL, BB_ERR, NULL\} \\
	\newline
	PAIR_ERR: Pair \\
	PAIR_ERR = \{\{NULL, NULL, NULL\}, \{NULL, NULL, NULL\}, UINT32_MAX\}
	
%\subsubsection{Exported Variables}

\subsubsection{Exported Data Types} \label{SecEDTLinked}
	BBTree: struct \\
	Node: struct \\
	Thread: struct \\
	Pair: struct \\
	MarkContext: struct \\
	EachContext: struct \\
	BBTreeVelocityFunc : void* $\to$ Vector 

\subsubsection{Exported Access Programs} \label{SecEAPLinked}
	\renewcommand*{\arraystretch}{1.2}
	\begin{longtable}{| y | x{3.7cm} | y | x{3.7cm} |}
	\hline \textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions} \\ \hline 
	BBTreeAlloc & - & BBTree* & - \\ \hline
	BBTreeInit & BBTree*, SpatialIndexBBFunc, SpatialIndex* & SpatialIndex* & - \\ \hline
	BBTreeSetVelocityFunc & SpatialIndex*, BBTreeVelocityFunc & - & NotBBTreeWarn \\ \hline
	BBTreeNew & SpatialIndexBBFunc, SpatialIndex* & SpatialIndex* & - \\ \hline
	BBTreeDestroy & BBTree* & - & - \\ \hline
	BBTreeCount & BBTree* & int & - \\ \hline
	BBTreeEach & BBTree*, SpatialIndexIteratorFunc, void* & - & - \\ \hline
	BBTreeInsert & BBTree*, void*, HashValue & - & - \\ \hline
	BBTreeRemove & BBTree*, void*, HashValue & - & - \\ \hline
	BBTreeContains & BBTree*, void*, HashValue & - & - \\ \hline
	BBTreeReindexQuery & BBTree*, SpatialIndexQueryFunc, void* & - & - \\ \hline
	BBTreeReindex & BBTree* & - & - \\ \hline
	BBTreeReindexObject & BBTree*, void*, HashValue & - & - \\ \hline
\end{longtable}

\subsection{Interface Semantics}

\subsubsection{State Variables} \label{SecSVLinked}
\textbf{BBTree:} 
\begin{multicols}{3}
	\noindent spatialIndex: SpatialIndex \\
	velocityFunc: BBTreeVelocityFunc \\
	leaves: HashSet* \\
	root: Node* \\
	pooledNodes: Node* \\
	pooledPairs: Pair* \\
	allocatedBuffers: Array* \\
	stamp: Timestamp
\end{multicols}

\noindent \textbf{Node:} 
\begin{multicols}{2}
	\noindent obj: void* \\
	bb: BB \\
	parent: Node* \\
	node: union
\end{multicols}

\noindent \textbf{Node.node.children:} 
\begin{multicols}{2}
	\noindent a: Node* \\
	b: Node*
\end{multicols}

\noindent \textbf{Node.node.leaf:} 
\begin{multicols}{2}
	\noindent stamp: Timestamp \\
	pairs: Pair*
\end{multicols}

\noindent \textbf{Thread:} 
\begin{multicols}{3}
	\noindent prev: Pair* \\
	leaf: Node* \\
	next: Pair*
\end{multicols}

\pagebreak %stylebreak

\noindent \textbf{Pair:} 
\begin{multicols}{3}
	\noindent a: Thread \\
	b: Thread \\
	id: CollisionID
\end{multicols}

\noindent \textbf{MarkContext:} 
\begin{multicols}{2}
	\noindent tree: BBTree* \\
	staticRoot: Node* \\
	func: SpatialIndexQueryFunc \\
	data: void*
\end{multicols}

\noindent \textbf{EachContext:} 
\begin{multicols}{2}
	\noindent func: SpatialIndexIteratorFunc \\
	data: void*
\end{multicols}

%\subsubsection{State Invariant} 

\subsubsection{Assumptions} \label{SecALinked}
	BBTreeAlloc or BBTreeNew is called before any other access program, and all input pointers are assumed to be non-null.

\subsubsection{Access Program Semantics} \label{SecAPSLinked}

\renewcommand*{\arraystretch}{\funcPadding}
	\begin{longtable*}{@{} p{3.0cm} l p{\colDescrip}} 
	\textbf{BBTreeAlloc:} & \textbf{Input:} & None. \\
	& \textbf{Exceptions:} & None.\\
	& \textbf{Transition:} & BBTreeAlloc allocates a new BBTree from the heap. \\
	& \textbf{Output:} & BBTreeAlloc returns a pointer to the allocated BBTree.  \newfunc
	
	\textbf{BBTreeInit:} & \textbf{Input:} & BBTreeInit accepts a BBTree pointer, a SpatialIndexBBFunc function pointer and a SpatialIndex pointer as inputs. \\
	& \textbf{Exceptions:} & None.\\
	& \textbf{Transition:} & BBTreeInit initializes the input BBTree as a SpatialIndex, using the BBTree SpatialIndexClass \hyperref[SecLCLinked]{klass} and the input parameters. All internal data structures are created accordingly and other variables are zero-initialized. \\
	& \textbf{Output:} & BBTreeInit returns a general SpatialIndex pointer to the initialized BBTree.  \newfunc 
	
	\textbf{BBTreeSet VelocityFunc:} & \textbf{Input:} & BBTreeSetVelocityFunc accepts a SpatialIndex pointer and a BBTreeVelocityFunc function pointer as inputs. \\
	& \textbf{Exceptions:} & BBTreeSetVelocityFunc may raise a NotBBTree warning if the input SpatialIndex is not a BBTree.\\
	& \textbf{Transition:} & BBTreeSetVelocityFunc sets the input BBTree SpatialIndex's internal velocity function to the provided function. \\
	& \textbf{Output:} & None.  \newfunc
	
	\textbf{BBTreeNew:} & \textbf{Input:} & BBTreeNew accepts a SpatialIndexBBFunc function pointer and a SpatialIndex pointer as inputs. \\
	& \textbf{Exceptions:} & None.\\
	& \textbf{Transition:} & BBTreeNew allocates a new BBTree from the heap and initializes it. \\
	& \textbf{Output:} & BBTreeNew returns a pointer to the initialized BBTree.  \newfunc
	
	% The rest are actually private/static functions in C, because they are called from the BBTree class through the SpatialIndex interface. 
	
	\textbf{BBTreeDestroy:} & \textbf{Input:} & BBTreeDestroy accepts a BBTree pointer as input. \\ 
	& \textbf{Exceptions:} & None. \\
	& \textbf{Transition:} & BBTreeDestroy frees the dynamically-allocated structures of the input BBTree and all of its elements, namely its leaves and allocated buffers. \\ 
	& \textbf{Output:} & None.  \newfunc
	
	\textbf{BBTreeCount:} & \textbf{Input:} & BBTreeCount accepts a BBTree pointer as input. \\
	& \textbf{Exceptions:} & None.\\
	& \textbf{Transition:} & None. \\
	& \textbf{Output:} & BBTreeCount counts the number of leaves contained in the input Tree and returns the result as an integer.  \newfunc
	
	\textbf{BBTreeEach:} & \textbf{Input:} & BBTreeEach accepts a BBTree pointer, a SpatialIndexIteratorFunc function pointer, and a void pointer as inputs. \\
	& \textbf{Exceptions:} & None.\\
	& \textbf{Transition:} & BBTreeEach creates a new EachContext structure with the input function and data (void pointer), and iterates through the input BBTree's leaves using the hash set iterator and the context structure. \\
	& \textbf{Output:} & None. \newfunc
	
	\textbf{BBTreeInsert:} & \textbf{Input:} & BBTreeInsert accepts a BBTree pointer, a void pointer and a HashValue as inputs. \\
	& \textbf{Exceptions:} & None.\\
	& \textbf{Transition:} & BBTreeInsert inserts a new Node with the input object (void pointer) and HashValue into the input BBTree. The function will update the Node's timestamp to the master tree's timestamp, add appropriate Pairs for the Node and update the timestamp of the input tree. \\
	& \textbf{Output:} & None.  \newfunc
	
	\textbf{BBTreeRemove:} & ~\textbf{Input:} & BBTreeRemove accepts a BBTree pointer, a void pointer and a HashValue as inputs. \\
	& ~\textbf{Exceptions:} & None.\\
	& ~\textbf{Transition:} & BBTreeRemove deletes the Node corresponding to the input object (void pointer) and HashValue from the input BBTree, clears the Pairs for that Node and recycles the empty Node. \\ \nopagebreak %stylebreak
	& ~\textbf{Output:} & None.  \newfunc 
	
	\textbf{BBTreeContains:} & ~~\textbf{Input:} & BBTreeContains accepts a BBTree pointer, a void pointer and a HashValue as inputs. \\
	& ~~\textbf{Exceptions:} & None.\\
	& ~~\textbf{Transition:} & None. \\
	& ~~\textbf{Output:} & BBTreeContains searches the leaves of the input BBTree for the input object (void pointer) and HashValue. It returns true if a valid Node is found; otherwise, it returns false.  \newfunc
	
	\textbf{BBTreeReindex Query:} & ~\textbf{Input:} & BBTreeReindexQuery accepts a BBTree pointer, a SpatialIndexQueryFunc function pointer, and a void pointer as inputs. \\
	& ~\textbf{Exceptions:} & None.\\
	& ~\textbf{Transition:} & If the input BBTree does not have a valid root, the function returns immediately. Otherwise, it will update the tree's leaves, attempt to obtain the root of the tree's static index, create a new MarkContext structure with the root and the input parameters, and mark the tree with this context. \\
	& & If the static index does not have a valid root, the function calls \hyperref[SecAPSSpatial]{spatialIndexCollideStatic} with the index and the input parameters. Finally, the function updates the timestamp of the tree.  \\
	& ~\textbf{Output:} & None.  \newfunc
	
	\textbf{BBTreeReindex:} & ~~\textbf{Input:} & BBTreeReindex accepts a BBTree pointer as input. \\
	& ~~\textbf{Exceptions:} & None.\\
	& ~~\textbf{Transition:} & BBTreeReindex calls BBTreeReindexQuery with the input BBTree, voidQueryFunc and a null pointer. \\
	& ~~\textbf{Output:} & None.  \newfunc
	
	\textbf{BBTreeReindex Object:} & ~\textbf{Input:} & BBTreeReindexObject accepts a BBTree pointer, a void pointer and a HashValue as inputs. \\
	& ~\textbf{Exceptions:} & None.\\
	& ~\textbf{Transition:} & The function will attempt to find the Node corresponding to the input HashValue and object (void pointer). If found, it will attempt to update the Node, and following success, add Pairs for the Node. The tree's timestamp will be updated accordingly at the end of the function. \\
	& ~\textbf{Output:} & None.  \newfunc
\end{longtable*}

\subsubsection{Local Constants} \label{SecLCLinked}
	klass: SpatialIndexClass \\
	klass := \{BBTreeDestroy, BBTreeCount, BBTreeEach, BBTreeContains, BBTreeInsert, BBTreeRemove, BBTreeReindex, BBTreeReindexObject, BBTreeReindexQuery\}

\subsubsection{Local Functions} \label{SecLFLinked}

\renewcommand*{\arraystretch}{\funcPadding}
	\begin{longtable*}{@{} p{3.3cm} l p{\colDescrip}}
	\iffalse
	% Simple helper functions for trees. They can be included in the document if their operations are deemed important enough for the specification (at the moment, it does not seem to add crucial details to the specification)
	
	% Retrieves the BB corresponding to the input object.
	\textbf{getBB:} & \textbf{Input:} & getBB accepts a BBTree pointer and a void pointer as inputs. \\
	& \textbf{Exceptions:} & None.\\
	& \textbf{Transition:} & getBB retrieves the BB corresponding to the input object (void pointer) from the input BBTree. If the tree has a valid velocity function, the boundaries of the BB will be adjusted accordingly. \\
	& \textbf{Output:} & getBB returns the retrieved BB as output.  \newfunc
	
	% Casts the index as a tree if it's a tree.
	\textbf{getTree:} & \textbf{Input:} & getTree accepts a SpatialIndex pointer as input. \\
	& \textbf{Exceptions:} & None.\\
	& \textbf{Transition:} & None. \\
	& \textbf{Output:} & getTree checks if the input SpatialIndex is of the BBTree class. If so, the function returns the input pointer cast as a BBTree pointer. Otherwise, it returns a null pointer.  \newfunc
	
	% If the index is a tree, obtains the root.
	\textbf{getRootIfTree:} & \textbf{Input:} & getRootIfTree accepts a SpatialIndex pointer as input. \\
	& \textbf{Exceptions:} & None.\\
	& \textbf{Transition:} & None.  \\
	& \textbf{Output:} & getRootIfTree checks if the input SpatialIndex is of the BBTree class. If so, the function casts the input pointer to a BBTree pointer and returns a Node pointer to its root. Otherwise, it returns a null pointer.  \newfunc
	
	% Retrieves the master tree of the BBTree.
	\textbf{getMasterTree:} & \textbf{Input:} & getMasterTree accepts a BBTree pointer as input. \\
	& \textbf{Exceptions:} & None.\\
	& \textbf{Transition:} & None. \\
	& \textbf{Output:} & getMasterTree attempts to retrieve the BBTree's master tree, which is its index of dynamic bodies. If the function retrieves a valid tree, it returns the tree. Otherwise, it returns the input tree.  \newfunc
	
	% By default, updates the timestamp of the master tree. Otherwise (if there's no master tree), updates the timestamp of the input tree.
	\textbf{incrementStamp:} & \textbf{Input:} & incrementStamp accepts a BBTree pointer as input. \\
	& \textbf{Exceptions:} & None.\\
	& \textbf{Transition:} & incrementStamp attempts to retrieve a BBTree's master tree. If the retrieved tree is valid, the function increments the timestamp of this tree. Otherwise, it will increment the timestamp of the input tree. \\
	& \textbf{Output:} & None.  \newfunc
	\fi
	
	\textbf{Recycle:} & \textbf{Input:} & Each Recycle function accepts a BBTree pointer and a pointer to the corresponding object as inputs. \\
	& \textbf{Exceptions:} & None.\\
	& \textbf{Transition:} & pairRecycle retrieves the master tree (its index of dynamic bodies) of the input BBTree and recycles the input Pair to the tree's pooled Pairs, while nodeRecycle removes the input Node from the input BBTree and recycles it to the tree's pooled Nodes. Used in functions involving deletion (\hyperref[SecLFLinked]{pairsClear, subtreeRemove, nodeReplaceChild}, \hyperref[SecAPSLinked]{BBTreeRemove}) and recycling fresh objects from the buffer (\hyperref[SecLFLinked]{FromPool}). \\
	& \textbf{Output:} & None.  \newfunc 
	
	\textbf{FromPool:} & \textbf{Input:} & pairFromPool accepts a BBTree pointer as input. \\
	& \textbf{Exceptions:} & Each FromPool function may throw an InsufficientBufferSize exception if the size of the corresponding object exceeds the buffer size (\hyperref[SecECControl]{BUFFER_BYTES}). \\
	& \textbf{Transition:} & pairFromPool retrieves the master tree of the input BBTree, while nodeFromPool uses the input BBTree. Each function retrieves a new object the tree's pooled objects. If there is none, the function allocates a new object buffer, adds it to the tree's allocated buffers, and adds all the new objects to the pool except the first one, which is returned. Used in \hyperref[SecLFLinked]{pairInsert} and Node constructors \hyperref[SecLFLinked]{nodeNew, leafNew}. \\
	& \textbf{Output:} & pairFromPool returns a pointer to the retrieved Pair as output.  \newfunc
	
	\iffalse
	% Abstracting these functions for Pairs and Nodes.
	\textbf{pairRecycle:} & \textbf{Input:} & pairRecycle accepts a BBTree pointer and a Pair pointer as inputs. \\
	& \textbf{Exceptions:} & None.\\
	& \textbf{Transition:} & pairRecycle retrieves the master tree (its index of dynamic bodies) of the input BBTree and recycles the input Pair to the tree's pooled Pairs. Used in \hyperref[SecLFLinked]{pairsClear} and recycling fresh Pairs in \hyperref[SecLFLinked]{pairsFromPool}. \\
	& \textbf{Output:} & None.  \newfunc 
	
	\textbf{pairFromPool:} & \textbf{Input:} & pairFromPool accepts a BBTree pointer as input. \\
	& \textbf{Exceptions:} & pairFromPool may throw an InsufficientBufferSize exception if the size of a Pair object exceeds the buffer size (\hyperref[SecECControl]{BUFFER_BYTES}). \\
	& \textbf{Transition:} & pairFromPool retrieves the master tree of the input BBTree and retrieves a Pair from the input BBTree's pooled Pairs. If there is none, the function allocates a new Pair buffer, adds it to the tree's allocated buffers, and adds all the new Pairs to the pool except the first one, which is returned. Used in \hyperref[SecLFLinked]{pairInsert}. \\
	& \textbf{Output:} & pairFromPool returns a pointer to the retrieved Pair as output.  \newfunc
	\fi
	
	\iffalse
	% Unlinks a Thread from its linked list of Threads. 
	% Commented out since it does not add much to the process of 'unlinking Threads' in places where it is used, i.e. pairsClear
	\textbf{threadUnlink:} & \textbf{Input:} & threadUnlink accepts a Thread as input. \\
	& \textbf{Exceptions:} & None.\\
	& \textbf{Transition:} & threadUnlink removes the input Thread from the chain. \\
	& \textbf{Output:} & None.  \newfunc
	\fi
	
	\textbf{pairsClear:} & \textbf{Input:} & pairsClear accepts a Node pointer and a BBTree pointer as inputs. \\
	& \textbf{Exceptions:} & None.\\
	& \textbf{Transition:} & pairsClear removes all Pairs associated with the input Node, unlinks all Threads associated with each Pair and recycles the Pairs. Used in \hyperref[SecLFLinked]{leafUpdate} and \hyperref[SecAPSLinked]{BBTreeRemove}. \\
	& \textbf{Output:} & None.  \newfunc
	
	\textbf{pairInsert:} & \textbf{Input:} & pairInsert accepts two Node pointers and a BBTree pointer as inputs.\\
	& \textbf{Exceptions:} & None.\\
	& \textbf{Transition:} & pairInsert obtains a pooled Pair from the input BBTree, creates a new Pair with the input Nodes and inserts the Pair by linking it with the Threads associated with the Nodes. Used in \hyperref[SecLFLinked]{markLeafQuery}. \\
	& \textbf{Output:} & None.  \newfunc 
	
	\iffalse
	% Abstracted as above.
	\textbf{nodeRecycle:} & \textbf{Input:} & nodeRecycle accepts a BBTree pointer and a Node pointer as inputs. \\
	& \textbf{Exceptions:} & None.\\
	& \textbf{Transition:} & nodeRecycle removes the input Node from the input BBTree and recycles it to the tree's pooled Nodes. \\ \nopagebreak %stylebreak
	& \textbf{Output:} & None.  \newfunc
	
	\textbf{nodeFromPool:} & \textbf{Input:} & nodeFromPool accepts a BBTree pointer as input. \\
	& \textbf{Exceptions:} & nodeFromPool may throw an InsufficientBufferSize exception if the size of a Node object exceeds the buffer size (\hyperref[SecECControl]{BUFFER_BYTES}). \\
	& \textbf{Transition:} & nodeFromPool obtains a Node from the input BBTree's pooled Nodes. If there are none, the function allocates a new Node buffer, adds it to the tree's allocated buffers, and adds all the new Nodes to the pool except for the first one, which is returned. \\
	& \textbf{Output:} & nodeFromPool returns the retrieved Node as output.  \newfunc
	
	% Convenient Node setters.
	\textbf{nodeSet:} & \textbf{Input:} & Each nodeSet function accepts two Node pointers as input. \\
	& \textbf{Exceptions:} & None.\\
	& \textbf{Transition:} & Each nodeSet function sets the corresponding children of the first input Node to the second input Node, and the second Node's parent to the first Node. \\
	& \textbf{Output:} & None.  \newfunc
	\fi
	
	\textbf{nodeNew:} & \textbf{Input:} & nodeNew accepts a BBTree pointer and two Node pointers as inputs. \\
	& \textbf{Exceptions:} & None.\\
	& \textbf{Transition:} & nodeNew retrieves a pooled Node and initializes it. The function sets this Node's children to the two input Nodes, its BB to the merged BBs of the two Nodes, and all other values to null. Used for inserting new Nodes in \hyperref[SecLFLinked]{subtreeInsert}. \\
	& \textbf{Output:} & nodeNew returns the initialized Node as output.  \newfunc 
	
	\iffalse
	% Convenient predicate to check if a Node is a leaf.
	\textbf{nodeIsLeaf:} & \textbf{Input:} & nodeIsLeaf accepts a Node pointer as input. \\
	& \textbf{Exceptions:} & None.\\
	& \textbf{Transition:} & None. \\
	& \textbf{Output:} & nodeIsLeaf checks if the input Node is a leaf. It returns true if the input Node has a valid non-null object, and false otherwise.  \newfunc
	
	% Convenient getter for a Node's sibling.
	\textbf{nodeOther:} & \textbf{Input:} & nodeOther accepts two Node pointers as inputs. \\
	& \textbf{Exceptions:} & None.\\
	& \textbf{Transition:} & None. \\
	& \textbf{Output:} & nodeOther retrieves the sibling of the second input Node and returns the sibling Node as output.  \newfunc
	\fi
	
	\textbf{nodeReplace Child:} & \textbf{Input:} & nodeReplaceChild accepts three Node pointers and a BBTree pointer as inputs. \\
	& \textbf{Exceptions:} & nodeReplaceChild may throw a LeafError exception if the user attempts to replace a child of a leaf Node, or an InvalidChild exception if the child Node (second input Node) is not a child of the parent Node (first input Node). \\
	& \textbf{Transition:} & nodeReplaceChild replaces the child (second input Node) of the parent Node (first input Node) with the third input Node, and updates the BBs of all parents of the parent Node. Used in the deletion algorithm of \hyperref[SecLFLinked]{subtreeRemove}. \\
	& \textbf{Output:} & None.  \newfunc
	
	\iffalse
	
	% Self-explanatory. Commented out because the descriptions doen't add much detail to other functions.
	\textbf{BBProximity:} & \textbf{Input:} & BBProximity accepts two BBs as inputs. \\
	& \textbf{Exceptions:} & None.\\
	& \textbf{Transition:} & None. \\
	& \textbf{Output:} & BBProximity calculates the proximity of the input BBs to each other and returns the result as a double.  \newfunc
	\fi
	
	\textbf{subtreeInsert:} & \textbf{Input:} & subtreeInsert accepts two Node pointers and a BBTree pointer as inputs. \\
	& \textbf{Exceptions:} & None.\\
	& \textbf{Transition:} & subtreeInsert inserts the second input Node into the subtree originating from the first input Node, and recalculates the BB of this root. Main insertion subroutine used in \hyperref[SecLFLinked]{leafUpdate} and \hyperref[SecAPSLinked]{BBTreeInsert}. \\
	& \textbf{Output:} & subtreeInsert returns a pointer to the resultant subtree as output.  \newfunc
	
	\textbf{subtreeRemove:} & \textbf{Input:} & subtreeRemove accepts two Node pointers and a BBTree pointer as inputs.\\
	& \textbf{Exceptions:} & None.\\
	& \textbf{Transition:} & subtreeRemove deletes the second input Node and its parent from the subtree originating from the first input Node. Main deletion subroutine used in \hyperref[SecLFLinked]{leafUpdate} and \hyperref[SecAPSLinked]{BBTreeRemove}. \\
	& \textbf{Output:} & subtreeRemove returns a pointer to the resultant subtree as output.  \newfunc
	
	\textbf{markLeafQuery:} & \textbf{Input:} & markLeafQuery accepts two Node pointers, a Boolean value and a MarkContext pointer as inputs. \\
	& \textbf{Exceptions:} & None.\\
	& \textbf{Transition:} & markLeafQuery only makes transitions if the BBs of the two input Nodes intersect. In that case, the function will check if the first input Node is a leaf. If not, the function will recursively search through the left and right subtrees of the first input Node. Otherwise, and if the Node is a left child (the input Boolean value is true), a new Pair will be added with the two Nodes. If the Node is a right child (the input Boolean value is false), a Pair will be added if the Node was updated more recently than the first Node. Finally, markLeafQuery will call the function in the input MarkContext with the objects of both Nodes, the ID zero, and the data (void pointer) in the context. This querying function is used in \hyperref[SecLFLinked]{markLeaf}. \\
	& \textbf{Output:} & None.  \newfunc
	
	\textbf{markLeaf:} & \textbf{Input:} & markLeaf accepts a Node pointer and a MarkContext pointer as inputs. \\
	& \textbf{Exceptions:} & None.\\
	& \textbf{Transition:} & markLeaf checks if first input Node was last updated at the same time as the master tree. If this is true, and if the input MarkContext has a valid static root, the function will call markLeafQuery with the root, the input Node, a value of false and the MarkContext. \\
	& & Afterwards, the function will iteratively move up each Node in the tree and call \hyperref[SecLFLinked]{markLeafQuery} on their siblings. If the timestamps are different, the function will instead iterate through the Pairs of the input Node. For each Pair, it will check if the Node is a leaf of the B-thread, and if so, call the function in the given MarkContext with the object of the leaf in the A-thread, the object of the Node, the ID of the Pair, and the data (void pointer) in the context. In this case, the function then traverses through the Pairs in the B-thread; otherwise, it traverses through the Pairs in the A-thread. Main subroutine used to mark tree leaves in \hyperref[SecLFLinked]{markSubtree}. \\
	& \textbf{Output:} & None.  \newfunc
	
	\textbf{markSubtree:} & \textbf{Input:} & markSubtree accepts a Node pointer and a MarkContext pointer as inputs. \\
	& \textbf{Exceptions:} & None.\\
	& \textbf{Transition:} & markSubtree checks if the input Node is a leaf. If so, it will mark the Node. Otherwise, markSubtree will recursively find and mark its children. This recursive subroutine is used to mark nodes through queries in \hyperref[SecAPSLinked]{BBTreeReindexQuery}. \\
	& \textbf{Output:} & None.  \newfunc
	
	\textbf{leafNew:} & \textbf{Input:} & leafNew accepts a BBTree pointer, a void pointer and a BB as inputs. \\
	& \textbf{Exceptions:} & None.\\
	& \textbf{Transition:} & leafNew retrieves a pooled Node from the input Tree and initializes the Node with the input object (void pointer) and BB. All other variables are zero-initialized. Used for inserting new leaves in \hyperref[SecAPSLinked]{BBTreeInsert}. \\
	& \textbf{Output:} & leafNew returns a pointer to the initialized leaf Node as output.  \newfunc
	
	\textbf{leafUpdate:} & \textbf{Input:} & Each leafUpdate function accepts a Node pointer and a BBTree pointer as inputs. \\
	& \textbf{Exceptions:} & None.\\
	& \textbf{Transition:} & leafUpdate obtains the BB corresponding to the object of the first input Node. If the Node's BB contains this BB, the function will update the Node; it sets the Node's BB to its object's BB, updates the Node's position in the tree, clear its Pairs, and updates its timestamp. leafUpdateWrap is simply a void-returning wrapper for this function. These are used in reindexing operations \hyperref[SecAPSLinked]{BBTreeReindexQuery and BBTreeReindexObject} which require the leaves to be updated. \\
	& \textbf{Output:} & If the Node is updated, leafUpdate returns true. Otherwise, it returns false. leafUpdateWrap calls this function, but discards the Boolean output.  \newfunc
	
	\iffalse
	% This function just returns the input ID.
	\textbf{voidQueryFunc:} & \textbf{Input:} & voidQueryFunc accepts two void pointers, a CollisionID and another void pointer as inputs. \\
	& \textbf{Exceptions:} & None.\\
	& \textbf{Transition:} & None. \\
	& \textbf{Output:} & voidQueryFunc returns the input CollisionID as output.  \newfunc
	\fi
	
	\textbf{leafAddPairs:} & \textbf{Input:} & leafAddPairs accepts a Node pointer and a BBTree pointer as inputs. \\
	& \textbf{Exceptions:} & None.\\
	& \textbf{Transition:} & leafAddPairs attempts to retrieve the master tree. If the tree is valid and has a valid root, the function creates a new MarkContext structure with the tree and call markLeafQuery on the root, the input Node, a value of true and the context structure. Otherwise, it will obtain the root of the index of static bodies, create a new MarkContext structure with the input Tree, the root, and voidQueryFunc, and mark the input Node using this context. Used to add Pairs to leaves in \hyperref[SecAPSLinked]{BBTreeInsert and BBTreeReindexObject}. \\
	& \textbf{Output:} & None.  \newfunc
	
	\iffalse
	% Default equality function for the tree's HashSet of leaves.
	\textbf{leafSetEql:} & \textbf{Input:} & leafSetEql accepts a void pointer and a Node pointer as inputs. \\
	& \textbf{Exceptions:} & None.\\
	& \textbf{Transition:} & leafSetEql checks if the input object (void pointer) is equal to the input Node's object. \\
	& \textbf{Output:} & leafSetEql returns the Boolean result of the above test.  \newfunc
	
	% Wrapper function that calls leafNew when inserting new leaves into the tree's HashSet.
	\textbf{leafSetTrans:} & \textbf{Input:} & leafSetTrans accepts a void pointer and a BBTree pointer as inputs. \\
	& \textbf{Exceptions:} & None.\\
	& \textbf{Transition:} & leafSetTrans creates a new leaf Node with the input Tree, object (void pointer) and BB corresponding to the object. \\
	& \textbf{Output:} & leafSetTrans returns a void pointer to a new leaf Node as output.  \newfunc
	
	% Default iterator function for iterating through each leaf in the HashSet.
	\textbf{eachHelper:} & \textbf{Input:} & eachHelper accepts a Node pointer and an EachContext pointer as inputs. \\
	& \textbf{Exceptions:} & None.\\
	& \textbf{Transition:} & eachHelper calls the function contained in the input EachContext with the input Node's object and the context's data. \\
	& \textbf{Output:} & None.  \newfunc
	
	% Convenience shortcut for the BBTree SpatialIndexClass.
	\textbf{Klass:} & \textbf{Input:} & None. \\
	& \textbf{Exceptions:} & None.\\
	& \textbf{Transition:} & None. \\
	& \textbf{Output:} & Klass returns a pointer to the SpatialIndexClass \hyperref[SecLCLinked]{klass}.  \newfunc
	\fi
\end{longtable*}

%%%%%%%%%%%%%%%%%%%% ASSOCIATIVE DATA STRUCTURE MODULE %%%%%%%%%%%%%%%%%%%%%%%

\section{MIS of the Associative Data Structure Module} \label{MISAssoc}

\subsection{Module Name: HashSet}

\subsection{Uses} \label{SecUAssoc}
	\Control, \Sequence

\subsection{Interface Syntax}

\subsubsection{Exported Constants} \label{SecECAssoc}
	HASH_COEF: \UZ \\
	HASH_COEF := 3344921057 \\
	\newline
	BIN_ERR: HashSetBin \\
	BIN_ERR := \{NULL, UINTPTR_MAX, NULL\}

%\subsubsection{Exported Variables}

\subsubsection{Exported Data Types} \label{SecEDTAssoc}
	HashSetBin: struct \\
	HashSet: struct \\
	HashSetEqlFunc : void* $\times$ void* $\to \mathbb{B}$ \\
	HashSetTransFunc : void* $\times$ void* $\to$ void \\
	HashSetIteratorFunc : void* $\times$ void* $\to$ void \\
	HashSetFilterFunc : void* $\times$ void* $\to \mathbb{B}$

\subsubsection{Exported Access Programs} \label{SecEAPAssoc}
	\renewcommand*{\arraystretch}{1.2}
	\begin{longtable}{| y | x{3.5cm} | y | x{3.5cm} |}
	\hline \textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions} \\ \hline
	HASH_PAIR & HashValue, HashValue & HashValue & - \\ \hline 
	hashSetNew & int, HashSetEqlFunc & HashSet* & - \\ \hline
	hashSetSetDefaultValue & HashSet*, void* & - & - \\ \hline
	hashSetFree & HashSet* & - & - \\ \hline
	hashSetCount & HashSet* & int & - \\ \hline
	hashSetInsert & HashSet*, HashValue, void*, HashSetTransFunc, void* & void* & - \\ \hline
	hashSetRemove & HashSet*, HashValue, void* & void* & - \\ \hline
	hashSetFind & HashSet*, HashValue, void* & void* & - \\ \hline
	hashSetEach & HashSet*, HashSetIteratorFunc, void* & - & - \\ \hline
	hashSetFilter & HashSet*, HashSetFilterFunc, void* & - & - \\ \hline
\end{longtable}

\subsection{Interface Semantics}

\subsubsection{State Variables} \label{SecSVAssoc}
\textbf{HashSetBin:} 
\begin{multicols}{3}
	\noindent elt: void* \\
	hash: HashValue \\
	next: HashSetBin*
\end{multicols}

\noindent \textbf{HashSet:} 
\begin{multicols}{3}
	\noindent entries: \UZ \\
	size: \UZ \\
	eql: HashSetEqlFunc \\
	defaultVal: void* \\
	table: HashSetBin** \\
	pooledBins: HashSetBin* \\
	allocatedBuffers: Array*
\end{multicols}

\subsubsection{State Invariant} \label{SecSIAssoc}
	$\text{HashSet.entries} \le \text{HashSet.size}$

\subsubsection{Assumptions} \label{SecAAssoc}
	hashSetNew is called before any other access programs, and all input pointers are assumed to be non-null.

\subsubsection{Access Program Semantics} \label{SecAPSAssoc}

\renewcommand*{\arraystretch}{\funcPadding}
	\begin{longtable*}{@{} p{3.1cm} l p{\colDescrip}} 
	\textbf{HASH_PAIR:} & \textbf{Input:} & HASH_PAIR is a macro that accepts two HashValues as inputs. \\
	& \textbf{Exceptions:} & None.\\
	& \textbf{Transition:} & None. \\
	& \textbf{Output:} & HASH_PAIR calculates a new HashValue from the pair of input HashValues and returns it as output.  \newfunc
	
	\textbf{hashSetNew:} & \textbf{Input:} & hashSetNew accepts an integer and a HashSetEqlFunc function pointer as inputs. \\
	& \textbf{Exceptions:} & None.\\
	& \textbf{Transition:} & hashSetNew heap-allocates a new HashSet, where the size is the next prime number greater than the input integer. The HashSet's internal equality function is set to the input function, and other variables are zero-initialized. Finally, a new Array is created for the HashSet's allocated buffers, and HashSetBins are allocated for the internal hash table. \\
	& \textbf{Output:} & hashSetNew returns a pointer to the newly-created HashSet.  \newfunc
	
	\textbf{hashSetSet DefaultValue:} & \textbf{Input:} & hashSetSetDefaultValue accepts a HashSet pointer and a void pointer as inputs.\\
	& \textbf{Exceptions:} & None.\\
	& \textbf{Transition:} & hashSetSetDefaultValue sets the input HashSet's default value variable to the input void pointer. \\
	& \textbf{Output:} & None.  \newfunc
	
	\textbf{hashSetFree:} & \textbf{Input:} & hashSetFree accepts a HashSet pointer as input. \\
	& \textbf{Exceptions:} & None.\\
	& \textbf{Transition:} & hashSetFree frees the internal hash table of the input HashSet, frees its allocated buffers, and finally frees the HashSet itself. \\
	& \textbf{Output:} & None.  \newfunc
	
	\textbf{hashSetCount:} & \textbf{Input:} & hashSetCount accepts a HashSet pointer as input. \\
	& \textbf{Exceptions:} & None.\\
	& \textbf{Transition:} & None. \\
	& \textbf{Output:} & hashSetCount returns the number of hash table entries contained in the input HashSet as an integer.  \newfunc
	
	\textbf{hashSetInsert:} & \textbf{Input:} & hashSetInsert accepts a HashSet pointer, a HashValue, a void pointer, a HashSetTransFunc function pointer and another void pointer as inputs.  \\
	& \textbf{Exceptions:} & None.\\
	& \textbf{Transition:} & hashSetInsert inserts the input element (first void pointer) into the input HashSet and increments its number of entries accordingly, if the element does not already exist. The element is placed in a bin and transformed if the appropriate function and information (second void pointer) are provided. If the HashSet is at capacity, it will be resized accordingly. \\
	& \textbf{Output:} & hashSetInsert returns a void pointer to the inserted element as output.  \newfunc
	
	\textbf{hashSetRemove:} & \textbf{Input:} & hashSetRemove accepts a HashSet pointer, a HashValue and a void pointer as inputs.\\
	& \textbf{Exceptions:} & None.\\
	& \textbf{Transition:} & hashSetRemove deletes the input element (void pointer) from the input HashSet and decrements its number of entries accordingly, if it exists. The bin containing the element is recycled in the process. \\
	& \textbf{Output:} & hashSetRemove returns a void pointer to the removed element as output. If the element does not exist, it returns a null value.  \newfunc
	
	\textbf{hashSetFind:} & \textbf{Input:} & hashSetFind accepts a HashSet pointer, a HashValue and a void pointer as inputs. \\
	& \textbf{Exceptions:} & None.\\
	& \textbf{Transition:} & None. \\
	& \textbf{Output:} & hashSetFind searches through the input HashSet and attempts to find the input element (void pointer). If the element is found, hashSetFind returns a void pointer to the element as output. Otherwise, it returns the HashSet's default value.  \newfunc
	
	\textbf{hashSetEach:} & \textbf{Input:} & hashSetEach accepts a HashSet pointer, a HashSetIteratorFunc function pointer and a void pointer as inputs. \\
	& \textbf{Exceptions:} & None.\\
	& \textbf{Transition:} & hashSetEach iterates through the entries of the input HashSet and calls the input function on each element with the input void pointer. \\
	& \textbf{Output:} & None.  \newfunc
	
	\textbf{hashSetFilter:} & \textbf{Input:} & hashSetFilter accepts a HashSet pointer, a HashSetFilterFunc function pointer and a void pointer as inputs. \\
	& \textbf{Exceptions:} & None.\\
	& \textbf{Transition:} & hashSetFilter iterates through the entries of the input HashSet and removes all entries for which the input filtering function returns false. For each removed element, the bin containing the entry is recycled. The number of entries is updated accordingly. \\
	& \textbf{Output:} & None. \newfunc
\end{longtable*}

\subsubsection{Local Constants} \label{SecLCAssoc}
	primes: array(\Z) \\
	primes := \{5, 13, 23, 47, 97, 193, 389, 769, 1543, 3079, 6151, 12289, 24593, 49157, 98317, 196613, 393241, 786433, 1572869, 3145739, 6291469, 12582917, 25165843, 50331653, 100663319, 201326611, 402653189, 805306457, 1610612741, 0\}

\subsubsection{Local Functions} \label{SecLFAssoc}

\renewcommand*{\arraystretch}{\funcPadding}
	\begin{longtable*}{@{} p{3.0cm} l p{\colDescrip}}
	\textbf{next_prime:} & \textbf{Input:} & next_prime accepts an integer as input. \\
	& \textbf{Exceptions:} & next_prime may throw an IllegalSize exception if the input integer is greater than 1610612741. \\
	& \textbf{Transition:} & next_prime iterates through the \hyperref[SecLCAssoc]{primes} array and finds the nearest prime that is greater than the input integer. Used to determine new size in \hyperref[SecAPSAssoc]{hashSetResize}. \\
	& \textbf{Output:} & next_prime returns the next greatest prime as output.  \newfunc
	
	\iffalse
	% Helper function that checks if a HashSet is full.
	\textbf{setIsFull:} & \textbf{Input:} & setIsFull accepts a HashSet pointer as input. \\
	& \textbf{Exceptions:} & None.\\
	& \textbf{Transition:} & None. \\
	& \textbf{Output:} & setIsFull returns true if the input HashSet is at capacity, and false otherwise. \newfunc
	\fi
	
	\textbf{hashSetResize:} & \textbf{Input:} & hashSetResize accepts a HashSet pointer as input. \\
	& \textbf{Exceptions:} & None.\\
	& \textbf{Transition:} & hashSetResize allocates a new hash table for the input HashSet, approximately double its current size. Each element is rehashed and reinserted into the new table, and the old table is freed. The capacity and number of entries are updated accordingly. \\
	& \textbf{Output:} & None.  \newfunc
	
	\textbf{recycleBin:} & \textbf{Input:} & recycleBin accepts a HashSet pointer and a HashSetBin pointer as inputs. \\
	& \textbf{Exceptions:} & None.\\
	& \textbf{Transition:} & recycleBin deletes the element of the input HashSetBin and adds it to the input HashSet's pooled bins. Used for deletion in \hyperref[SecAPSAssoc]{hashSetRemove and hashSetFilter}, and to recycle bins fresh from the buffer in \hyperref[SecLFAssoc]{getUnusedBin}.  \\
	& \textbf{Output:} & None.  \newfunc
	
	\textbf{getUnusedBin:} & \textbf{Input:} & getUnusedBin accepts a HashSet pointer as input. \\
	& \textbf{Exceptions:} & getUnusedBin may throw a InsufficientBufferSize exception if the size of a HashSetBin object exceeds the buffer size. (\hyperref[SecECControl]{BUFFER_BYTES}). \\
	& \textbf{Transition:} & getUnusedBin retrieves the first unused bin from the input HashSet's pooled bins. If there are no pooled bins, the function allocates a new HashSetBin buffer, adds it to the HashSet's allocated buffers, and adds all the new bins to the pool except for the first one, which is returned. Used for insertion in \hyperref[SecAPSAssoc]{hashSetInsert}. \\
	& \textbf{Output:} & getUnusedBin returns a HashSetBin pointer to the retrieved bin.  \newfunc
\end{longtable*}

\pagebreak

%%%%%%%%%%%%%%%%%%%% APPENDIX %%%%%%%%%%%%%%%%%%%%%%%

\section{Appendix} \label{SecAppendix}

\renewcommand{\thetable}{1}
\renewcommand{\arraystretch}{1.2}
\begin{longtable}{y x{11.6cm}} \caption{Possible Exceptions}\\
	\toprule \textbf{Exception Name} &
	\textbf{Error Message} \\ \midrule
	    AttachedBody & \inquote{You have already added this body to another space. You cannot add it to a second.} \\
	    AttachedShape & \inquote{You have already added this shape to another space. You cannot add it to a second.} \\
	    AttachedStaticBody & \inquote{Internal Error: Changing the designated static body while the old one still had shapes attached.} \\
	    AttachedStaticIndex & \inquote{This static index is already associated with a dynamic index.} \\
	    BodyNotFound & \inquote{Cannot remove a body that was not added to the space. (Removed twice maybe?)} \\
	    BufferOverflow & \inquote{Internal Error: Contact buffer overflow!} \\
	    CollisionContactOverflow & \inquote{Internal Error: Tried to push too many contacts.} \\
	    CollisionError & \inquote{Internal Error: Shape types are not sorted.} \\
	    ContactIndexOutOfBounds & \inquote{Index error: The specified contact index is invalid for this arbiter.} \\ 
	    DuplicateBody & \inquote{You have already added this body to this space. You must not add it a second time.} \\
	    DuplicateShape & \inquote{You have already added this shape to this space. You must not add it a second time.} \\
	    EmptyArray & \inquote{Unable to pop items from an empty array!} \\
	    HighIterWarning & One of: \inquote{High EPA iterations: \#,} \inquote{High GJK iterations: \#,} \inquote{High GJK-\textgreater EPA iterations: \#,} where \# is the number of iterations. \\
	    IllegalBody & One of the above messages, in addition to: \inquote{Body's position is invalid.}, \inquote{Body's velocity is invalid,} \inquote{Body's force is invalid,} \inquote{Body's angle is invalid,} \inquote{Body's angular velocity is invalid,} \inquote{Body's torque is invalid.} \\
	    IllegalSize & \inquote{Tried to resize a hash table to a size greater than 1610612741.} \\
	    ImmutableNumContacts & \inquote{The number of contact points cannot be changed.} \\
	    IndexOutOfBounds & \inquote{Index out of range.} \\
	    InfiniteMass & \inquote{Mass must be positive and finite.} \\
	    InsufficientBufferSize & \inquote{Internal Error: Buffer size too small.} \\
	    InvalidChild & \inquote{Internal Error: Node is not a child of parent.} \\
	    InvalidIter & \inquote{Iterations must be positive and non-zero.} \\
	    LeafError & \inquote{Internal Error: Cannot replace child of a leaf.} \\
	    MainStaticBody &\inquote{Cannot remove the designated static body for the space.} \\
	    NaNMass & \inquote{Body's mass is NaN.} \\
	    NaNMoment & \inquote{Body's moment is NaN}. \\
	    NegativeElasticity & \inquote{Elasticity must be a positive quantity.} \\
	    NegativeFriction & \inquote{Friction must be a positive quantity.} \\
	    NegativeHalfDimensions & \inquote{Half-dimensions should be nonnegative.} \\
	    NegativeMass & \inquote{Body's mass is negative.} \\
	    NegativeMoment & \inquote{Body's moment is negative.} \\
	    NegativeRadius & \inquote{Radius should be nonnegative.} \\
	    NotBBTreeWarn & \inquote{Ignoring BBTreeSetVelocityFunc() call to non-tree spatial index.} \\
	    NotCircleShape & \inquote{Shape is not a circle shape.} \\
	    NotSegmentShape & \inquote{Shape is not a segment shape.} \\
	    NotPolyShape & \inquote{Shape is not a poly shape.} \\
	    SameVertices & \inquote{Internal Error: EPA vertices are the same (\#1 and \#2),} where \#1 and \#2 are the indices of the vertices. \\
	    ShapeNotFound & \inquote{Cannot remove a shape that was not added to the space. (Removed twice maybe?)} \\
	    SpaceLocked & One of: \inquote{This operation cannot be done safely during a call to spaceStep() or during a query. Put these calls into a post-step callback,} \inquote{You cannot manually reindex objects while the space is locked. Wait until the current query or step is complete.} \\
	    SpaceLockUnderflow & \inquote{Internal Error: Space lock underflow.} \\
	    StaticBodyMass & \inquote{You cannot set the mass of static bodies.} \\
	    UnsolvableCollision & \inquote{Unsolvable collision or constraint.} \\
	\bottomrule
\end{longtable}

% TEMPLATE

%\textbf{:} & \textbf{Input:} & \\
%& \textbf{Exceptions:} & \\
%& \textbf{Transition:} & \\
%& \textbf{Output:} &  \newfunc

%may throw an IllegalBody exception if the Body violates any invariant in Section %\ref{SecSIBody} after the transition is complete. 

\end{document}