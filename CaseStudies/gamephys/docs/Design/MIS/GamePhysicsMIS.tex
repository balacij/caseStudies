\documentclass[12pt]{article}

\usepackage{bm} 
\usepackage[all]{nowidow}
\usepackage{amsmath, mathtools} 
%\usepackage[round]{natbib}
\usepackage{amsfonts}
\usepackage{amssymb} 
\usepackage{graphicx} 
\usepackage{colortbl}
\usepackage{xr} 
\usepackage{hyperref} 
\usepackage{array}
\usepackage{longtable} 
\usepackage{xfrac} 
\usepackage{tabularx} 
\usepackage{float} 
\usepackage{siunitx} 
\usepackage{booktabs} 
\usepackage{multirow} 
\usepackage[section]{placeins}
\usepackage{xcolor} 
\usepackage{multicol} 
\usepackage{caption}
\usepackage{enumitem}
\usepackage{underscore}
\usepackage{threeparttablex}
\usepackage{comment}
\usepackage[square,sort]{natbib}

%\usepackage{refcheck}

\hypersetup{ bookmarks=true, % show bookmarks bar?  
colorlinks=true, %false: boxed links; true: coloured links 
linkcolor=red, % color of internal links (change box color with 
%linkbordercolor)
citecolor=green, % color of links to bibliography 
filecolor=magenta, %color of file links 
urlcolor=cyan % color of external links 
}

\newcommand{\colZwidth}{1.0\textwidth} \newcommand{\blt}{- } 
\newcommand{\colAwidth}{0.13\textwidth}
\newcommand{\colBwidth}{0.82\textwidth}
\newcommand{\colCwidth}{0.1\textwidth}
\newcommand{\colDwidth}{0.05\textwidth}
\newcommand{\colEwidth}{0.8\textwidth}
\newcommand{\colFwidth}{0.17\textwidth}
\newcommand{\colGwidth}{0.5\textwidth}
\newcommand{\colHwidth}{0.28\textwidth}
\newcommand{\colDescrip}{0.63\textwidth}
\newcommand{\funcPadding}{1.3}
\newcommand{\newfunc}{\\[1.5em]}
\newcommand{\inquote}[1]{``{#1}"}

\newcommand{\progname}{Tamias2D }
\newcommand{\vor}{$\vee$ }
\newcommand{\B}{$\mathbb{B}$}
\newcommand{\R}{$\mathbb{R}$}
\newcommand{\Z}{$\mathbb{Z}$}
\newcommand{\UZ}{$\mathbb{Z}^+$}

\newcounter{nmnum} \newcommand{\nmthenmnum}{NM\thenmnum}
\newcommand{\nmref}[1]{NM\ref{#1}}

\newcommand{\un}{\si{unitless}}
\newcommand{\du}{\si{data unit}}
\setitemize{itemsep=0pt}
\externaldocument[SRS-]{../../SRS/GamePhysicsSRS}
\externaldocument[MG-]{../MG/GamePhysicsMG}

% define "struts", as suggested by Claudio Beccari in 
% a piece in TeX and TUG News, Vol. 2, 1993.  
\newcommand{\Tstrut}{\rule{0pt}{2.6ex}} %= `top' strut

%\oddsidemargin 0mm %\evensidemargin 0mm %\textwidth 160mm
%\textheight 200mm 
\usepackage{fullpage}

\newcommand{\blue}[1]{\textcolor{blue}{#1}}
\newcommand{\green}[1]{\textcolor{black!40!green}{#1}}

%% Comments 
\input{../../Comments}

\newcolumntype{x}[1]{>{\raggedright\arraybackslash}m{#1}}
\newcolumntype{y}{>{\raggedright\arraybackslash}l}

\newcommand{\Body}{\hyperref[MISBody]{Rigid Body Module}}
\newcommand{\Shape}{\hyperref[MISShape]{Shape Module}}
\newcommand{\Circle}{\hyperref[MISCircle]{Circle Module}}
\newcommand{\Segment}{\hyperref[MISSegment]{Segment Module}}
\newcommand{\Poly}{\hyperref[MISPoly]{Polygon Module}}
\newcommand{\Space}{\hyperref[MISSpace]{Space Module}}
\newcommand{\Arbiter}{\hyperref[MISArbiter]{Arbiter Module}}
\newcommand{\Control}{\hyperref[MISControl]{Control Module}}
\newcommand{\Vector}{\hyperref[MISVector]{Vector Module}}
\newcommand{\BB}{\hyperref[MISBB]{Bounding Box Module}}
\newcommand{\Transform}{\hyperref[MISTransform]{Transform Matrix Module}}
\newcommand{\SpatialIndex}{\hyperref[MISSpatial]{Spatial Index Module}}
\newcommand{\Collision}{\hyperref[MISCollision]{Collision Solver Module}}
\newcommand{\Sequence}{\hyperref[MISSequence]{Sequence Data Structure Module}}
\newcommand{\Linked}{\hyperref[MISLinked]{Linked Data Structure Module}}
\newcommand{\Assoc}{\hyperref[MISAssoc]{Associative Data Structure Module}}

\begin{document}

\title{Module Interface Specification for \progname:\\ A 2D Game Physics Library} \author{Luthfi Mawarid and Oluwaseun Owojaiye}
\date{\today}
\maketitle

~\newpage
\pagenumbering{roman}

\section{Revision History}

\begin{tabularx}{\textwidth}{p{3cm}p{2cm}X}
	\toprule {\bf Date} & {\bf Version} & {\bf Notes}\\
	\midrule
	Nov. 15, 2018 & 1.0 & Updates throughout document; siimplifying document\\
	Nov 20, 2018 & 1.1 & Notes\\
	\bottomrule
\end{tabularx}

~\newpage

\section{Symbols, Abbreviations and Acronyms}

See SRS Documentation at \url{https://github.com/smiths/caseStudies/blob
	/master/CaseStudies/gamephys/docs/SRS/GamePhysicsSRS.pdf}

~\newpage
\tableofcontents

~\newpage
\pagenumbering{arabic}

\section{Introduction} \label{SecIntro}

The following document details the Module Interface
Specifications for the implemented modules in the \progname Game Physics Library.  It is intended to ease navigation through the program for design and
maintenance purposes.  Complementary documents include the System
Requirement Specifications and Module Guide. The full documentation and implementation can be found at \url{https://github.com/smiths/caseStudies/tree/master/CaseStudies/gamephys}

\section{Notation} \label{SecNotation}

The structure of the MIS for modules comes from \citet{HoffmanAndStrooper1995} ,
with the addition that template modules have been adapted from
\cite{GhezziEtAl2003} .  The mathematical notation comes from Chapter 3 of
\citet{HoffmanAndStrooper1995} .  
For instance, the symbol := is used for a
multiple assignment statement and conditional rules follow the form $(c_1
\Rightarrow r_1 | c_2 \Rightarrow r_2 | ... | c_n \Rightarrow r_n )$.\\

The following table summarizes the primitive data types used by \progname. 
\begin{center}
\renewcommand*{\arraystretch}{1.2}
\noindent  \begin{longtable}{l l p{10.5cm}} 
\toprule 
\textbf{Data Type} & \textbf{Notation} & \textbf{Description} \\ 
\midrule
boolean & $\mathbb{B}$ & An element of \{true, false\}. \\
character & char & A single symbol or digit. \\
real & $\mathbb{R}$ & Any number in (-$\infty$, $\infty$). \\
integer & $\mathbb{Z}$ & A number without a fractional
  component in (-$\infty$, $\infty$). \\
natural number & $\mathbb{N}$ & A number without a fractional
  component in $[1, \infty)$. \\
\bottomrule
\end{longtable}
\end{center} 

The specification of \progname \ uses some derived data types: sequences, strings, and tuples. Sequences are lists filled with elements of the same data type. Strings
are sequences of characters. Tuples contain a list of values, potentially of different types. In addition, \progname \ uses functions, which
are defined by the data types of their inputs and outputs. Local functions are described by giving their type signature followed by their specification.

Here is a table to summarize the derived data types:



\begin{center}
	
	\renewcommand{\arraystretch}{1.2}
	
	\noindent 
	
	\begin{tabular}{l l p{7.5cm}} 
		
		\toprule 
		
		\textbf{Data Type} & \textbf{Notation} & \textbf{Description}\\ 
		
		\midrule
		
		bodyType & Body & an object used by \progname{} to represent a rigid body  \\
		
		vector & Vec2d & an object used by \progname{} to store vector values i.e x, y coordinates\\ 
		
		space & Space & an object used by \progname{} to represent the simulation space \\
		
		\bottomrule
		
	\end{tabular} 
	
\end{center}


\wss{I'm not sure we need pointers at this point.  An abstract design probably
  shouldn't have to invoke the concept of pointers.}\olu{updated}

%\renewcommand*{\arraystretch}{1.2}
%\noindent \begin{longtable}{l l p{9.5cm}}
%\toprule
%	\textbf{Data Type} & \textbf{Notation} & \textbf{Description} \\
%\midrule
%	Array & array(\textit{T}) & A list of a given data type \textit{T}. \\
%	Enumeration & enum & A data type containing named, constant values. \\
%	String & string/array(char) & An array of characters. \\
%	Structure & struct & A data type that can store multiple fields of different data types in one variable. \\
%	Union & union & Similar to a structure, but only one field can contain a value at any given time. \\
%	\bottomrule
%\end{longtable}

\wss{I really don't think we need void in the abstract MIS.  If an access
  program doesn't return any value, we just don't assign it one.} \olu{removed section}


\section{Module Decomposition} 

The following table is taken directly from the Module Guide document for this project.

\begin{table}[h!]
\centering
\begin{tabular}{p{0.3\textwidth} p{0.4\textwidth} p{0.6\textwidth}}
\toprule
\textbf{Level 1} & \textbf{Level 2}  & \textbf{Level 3} \\
\midrule
		
		
{Hardware-Hiding Module} & ~ \\
\midrule
 ~\newpage	
 \multirow{3}{0.3\textwidth}{Behaviour-Hiding Module}
& Rigid Body\\
& Shape\\
%& \multirow{3}{0.3\textwidth}{Shape Module} 
& &Circle \\
%& &Segment \\
& &Polygon \\
& Space\\ 
\midrule
		
\multirow{3}{0.3\textwidth}{Software Decision Module} 
& Vector\\ 
&Collision Solver \\  
		
\bottomrule
		
			
	\end{tabular}
	
	\caption{Module Hierarchy}
	
	\label{TblMH}
	
\end{table}

~\newpage
%%%%%%%%%%%%%%%%%%%% RIGID BODY MODULE %%%%%%%%%%%%%%%%%%%%%%%
~\newpage
\newpage \wss{put a newpage between all modules.}\olu{noted}

\section{MIS of the Rigid Body Module} \label{MISBody}

\subsection{Module} 
Body

\subsection{Uses} \label{SecUBody}
	\Shape, \Space, \Vector 
	
\subsection{Syntax}

\subsubsection{Exported Constants}

N/A

	
\subsubsection{Exported Access Programs} \label{SecEAPBody}

\begin{center}
	\begin{tabular}{p{4cm} p{4cm} p{4cm} p{2cm}}
		\hline
		\textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions} \\
		\hline
		{BodyInit} & $\mathbb{R}$,$\mathbb{R}$, ($\mathbb{R}$$_{x}$,$\mathbb{R}$$_{y}$), $\mathbb{R}$,$\mathbb{N}$, $\mathbb{R}$ & $Body$ & massError \\
		\hline
		{Update} & $Body$ &($\mathbb{R}$$_{x}$,$\mathbb{R}$$_{y}$),($\mathbb{R}$$_{x}$,$\mathbb{R}$$_{y}$) & - \\
		\hline
		{apply\_force} & $Body$  &$Vec2d$& - \\
		\hline
		{apply\_torque} & $Body$  &$\mathbb{R}$& - \\
		\hline
		{set\_space} & $Body$  &$Space$& - \\
		\hline
		{set\_angular\_accler} & $Body$  &$\mathbb{R}$& - \\
		\hline
	\end{tabular}
\end{center}
	
\subsubsection{Exported Constants}
${C_R}$ := 1

\subsection{Semantics}

\subsubsection{State Variables} \label{SecSVBody}
%	\textbf{BodyType} $\in$ \{DYNAMIC, STATIC\}
	 \wss{if you are going to
          create a new type, then this should be an exported type, not a state variable.}
	\newline
%	\textbf{Body:}
	 \wss{I don't know what this heading means?  You can just
          have your list of state variables.}
	 \begin{multicols}{3}
		\noindent type: BodyType \\
	%	positionFunc: PositionFunc \\
	%	velocityFunc: VelocityFunc \\
		mass: \R \\
		massInv: \R \\
		moment: \R \\
		momentInv: \R \\
		%com: Vector \\
		position: Vec2d \\
		velocity: Vec2d \\
		force: Vec2d \\
		angle: \R \\
		angular_accl: \R \\
		torque: \R \\
		space: Space \\
	\end{multicols}
	\wss{You don't need the pointers.  That is an implementation detail.}
	\olu{updated section}

\wss{Most of the state invariants above are just restating the type of the state
  variables.  This is redunant and can be removed.  For more interesting
  invariants, like the one about the mass being positive, you need to make sure
  that the constructor will not allow this invariant to be violated.  I can see
  below that this is not done.  Invariants aren't automatically true.  Your
  specification needs to enforce them.}

\subsubsection{Environment Variables}	\label{SecEVBody}
N/A
\subsubsection{Assumptions} \label{SecABody} 
N/A
					\wss{This is far
          too implementation specific.  Don't worry about pointers at this point.}

\subsubsection{Access Routine Semantics} \label{SecAPSBody}

\renewcommand*{\arraystretch}{\funcPadding}
\begin{longtable*}{@{} p{3.3cm} l p{\colDescrip}} 

\textbf{bodyInit:} %& \textbf{Input:} & bodyInit accepts a Body pointer and two double values as inputs. \\
%& \textbf{Exceptions:} & None.\\
& \textbf{Transition:} & bodyInit allocates a new Body and initializes its mass,
moment, bodyType, restitution, angle and shape with the input values. Other
fields are zero-initialized and kinematic functions are set to default
ones. \wss{Where do these inputs come from?  Only two real numbers are passed to
  body?}\\

& \textbf{Output:} & bodyInit returns a pointer to the initialized Body.\newfunc
& \textbf{Exceptions:} & None.\wss{Why aren't you checking that the mass is positive?}\\ 
%\textbf{newBody:} & \textbf{Input:} & newBody accepts two double values as inputs. \\
%& \textbf{Exceptions:} & newBody may throw a NaNMass, NaNMoment, NegativeMass or NegativeMoment exception when the user provides NaN or negative values for input, or an InfiniteMass exception when the user provides an infinite value for the first input double. \\
%& \textbf{Transition:} & newBody will allocate a new Body, initialize it with the input and default values, and set it to a dynamic body. \\
%& \textbf{Output:} & newBody returns a pointer to the new Body. \newfunc  \pagebreak %stylebreak

%\textbf{newStaticBody:} & \textbf{Input:} & None. \\
%& \textbf{Exceptions:} & None.\\
%& \textbf{Transition:} & newStaticBody creates a new Body and sets it to a static body. \\
%& \textbf{Output:} & newStaticBody returns a pointer to the new Body. \newfunc
	
%\textbf{bodyDestroy:} & \textbf{Input:} & bodyDestroy accepts a Body pointer. \\
%& \textbf{Exceptions:} & None.\\
%& \textbf{Transition:} & bodyDestroy frees the input Body object.\\
%& \textbf{Output:} & None. \newfunc

%\textbf{bodyGet:} & \textbf{Input:} & Each bodyGet function accepts a Body pointer as input.  \\
%& \textbf{Exceptions:} & None.\\
%& \textbf{Transition:} & None. \\
%& \textbf{Output:} & Each bodyGet function returns the value of their corresponding parameter.\newfunc

%\textbf{bodySet:} & \textbf{Input:} & Each bodySet function accepts a Body pointer and their corresponding value as inputs.  \\
%& \textbf{Exceptions:} & Various, see Section \ref{SecEAPBody}. The IllegalBody exception occurs when any invariant in \ref{SecSIBody} is violated. \\
%& \textbf{Transition:} & Each bodySet function will modify the state of their corresponding parameter to the input value, if valid. bodySetMass and bodySetMoment will also modify the inverse values of the parameters. bodySetType will reset the Body's mass, moment and velocities if changed to a static type, or recalculate its mass from attached Shapes if changed to a dynamic type. It also updates any associated Space accordingly. \\
%& \textbf{Output:} & None. \newfunc
%
%\textbf{bodyAccumulate Mass FromShapes} & \textbf{Input:} & bodyAccumulateMassFromShapes accepts a Body pointer as input. \\
%& \textbf{Exceptions:} & bodyAccumulateMassFromShapes may throw an IllegalBody exception if the Body violates any invariant in \ref{SecSIBody} after the transition is complete. \\
%& \textbf{Transition:} & The function recalculates the mass, moment and centre of mass of the Body based on the masses, moments and centres of mass of Shapes associated with it. It will modify the mass and moment inverses accordingly, realign the Body's position in Space, and check that it satisfies all invariants. \\
%& \textbf{Output:} & None. \newfunc
%
%\textbf{bodyAddShape:} & \textbf{Input:} & bodyAddShape accepts a Body pointer and a Shape pointer as inputs. \\
%& \textbf{Exceptions:} & None.\\
%& \textbf{Transition:} & The function will add the input Shape to the input Body's list of Shapes and recalculate the Body's mass accordingly. \\
%& \textbf{Output:} & None. \newfunc
%
%\textbf{bodyRemove Shape:} & \textbf{Input:} & bodyRemoveShape accepts a Body pointer and a Shape pointer as inputs. \\
%& \textbf{Exceptions:} & None.\\
%& \textbf{Transition:} & The function will remove the input Shape from the Body's list of Shapes and, if the Body is dynamic, recalculate its mass accordingly. \\
%& \textbf{Output:} & None. \newfunc

%\textbf{bodyUpdate Position:} & \textbf{Input:} & bodyUpdatePosition accepts a Body pointer and a double value as inputs. \\
%& \textbf{Exceptions:} & bodyUpdatePosition may throw an IllegalBody exception if the Body violates any invariant in \ref{SecSIBody} after the transition is complete. \\
%& \textbf{Transition:} & bodyUpdatePosition will update the Body's position and angle based on its linear and angular velocities, respectively, their bias values, and the timestep, which is the second input value. It then resets the bias values and checks if any invariant has been violated. \\
%& \textbf{Output:} & None. \newfunc

\textbf{Update :} %& \textbf{Input:} & bodyUpdatePosition accepts a Body pointer and a double value as inputs. \\
& \textbf{Transition:}  & Update will update Body's position and all other
parameters (bodyInit) associated to the body after each cycle. \wss{How is the
  update done?  The equations from your SRS should appear in your MIS.  You
  haven't given enough information for someone to code this module.}\\
& \textbf{Output:} & None. \wss{If there is no output, do not include this
  field.  Remember that output and transition are unlikely to go together,
  except for constructors.}\newfunc
& \textbf{Exceptions:} & None \\

\textbf{apply_force:} & \textbf{Transition:} & apply_force will apply forces on
the rigid bodies and it recalculates the total force acting on each
body. \wss{What state variable is updated?} \\%& \textbf{Input:}  bodyUpdateVelocity accepts a Body pointer, a Vector and a double value as its input. \\
& \textbf{Output:} & None. \newfunc
& \textbf{Exceptions:} & None \\

\textbf{apply_torque:} & \textbf{Transition:} & apply_torque will apply
forces(for rotation) on rigid bodies and recalculates the total torque acting on
each body.  \wss{What state variable is updated?  How is it changed?  I should
  see an explicit change to a state variable, not just vague words.}\\
& \textbf{Output:} & None. \newfunc
& \textbf{Exceptions:} & None \\

%\textbf{bodyKinetic Energy:} & \textbf{Input:} & bodyKineticEnergy accepts a Body pointer as input. \\
%& \textbf{Exceptions:} & None.\\
%& \textbf{Transition:} & bodyKineticEnergy will calculate the Body's kinetic energy based on its mass, moment, and linear and angular velocities. \\
%& \textbf{Output:} & bodyKineticEnergy returns a double value representing the kinetic energy. \newfunc

%\textbf{bodyEach:} & \textbf{Input:} & Each bodyEach function accepts a Body pointer, a function pointer to the corresponding iterator, and a void pointer as inputs. \\
%& \textbf{Exceptions:} & None.\\
%& \textbf{Transition:} & Each bodyEach function will iterate through the Body's Shapes or Arbiters, depending on the function's corresponding parameter, and apply the input function to each object in the list, using the data (void pointer) from the third input value. \\
%& \textbf{Output:} & None.  \newfunc
\end{longtable*} 

\wss{There are state variables that do not appear to have any transitions.  How
  are they influenced?  Is there no way to inspect the values of the state
  variables?  You have an access program for set space, but you don't actually
  specify it.}

\subsubsection{Local Functions} \label{SecLFBody}

N/A

%\renewcommand*{\arraystretch}{\funcPadding}
%\begin{longtable*}{@{} p{2.6cm} l p{\colDescrip}} 
%\textbf{vectAssert NaN:} & \textbf{Input: } & vectAssertNaN accepts a Vector and a string as inputs. \\
%& \textbf{Exceptions:} & vectAssertNaN throws an exception if the input Vector has NaN values for its fields. \\
%& \textbf{Transition:} & vectAssertNaN checks if the fields of the input Vector are valid numbers. If this test fails, it prints the input string as an error message. Called by \hyperref[SecLFBody]{vectAssertSane}. \\
%& \textbf{Output:} & None.  \newfunc
%
%\textbf{vectAssert Infinite:} & \textbf{Input:} & vectAssertInfinite accepts a Vector and a string as inputs. \\
%& \textbf{Exceptions:} & vectAssertInfinite throws an exception if the input Vector has infinite values for its fields. \\
%& \textbf{Transition:} & vectAssertInfinite checks if the fields of the input Vector are finite. If this test fails, it prints the input string as an error message. Called by \hyperref[SecLFBody]{vectAssertSane}. \\
%& \textbf{Output:} & None.  \newfunc
%
%\textbf{vectAssert Sane:} & \textbf{Input:} & vectAssertSane accepts a Vector and a string as inputs. \\
%& \textbf{Exceptions:} & vectAssertSane throws an exception if the input Vector has NaN or infinite values for its fields. \\
%& \textbf{Transition:} & vectAssertSane checks if the fields of the input Vector are valid and finite double values. If this test fails, it prints the input string as an error message. Called by \hyperref[SecLFBody]{assertSaneBody}. \\
%& \textbf{Output:} & None.  \newfunc
%
%\textbf{assertSane Body:} & \textbf{Input:} & assertSaneBody accepts a Body pointer as input. \\
%& \textbf{Exceptions:} & assertSaneBody may throw an IllegalBody exception if the Body violates any invariant in \ref{SecSIBody} after the transition is complete. \\
%& \textbf{Transition:} & assertSaneBody checks if the input Body satisfies all state invariants, and prints various error messages depending on the first invariant found to be violated. Called by various functions in Section \ref{SecAPSBody}. \\
%& \textbf{Output:} & None. \newfunc
%
%\textbf{bodySet Transform:} & \textbf{Input:} & bodySetTransform accepts a Body pointer, a Vector, and a double value as inputs. \\
%& \textbf{Exceptions:} & None.\\
%& \textbf{Transition:} & bodySetTransform mutates the input Body's transformation matrix (used to obtain its local position) using the input position Vector and a rotation vector converted from the given angle (last input value). Called by \hyperref[SecAPSBody]{bodySetPosition and bodySetAngle}. \\
%& \textbf{Output:} & None.  \newfunc
%\end{longtable*}

%%%%%%%%%%%%%%%%%%%% SHAPE MODULE %%%%%%%%%%%%%%%%%%%%%%%

\section{MIS of the Shape Module} \label{MISShape}

\wss{I have similar comments on this module to the previous.  Exported types
  should be in an exported types field, or in their own ADT.  You shouldn't show
  transition and output for every module.  You don't want to use pointers.  Put
  a newpage between modules.  Transitions and outputs should be expressed as
  equations, not words.}

\wss{Modifying the previous documentation by deleting the things that don't
  apply isn't really working well.  The previous design is far too tied to the
  Chipmunk implementation.  We want the new documentation to follow the MIS
  examples we showed in class.  We also want it much simpler.  It should be
  based on the SRS, not the code.}

\wss{You seem to have inheritance, but you haven't used the way we covered in
  class to show it.}

\subsection{Module Name: Shape} 

\subsection{Uses} \label{SecUShape}
	 \Body, \Space, \Vector,

\subsection{ Syntax}

\subsubsection{Exported Constants} \label{SecECShape}
%	MAGIC_EPSILON: \R \\
%	MAGIC_EPSILON := $1 \times 10^{-5}$ \\
%	\newline
%	POLY_SHAPE_INLINE_ALLOC: \UZ \\
%	POLY_SHAPE_INLINE_ALLOC := $6$ 
N/A	
%\subsubsection{Exported Data Types} \label{SecEDTShape}
%	ShapeType: enum \\
%	ShapeMassInfo: struct \\
%	ShapeClass: struct \\
%	Shape: struct \\
%	ShapeCacheDataImpl : Shape* $\times$ Transform $\to$ BB \\
%	ShapeDestroyImpl : Shape* $\to$ void
	
\subsubsection{Exported Access Programs} \label{SecEAPShape}
	\renewcommand*{\arraystretch}{1.2}
	\begin{longtable}{| y | x{3.5cm} | y | x{3.5cm} |}
		\hline \textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions} \\ \hline 
		%shapeInit & Shape*, ShapeClass*, Body*, ShapeMassInfo & Shape* & - \\ \hline
		set_angle & Shape* & $\mathbb{R}$ & - \\ \hline
		set_pos & Shape* & Vec2* & - \\ \hline
		get_center & Shape* & Vec2* & - \\ \hline
%		shapeDestroy & Shape* & - & - \\ \hline
%		shapeGetSpace & Shape* & Space* & - \\ \hline
%		shapeGetBody & Shape* & Body* & - \\ \hline
%		shapeGetMass & Shape* & double & - \\ \hline
%		shapeGetDensity & Shape* & double & - \\ \hline
%		shapeGetMoment & Shape* & double & - \\ \hline
%		shapeGetArea & Shape* & double & - \\ \hline
%		shapeGetCenterOfMass & Shape* & Vector & - \\ \hline
%		shapeGetBB & Shape* & BB & - \\ \hline
%		shapeGetElasticity & Shape* & double & - \\ \hline
%		shapeGetFriction & Shape* & double & - \\ \hline
%		shapeGetSurfaceVelocity & Shape* & Vector & - \\ \hline
%		shapeGetCollisionType & Shape* & CollisionType & - \\ \hline
%		shapeSetMass & Shape*, double & - & IllegalBody \\ \hline
%		shapeSetDensity & Shape*, double & - & IllegalBody \\ \hline
%		shapeSetElasticity & Shape*, double & - & NegativeElasticity \\ \hline
%		shapeSetFriction & Shape*, double & - & NegativeFriction \\ \hline
%		shapeSetSurfaceVelocity & Shape*, Vector & - & - \\ \hline
%		shapeSetCollisionType & Shape*, CollisionType & - & - \\ \hline
%		shapeCacheBB & Shape* & BB & - \\ \hline
%		shapeUpdate & Shape*, Transform & BB & - \\ \hline
	\end{longtable}
	
\subsection{Semantics}

\subsubsection{State Variables} \label{SecSVShape}
	\textbf{ShapeType} $\in$ \{CIRCLE, POLYGON\} \\
%	\newpage %BREAK
	\noindent 
%\textbf{ShapeMassInfo:}
%	\begin{multicols}{2}
%		\noindent mass: \R \\
%		moment: \R \\
%		com: Vector \\
%		area: \R
%	\end{multicols}
	\noindent \textbf{ShapeClass:}
	\begin{multicols}{2}
		\noindent type: ShapeType \\
%		cacheData: ShapeCacheDataImpl \\
%		destroy: ShapeDestroyImpl \\
	\end{multicols}
	\noindent \textbf{Shape:}
	\begin{multicols}{2}
		\noindent Colshape: ShapeClass* \\
		space: Space* \\
		body: Body* \\
%		massInfo: ShapeMassInfo \\
%		bb: BB \\
%		elast: \R \\
%		fric: \R \\
%		surfaceVel: Vector \\
		type: CollisionType \\
%		next: Shape* \\
%		prev: Shape* \\
%		hashId: HashValue
	\end{multicols}
	
%\subsubsection{State Invariants} \label{SecSIShape}
%	$\text{Shape.elast} \ge 0 $ \\
%	$\text{Shape.fric} \ge 0 $ 

\subsubsection{Enviroment Vaiables}
None
\subsubsection{Assumptions} \label{SecAShape}
	All input pointers are assumed to be non-null. Also see \ref{SecACircle}, \ref{SecAPoly}.
	
\subsubsection{Access Program Semantics} \label{SecAPSShape}
	\renewcommand*{\arraystretch}{\funcPadding}
	\begin{longtable*}{@{} p{3.3cm} l p{\colDescrip}} 
	
		& \textbf{Transition:} & None. \\
		\textbf{get_center:} & \textbf{Exceptions:} & None. \\
		& \textbf{Output:} &get_center returns the coordinates of the input Shape object.\\
		
%		\textbf{shapeDestroy:} & \textbf{Input:} & shapeDestroy accepts a Shape pointer as input. \\
%		& \textbf{Exceptions:} & None. \\ \pagebreak %stylebreak
%		& \textbf{Transition:} & shapeDestroy frees the input Shape object. \\ 
%		& \textbf{Output:} & None.  \newfunc 
%		
%		\textbf{shapeGet:} & \textbf{Input:} & Each shapeGet function accepts a Shape pointer as input. \\
%		& \textbf{Exceptions:} & None.\\
%		& \textbf{Transition:} & None. \\
%		& \textbf{Output:} & Each shapeGet function returns the value of their corresponding parameter.  \newfunc
		
		\textbf{set_angle:} & \textbf{Transition:} & Each set_angle function sets their corresponding angle with the input value\\
		& \textbf{Exceptions:} & None. \\
		& \textbf{Output:} & None.  \newfunc
		
		\textbf{set_pos:} & \textbf{Transition:} & Each set_pos function sets their corresponding position of a shape pointer in space\\
		& \textbf{Exceptions:} & None. \\
		& \textbf{Output:} & None.  
				
%		\textbf{shapeCacheBB:} & \textbf{Input:} & shapeCacheBB accepts a Shape pointer as input. \\
%		& \textbf{Exceptions:} & None.\\
%		& \textbf{Transition:} & shapeCacheBB updates the input Shape using the Transform matrix of its associated Body and modifies its bounding box (BB). \\
%		& \textbf{Output:} & shapeCacheBB returns the new BB as output.  \newfunc
%		
%\textbf{shapeUpdate:} & \textbf{Input:} & shapeUpdate accepts a Shape pointer and a Transform matrix as inputs.\\
%& \textbf{Exceptions:} & None.\\
%& \textbf{Transition:} & shapeUpdate will call the cacheData function in the input Shape's class using the given parameters and modify the Shape's BB. \\
%& \textbf{Output:} & shapeUpdate returns the BB returned by the cacheData function as output.  \newfunc
%\textbf{get_centre:} & \textbf{Transition:} & None\\
%%	& \textbf{Exceptions:} & None. \\
%%	& \textbf{Output:} & get_center returns the coordinates of the centre of a shape pointer.\\
	\end{longtable*}

\subsection{Submodule Name: CircleShape} \label{MISCircle}

\wss{Out template doesn't have a heading called Submodule.  I don't know what
  this means.  Document inheritance as we discussed it in class.}

\subsection{Uses} \label{SecUCircle}
	\Body, \Shape, \Vector

\subsection{Syntax}

\subsubsection{Exported Data Types} \label{SecEDTCircle}
	CircleShape: struct

\subsubsection{Exported Access Programs} \label{SecEAPCircle}
	\renewcommand*{\arraystretch}{1.2}
	\begin{longtable}{| y | x{3.5cm} | y | x{3.5cm} |} 
		\hline \textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions} \\ \hline 
%		circleShapeAlloc & - & CircleShape* & - \\ \hline
		circleShapeInit & CircleShape*, Body*, double, Vector & CircleShape* & - \\ \hline
		get_center & Shape* & double & NotCircleShape \\ \hline
		circleShapeNew & Body*, double, Vector & Shape* & - \\ \hline
		circleShapeGetRadius & Shape* & double & NotCircleShape \\ \hline
%		circleShapeGetOffset & Shape* & Vector & NotCircleShape \\ \hline
		circleShapeSetRadius & Shape*, double & - & NotCircleShape \vor IllegalBody \\ \hline
%		circleShapeSetOffset & Shape*, Vector & - & NotCircleShape \vor IllegalBody \\ \hline
		momentForCircle & double, double, double, Vector & double & - \\ \hline
		areaForCircle & double, double & double & - \\ \hline
	\end{longtable}

\wss{How is the center of the circle a double?}
\wss{Why aren't the semantics given for all of the access programs?}
	
\subsection{Semantics}

\subsubsection{State Variables} \label{SecSVCircle}
	\textbf{CircleShape:}
	\begin{multicols}{2}
		\noindent shape: Shape \\
		center: Vector \\
	%	tcenter: Vector \\
		radius: \R
	\end{multicols}
%	\noindent Note that \textit{center} is the centroid of the circle, and \textit{tcenter} is the transformed centroid in global coordinates.
	
\subsubsection{Assumptions} \label{SecACircle}
circleShapeNew have been called before any other access programs. 
All input pointers are also assumed to be non-null.
	
\subsubsection{Access Program Semantics} \label{SecAPSCircle}
	\renewcommand*{\arraystretch}{\funcPadding}
	\begin{longtable*}{@{} p{3.5cm} l p{\colDescrip}} 
%		\textbf{circleShapeAlloc:} & \textbf{Input:} & None. \\
%		& \textbf{Exceptions:} & None.\\
%		& \textbf{Transition:} & None. \\
%		& \textbf{Output:} & circleShapeAlloc heap-allocates a new CircleShape object and returns a pointer to it as output.  \newfunc
		
		\textbf{circleShapeInit:} & \textbf{Input:} & circleShapeInit accepts a CircleShape pointer, a Body pointer, a double and a Vector as inputs. \\
		& \textbf{Exceptions:} & None.\\
		& \textbf{Transition:} & circleShapeInit initializes the input CircleShape. It sets the radius to the input double, the center to the input Vector, and then initializes the rest of the variables using shapeInit and the input Body. \\
		& \textbf{Output:} & circleShapeInit returns a pointer to the initialized CircleShape.  \newfunc
		
		\textbf{circleShapeNew:} & \textbf{Input:} & circleShapeNew accepts a Body pointer, a double and a Vector as inputs. \\
		& \textbf{Exceptions:} & None.\\
		& \textbf{Transition:} & circleShapeNew allocates and initializes a new CircleShape object using the input paramters. \\
		& \textbf{Output:} & circleShapeNew returns a pointer to the new CircleShape.  \newfunc
		
		\textbf{circleShapeGet:} & \textbf{Input:} & Each circleShapeGet function accepts a Shape pointer as input.\\
		& \textbf{Exceptions:} & Each circleShapeGet function may throw a NotCircleShape exception if the input Shape pointer is not of the CircleShape class. \\ \\ \\ % stylebreak
		& \textbf{Transition:} & None. \\
		& \textbf{Output:} & Each circleShapeGet function returns the value of their corresponding parameter.  \newfunc
		
		\textbf{circleShapeSet:} & \textbf{Input:} & Each circleShapeSet function accepts a Shape pointer and their corresponding parameter as inputs. \\
		& \textbf{Exceptions:} & Each circleShapeSet function may throw a NotCircleShape exception if the input Shape pointer is not of the CircleShape class, or if the Body associated with the Shape violates an invariant in \ref{SecSIBody} after the transitions are complete. \\
		& \textbf{Transition:} & Each circleShapeSet function sets their corresponding parameter with the input value, updates the mass information of the Shape and recalculates the mass of its associated Body. \\
		& \textbf{Output:} & None.  \newfunc
		
		\textbf{momentForCircle:} & \textbf{Input:} & momentForCircle accepts three doubles for mass, inner radius and outer radius, and a Vector as inputs.\\
		& \textbf{Exceptions:} & None.\\
		& \textbf{Transition:} & None. \\
		& \textbf{Output:} & momentForCircle returns the calculated moment from the input parameters as a double.  \newfunc
		
		\textbf{areaForCircle:} & \textbf{Input:} & areaForCircle accepts two double values for the inner radius and outer radius as inputs. \\
		& \textbf{Exceptions:} & None.\\
		& \textbf{Transition:} & None. \\
		& \textbf{Output:} & areaForCircle returns the calculated area from the input parameters as a double.  \newfunc
	\end{longtable*}
	
\subsubsection{Local Constants} \label{SecLCCircle}
CircleShapeClass: ShapeClass \\
CircleShapeClass := \{CIRCLE_SHAPE, circleShapeCacheData, NULL\}

\pagebreak % for pagebreak

\subsubsection{Local Functions} \label{SecLFCircle}
	\renewcommand*{\arraystretch}{\funcPadding}
	\begin{longtable*}{@{} p{3.3cm} l p{\colDescrip}}
		\textbf{circleShapeCache Data:} & \textbf{Input:} & circleShapeCacheData accepts a CircleShape pointer and a Transform matrix as inputs. \\
		& \textbf{Exceptions:} & None.\\
		& \textbf{Transition:} & circleShapeCacheData updates the transformed center of the input CircleShape using the input Transform matrix and generates a new BB with the CircleShape's properties. Default cacheData method of the \hyperref[SecLCCircle]{CircleShapeClass}. \\
		& \textbf{Output:} & circleShapeCacheData returns the new BB as output.  \newfunc
		
		\textbf{circleShapeMass Info:} & \textbf{Input:} & circleShapeMassInfo accepts two double values for mass and radius and a Vector as inputs. \\
		& \textbf{Exceptions:} & None.\\
		& \textbf{Transition:} & None. \\
		& \textbf{Output:} & circleShapeMassInfo is a convenience constructor which returns a new ShapeMassInfo structure for CircleShapes, initialized using the input values.  \newfunc
	\end{longtable*}
	
	
\subsection{Submodule Name: PolyShape} \label{MISPoly}

\subsection{Uses} \label{SecUPoly}
	\Body, \Shape, \Vector, 

\subsection{Syntax}

\subsubsection{Exported Data Types} \label{SecEDTPoly}
%SplittingPlane: struct \\
PolyShape: struct

\subsubsection{Exported Access Programs} \label{SecEAPPoly}
	\renewcommand*{\arraystretch}{1.2}
	\begin{longtable}{| y | x{3.5cm} | y | x{3.5cm} |} 
	\hline \textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions} \\ \hline 
%	polyShapeAlloc & - & PolyShape* & - \\ \hline
%	Raw & PolyShape*, Body*, int, Vector*, double & PolyShape* & - \\ \hline
	polyShapeInit & PolyShape*, Body*, int, Vector*, double, Transform & PolyShape* & - \\ \hline
	boxShapeInit & PolyShape*, Body*, double, double, double & PolyShape* & - \\ \hline
	boxShapeInit2 & PolyShape*, Body*, double, BB & PolyShape* & - \\ \hline
	polyShapeNew & Body*, int, Vector*, double & Shape* & - \\ \hline
	polyShapeNewRaw & Body*, int, Vector*, double, Transform & Shape* & - \\ \hline
	boxShapeNew & Body*, double, double, double & Shape* & - \\ \hline
	boxShapeNew2 & Body*, double, BB & Shape* & - \\ \hline
	polyShapeGetCount & Shape* & int & NotPolyShape \\ \hline
	polyShapeGetVert & Shape*, int & Vector & NotPolyShape \vor IndexOutOfBounds \\ \hline
	polyShapeGetRadius & Shape* & double & NotPolyShape \\ \hline
	polyShapeSetVerts & Shape*, int, Vector*, Transform & - & NotPolyShape \vor IllegalBody \\ \hline
	polyShapeSetVertsRaw & Shape*, int, Vector* & - & NotPolyShape \vor IllegalBody \\ \hline
	polyShapeSetRadius & Shape*, double & - & NotPolyShape \\ \hline
	momentForPoly & double, int, Vector*, Vector, double & double & - \\ \hline
	areaForPoly & int, Vector*, double & double & - \\ \hline
	centroidForPoly & int, Vector* & Vector & - \\ \hline
\end{longtable}

\subsection{Semantics}

\subsubsection{State Variables} \label{SecSVPoly}
%	\textbf{SplittingPlane:}
%	\begin{multicols}{2}
%		\noindent v0: Vector \\
%		n: Vector 
%	\end{multicols}
	\noindent \textbf{PolyShape:}
	\begin{multicols}{2}
		\noindent shape: Shape \\
		radius: \R \\
		count: \Z \\
%		planes: SplittingPlane* \\
%		_planes: array(SplittingPlane)
	\end{multicols}
	

\subsubsection{Assumptions} \label{SecAPoly}
 polyShapeNew/polyShapeNewRaw, or boxShapeNew/boxShapeNew2, have been called before any other access programs. All input pointers are also assumed to be non-null.

\subsubsection{Semantics} \label{SecAPSPoly}
\renewcommand*{\arraystretch}{\funcPadding}
	\begin{longtable*}{@{} p{3.3cm} l p{\colDescrip}} 
%	\textbf{polyShapeAlloc:} & \textbf{Input:} & None. \\
%	& \textbf{Exceptions:} & None.\\
%	& \textbf{Transition:} & None. \\
%	& \textbf{Output:} & polyShapeAlloc heap-allocates a new PolyShape object and returns a pointer to it as output.  \newfunc
%	
	\textbf{polyShapeInit:} & \textbf{Input:} & polyShapeInit accepts a PolyShape pointer, a Body pointer, an integer, a pointer to a Vector array, a double and a Transform matrix as inputs. \\
	& \textbf{Exceptions:} & None.\\
	& \textbf{Transition:} & polyShapeInit transforms each vertex from the input array with the input Transform matrix, places the resultant vertices in a new array, calculates the size of the convex hull containing the new vertices and initializes the input PolyShape using this array, the hull size and the remaining parameters. \\
	& \textbf{Output:} & polyShapeInit returns a pointer to the initialized PolyShape.  \newfunc
	
	\textbf{polyShapeInit Raw:} & \textbf{Input:} & polyShapeInitRaw accepts a PolyShape pointer, a Body pointer, an integer, a pointer to a Vector array and a double as inputs. \\
	& \textbf{Exceptions:} & None.\\
	& \textbf{Transition:} & polyShapeInitRaw initializes the input PolyShape using shapeInit and the input parameters, sets its vertices to the given array and integer (which represents the length of the array), and sets its radius to the input double. \\
	& \textbf{Output:} & polyShapeInitRaw returns a pointer to the initialized PolyShape.  \newfunc
	
	\textbf{boxShapeInit:} & \textbf{Input:} & boxShapeInit accepts a PolyShape pointer, Body pointer and three doubles as inputs. \\
	& \textbf{Exceptions:} & None.\\
	& \textbf{Transition:} & boxShapeInit calculates values for half-width and half-height using the last two input doubles as width and height, respectively. It then initializes the input PolyShape using a new BB generated from the calculated half-dimensions and the remaining parameters. \\
	& \textbf{Output:} & boxShapeInit returns a pointer to the initialized PolyShape.  \newfunc
	
	\textbf{boxShapeInit2:} & \textbf{Input:} & boxShapeInit2 accepts a PolyShape pointer, Body pointer, a double and a BB as inputs. \\
	& \textbf{Exceptions:} & None.\\
	& \textbf{Transition:} & boxShapeInit2 creates a Vector array containing the vertices of the box, determined from the input BB. It then initializes the input PolyShape as a box using the array and number of vertices, as well as the remaining parameters. \\
	& \textbf{Output:} & boxShapeInit2 returns a pointer to the initialized PolyShape.  \newfunc
	
	\textbf{polyShapeNew:} & \textbf{Input:} & Each polyShapeNew function accepts a Body pointer, an integer, a pointer to a Vector array and a double as inputs. In addition, polyShapeNew (not Raw) accepts a Transform matrix as its last input. \\
	& \textbf{Exceptions:} & None.\\
	& \textbf{Transition:} & Each polyShapeNew function allocates and initializes a new PolyShape object using the input parameters. \\
	& \textbf{Output:} & Each polyShapeNew function returns a pointer to the new PolyShape.  \newfunc
	
	\textbf{boxShapeNew:} & \textbf{Input:} & Each boxShapeNew function accepts a Body pointer and a double as inputs. In addition, boxShapeNew accepts two additional doubles, while boxShapeNew2 accepts an additional BB as input. \\
	& \textbf{Exceptions:} & None.\\
	& \textbf{Transition:} & Each boxShapeNew function allocates and initializes a new PolyShape object as a box using the input parameters. \\
	& \textbf{Output:} & Each boxShapeNew function returns a pointer to the new PolyShape.  \newfunc
	
	\textbf{polyShapeGet:} & \textbf{Input:} & Each polyShapeGet function accepts a Shape pointer as input. polyShapeGetVert also accepts an additional integer as input. \\
	& \textbf{Exceptions:} & Each polyShapeGet function may throw a NotPolyShape exception if the input Shape pointer is not of the PolyShape class. polyShapeGetVert may also throw an exception if the input integer is greater than or equal to the number of vertices of the input Shape. \\
	& \textbf{Transition:} & None. \\
	& \textbf{Output:} & Each polyShapeGet function returns the value of their corresponding parameter.  \newfunc
	
	\textbf{polyShapeSet:} & \textbf{Input:} & Each polyShapeSet function accepts a Shape pointer and their corresponding parameter as inputs. Specifically, each polyShapeSetVerts function accepts an integer (for the number of vertices) and a pointer to a Vector array (holding the vertices) as inputs, and polyShapeSetVerts (not Raw) accepts an additional Transform matrix. \\
	& \textbf{Exceptions:} & Each polyShapeSet function may throw a NotPolyShape exception if the input Shape pointer is not of the PolyShape class. Each polyShapeSetVerts function may throw an IllegalBody exception if the Body associated with the Shape violates an invariant in \ref{SecSIBody} after the transitions are complete. \\
	& \textbf{Transition:} & Each polyShapeSet function sets their corresponding parameter with the input value. More specifically, polyShapeVerts transforms the vertices in the input array with the input Transform matrix, places the resultant vertices in a new array, determines the size of the convex hull containing these vertices, and calls polyShapeSetVertsRaw with the new array and hull size. polyShapeVertsRaw frees the current vertices of the input PolyShape, sets its new vertices, updates the mass information of the Shape and recalculates the mass of the associated Body. \\
	& \textbf{Output:} & None.  \newfunc
	
	\textbf{momentForPoly:} & \textbf{Input:} & momentForPoly accepts a double for mass, an integer for number of vertices, a pointer to a Vector array containing these vertices, a Vector for offset, and a double for radius as inputs.\\
	& \textbf{Exceptions:} & None.\\
	& \textbf{Transition:} & None. \\
	& \textbf{Output:} & momentForPoly returns the calculated moment from the input parameters as a double.  \newfunc
	
	\textbf{areaForPoly:} & \textbf{Input:} & areaForPoly accepts an integer for number of vertices, a pointer to a Vector array containing these vertices, and a double for radius as inputs. \\
	& \textbf{Exceptions:} & None.\\
	& \textbf{Transition:} & None. \\
	& \textbf{Output:} & areaForPoly returns the calculated area from the input parameters as a double.  \newfunc
	
	\textbf{centroidForPoly:} & \textbf{Input:} & centroidForPoly accepts an integer for number of vertices and a pointer to a Vector array containing these vertices as inputs. \\
	& \textbf{Exceptions:} & None.\\
	& \textbf{Transition:} & None. \\
	& \textbf{Output:} & centroidForPoly returns the calculated centroid from the input parameters as a Vector.  \newfunc
\end{longtable*}

\subsubsection{Local Constants} \label{SecLCPoly}
PolyShapeClass: ShapeClass \\
PolyShapeClass := \{POLY_SHAPE, polyShapeCacheData, polyShapeDestroy\}

\subsubsection{Local Functions} \label{SecLFPoly}
\renewcommand*{\arraystretch}{\funcPadding}
	\begin{longtable*}{@{} p{2.9cm} l p{\colDescrip}}
	
	\textbf{setVerts:} & \textbf{Input:} & setVerts accepts a PolyShape pointer, an integer, and a pointer to a Vector array as inputs. \\
	& \textbf{Exceptions:} & None.\\
	& \textbf{Transition:} & setVerts sets the input PolyShape's number of vertices to the input integer. If this is less than or equal to \hyperref[SecECShape]{POLY_SHAPE_INLINE_ALLOC}, the PolyShape uses its default _planes array for its vertices. Otherwise, it heap-allocates a new array with the length of the input integer. Finally, the function iterates through the planes array and sets the vertices and their calculated edge normals from the input array. Called by \hyperref[SecAPSPoly]{polyShapeInitRaw and polyShapeSetVertsRaw} to mutate vertices.  \\
	& \textbf{Output:} & None.  \newfunc
	
\end{longtable*}
	
%%%%%%%%%%%%%%%%%%%% SPACE MODULE %%%%%%%%%%%%%%%%%%%%%%%

\section{MIS of the Space Module} \label{MISSpace}

\subsection{Module Name: Space}

\subsection{Uses} \label{SecUSpace}
	\Body, \Shape, \Vector, \Collision

\subsection{Syntax}

\subsubsection{Exported Constants} \label{SecECSpace}
	collisionHandlerDoNothing: CollisionHandler \\
	collisionHandlerDoNothing := \{\hyperref[SecECControl]{WILDCARD_COLLISION_TYPE}, WILDCARD_COLLISION_TYPE, \hyperref[SecLFSpace]{alwaysCollide}, alwaysCollide, \hyperref[SecLFSpace]{doNothing}, doNothing, NULL\} \\
	\newline
	CONTACTS_BUFFER_SIZE: \UZ \\
	CONTACTS_BUFFER_SIZE := (\hyperref[SecECControl]{BUFFER_BYTES} - sizeof(ContactBufferHeader)) / sizeof(Contact)

\subsubsection{Exported Access Programs} \label{SecEAPSpace}
	\renewcommand*{\arraystretch}{1.2}
	\begin{longtable}{| y | x{3.5cm} | y | x{3.5cm} |}
	\hline \textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions} \\ \hline 
%	spaceAlloc & - & Space* & - \\ \hline
	spaceInit & Space* & Space* & - \\ \hline
%	spaceNew & - & Space* & - \\ \hline
%	spaceDestroy & Space* & - & - \\ \hline
%	spaceFree & Space* & - & - \\ \hline
%	spaceGetIterations & Space* & int & - \\ \hline
%	spaceGetGravity & Space* & Vector & - \\ \hline
%	spaceGetCollisionSlop & Space* & double & - \\ \hline
%	spaceGetCollisionBias & Space* & double & - \\ \hline
%	spaceGetCollisionPersistence & Space* & Timestamp & - \\ \hline
%	spaceGetCurrentTimeStep & Space* & double & - \\ \hline
%	spaceGetStaticBody & Space* & Body* & - \\ \hline
%	spaceSetIterations & Space*, int & - & InvalidIter \\ \hline
	spaceSetGravity & Space*, Vector & - & - \\ \hline
%	spaceSetCollisionSlop & Space*, double & - & - \\ \hline
%	spaceSetCollisionBias & Space*, double & - & - \\ \hline
%	spaceSetCollisionPersistence & Space*, Timestamp & - & - \\ \hline
%	spaceSetStaticBody & Space*, Body* & - & AttachedStaticBody \\ \hline
%	spaceIsLocked & Space* & Boolean & - \\ \hline
%	spaceAddDefaultCollisionHandler & Space* & CollisionHandler* & - \\ \hline
	spaceGetBodies & Space* & array* & - \\ \hline
	spaceAddCollisionHandler & Space*, CollisionType, CollisionType & CollisionHandler* & - \\ \hline
%	spaceAddWildcardHandler & Space*, CollisionType & CollisionHandler* & - \\ \hline
%	spaceAddShape & Space*, Shape* & Shape* & DuplicateShape \vor AttachedShape \vor SpaceLocked \\ \hline
	spaceAddBody & Space*, Body* & Body* & - \\ \hline
%	spaceFilterArbiters & Space*, Body*, Shape* & - & - \\ \hline
%	spaceRemoveShape & Space*, Shape* & - & ShapeNotFound \vor SpaceLocked \\ \hline
%	spaceRemoveBody & Space*, Body* & - & MainStaticBody \vor BodyNotFound \vor SpaceLocked \\ \hline
%	spaceContainsShape & Space*, Shape* & Boolean & - \\ \hline
%	spaceContainsBody & Space*, Body* & Boolean & - \\ \hline
%	spaceEachBody & Space*, SpaceBodyIteratorFunc, void* & - & - \\ \hline
%	spaceEachShape & Space*, SpaceShapeIteratorFunc, void* & - & - \\ \hline
%	spaceReindexStatic & Space* & - & SpaceLocked \\ \hline
%	spaceReindexShape & Space*, Shape* & - & SpaceLocked \\ \hline
%	spaceReindexShapesForBody & Space*, Body* & - & SpaceLocked \\ \hline
%	spacePushFreshContactBuffer & Space* & - & - \\ \hline
%	contactBufferGetArray & Space* & Contact & - \\ \hline
	spaceCollideShapes & Shape*, Shape*, CollisionID, Space* & CollisionID & - \\ \hline
%	spaceArbiterSetFilter & Arbiter*, Space* & Boolean & - \\ \hline
%	spaceLock & Space* & - & - \\ \hline
%	spaceUnlock & Space*, Boolean & - & SpaceLockUnderflow \\ \hline
%	spaceArrayForBodyType & Space*, BodyType & Array* & - \\ \hline
%	shapeUpdateFunc & Shape*, void* & - & - \\ \hline
	spaceStep & Space*, double & - & - \\ \hline
\end{longtable}

\subsection{Semantics}

\subsubsection{State Variables} \label{SecSVSpace}
	\textbf{Space:} 
	\begin{multicols}{2}
		\noindent iterations: \Z \\
		gravity: Vector \\
%		collisionSlop: \R \\
%		collisionBias: \R \\
%		collisionPersistence: Timestamp \\
		Bodies: Array* \\
		stamp: Timestamp \\
%		curr_dt: \R \\
%		dynamicBodies: Array* \\
%		staticBodies: Array* \\
%		shapeIDCounter: HashValue \\
%		staticShapes: SpatialIndex* \\
%		dynamicShapes: SpatialIndex* \\
%		arbiters: Array* \\
%		contactBuffersHead: ContactBufferHeader* \\
%		cachedArbiters: HashSet* \\
%		pooledArbiters: Array* \\
%		allocatedBuffers: Array* \\
%		locked: \UZ \\
%		usesWildcards: \B \\
%		collisionHandlers: HashSet* \\
%		defaultHandler: CollisionHandler \\
%		skipPostStep: \B \\
%		postStepCallbacks: Array* \\
%		staticBody: Body* \\
%		_staticBody: Body 
	\end{multicols}
	
	\noindent \textbf{CollisionHandler:}
	\begin{multicols}{3}
		\noindent typeA: CollisionType \\
		typeB: CollisionType \\
		beginFunc: CollisionBeginFunc \\
		preSolveFunc: CollisionPreSolveFunc \\
		postSolveFunc: CollisionPostSolveFunc \\
		separateFunc: CollisionSeparateFunc \\
		userData: DataPointer
	\end{multicols}
	
	\noindent \textbf{ContactBufferHeader:}
	\begin{multicols}{3}
		\noindent stamp: Timestamp \\
		next: ContactBufferHeader* \\
		numContacts: \UZ
	\end{multicols}
	
	\noindent \textbf{ContactBuffer:}
	\begin{multicols}{2}
		\noindent header: ContactBufferHeader \\
		contacts: array(Contact) 
	\end{multicols}
	

%\subsubsection{State Invariant} 

\subsubsection{Assumptions} \label{SecASpace}
 spaceInit is called before any other access programs.

\subsubsection{Semantics}  \label{SecAPSSpace}

\renewcommand*{\arraystretch}{\funcPadding}
	\begin{longtable*}{@{} p{3.0cm} l p{\colDescrip}} 

	\textbf{spaceCollide Shapes:} & \textbf{Input:} & spaceCollideShapes accepts two Shape pointers, a Collision ID and a Space pointer as inputs. \\
	& \textbf{Exceptions:} & None.\\
	& \textbf{Transition:} & spaceCollideShapes tests if the input Shapes can be collided using \hyperref[SecLFSpace]{queryReject}. If it fails, it returns the input ID. Otherwise, it performs collision detection and makes a new CollisionInfo structure. If a collision occurs, the function modifies the number of Contacts for the input Space, updates the Arbiter for the input Shapes, calls the Arbiter's collision handler functions and updates the Arbiter's timestamp. Otherwise, no further transitions are made. In either case, the function returns the ID of the generated CollisionInfo structure. \\
	& \textbf{Output:} & spaceCollideShapes returns a CollisionID as output.  \newfunc
	
	\textbf{spaceStep:} & \textbf{Input:} & spaceStep accepts a Space pointer and a  as inputs. \\
	& \textbf{Exceptions:} & None.\\
	& \textbf{Transition:} & spaceStep updates the input Space following the specified timestep (input double). If the timestep is zero, the function exits immediately. Otherwise, it updates the Space's timestamp and current timestep, resets space lists and locks the Space. While the Space is locked, the function calculates new positions of Bodies in the Space and collides Shapes as necessary.
	 before unlocking the Space without running post-step callbacks. Next, it locks the Space once again, clears cached Arbiters, pre-processes the Arbiters, updates the velocities of Bodies in the Space, applies cached impulses, runs the impulse solver, and then runs post-solve callbacks on the Arbiters. Finally, it unlocks the Space and runs post-step callbacks. \\
	& \textbf{Output:} & None.  \newfunc\\
\end{longtable*}

\subsubsection{Local Functions} \label{SecLFSpace}

\renewcommand*{\arraystretch}{\funcPadding}
	\begin{longtable*}{@{} p{3.0cm} l p{\colDescrip}}
	\iffalse
	% Default equality function for Arbiter HashSets. Used in space initialization.
%	\textbf{arbiterSetEql:} & \textbf{Input:} & arbiterSetEql accepts a pointer to an array of Shape pointers and an Arbiter pointer as inputs.\\
%	& \textbf{Exceptions:} & None.\\
%	& \textbf{Transition:} & None. \\
%	& \textbf{Output:} & arbiterSetEql returns true if the Shapes in the input array are equal to the input Arbiter's Shapes, and false otherwise.  \newfunc
	
	% Default equality function for CollisionHandler HashSets. Used in space initialization.
	\textbf{handlerSetEql:} & \textbf{Input:} & handlerSetEql accepts two CollisionHandler pointers as inputs. \\
	& \textbf{Exceptions:} & None.\\
	& \textbf{Transition:} & None. \\
	& \textbf{Output:} & handlerSetEql returns true if the CollisionTypes of both handlers are equal, and false otherwise.  \newfunc
	
	% Transformation function used to insert CollisionHandlers into a HashSet. Used in functions that add handlers.
	\textbf{handlerSet Trans:} & \textbf{Input:} & handlerSetTrans accepts a CollisionHandler pointer and a void pointer as inputs. \\
	& \textbf{Exceptions:} & None.\\
	& \textbf{Transition:} & handlerSetTrans clones the input CollisionHandler. \\
	& \textbf{Output:} & handlerSetTrans returns a void pointer to the cloned handler.  \newfunc
	\fi
	

	\iffalse
	% An internal helper function that automatically retrieves the velocity functions for Shapes in BBTrees. Used in space initialization.
	\textbf{shapeVelocity Func:} & \textbf{Input:} & shapeVelocityFunc accepts a Shape pointer as input. \\
	& \textbf{Exceptions:} & None.\\
	& \textbf{Transition:} & None. \\
	& \textbf{Output:} & shapeVelocityFunc returns the velocity function of the Body associated to the input Shape.  \newfunc 
	
	% A binary wrapper of the standard unary free function. Used for individually freeing HashSet elements.
	\textbf{freeWrap:} & \textbf{Input:} & freeWrap accepts two void pointers as inputs. \\
	& \textbf{Exceptions:} & None.\\
	& \textbf{Transition:} & freeWrap frees the first input pointer. \\
	& \textbf{Output:} & None.  \newfunc
	\fi
	
	\textbf{spaceUse WildcardDefaultHandler:} & \textbf{Input:} & spaceUseWildcardDefaultHandler accepts a Space pointer as input. \\
	& \textbf{Exceptions:} & None.\\
	& \textbf{Transition:} & The function sets the Space to use wildcards and copies \hyperref[SecLCSpace]{collisionHandlerDefault} to the Space's default handler. Called by \hyperref[SecAPSSpace]{spaceAddDefaultCollisionHandler}. \\
	& \textbf{Output:} & None.  \newfunc
	
	\iffalse
	% HashSet filtering function for Arbiters matching the Body and Shape in the filtering context. Called by spaceFilterArbiters, but commented out because it doesn't really add detail to that function.
	\textbf{cachedArbiters Filter:} & \textbf{Input:} & cachedArbitersFilter accepts an Arbiter pointer and a pointer to an ArbiterFilterContext structure. \\
	& \textbf{Exceptions:} & None.\\
	& \textbf{Transition:} & cachedArbitersFilter is the filtering function used by \hyperref[SecAPSSpace]{spaceFilterArbiters} to remove and recycle cached Arbiters that are associated with the Body and/or Shape defined in the input ArbiterFilterContext structure. \\
	& \textbf{Output:} & cachedArbitersFilter returns true if no Arbiters were removed, and false otherwise.  \newfunc
	
	% Spatial index iterator for Shapes. Called by spaceEachShape, but doesn't add detail to the behavior so commented out.
	\textbf{spaceEachShape Iterator:} & \textbf{Input:} & spaceEachShapeIterator accepts a Shape pointer and a pointer to a SpaceShapeContext structure as inputs. \\
	& \textbf{Exceptions:} & None.\\
	& \textbf{Transition:} & spaceEachShapeIterator calls the function in the input SpaceShapeContext structure with the input Shape and the data pointer defined in the structure. \\
	& \textbf{Output:} & None.  \newfunc
	\fi
	
	\textbf{spaceAlloc ContactBuffer:} & \textbf{Input:} & spaceAllocContactBuffer accepts a Space pointer as input. \\
	& \textbf{Exceptions:} & None.\\
	& \textbf{Transition:} & spaceAllocContactBuffer heap-allocates a new contact buffer and adds it to the input Space's allocated buffers. Called by \hyperref[SecAPSSpace]{spacePushFreshContactBuffer} to allocate a new ContactBufferHeader. \\
	& \textbf{Output:} & spaceAllocContactBuffer returns a pointer to the allocated ContactBuffer as output, cast as a ContactBufferHeader pointer.  \newfunc
	
	\textbf{contactBuffer HeaderInit:} & \textbf{Input:} & contactBufferHeaderInit accepts a ContactBufferHeader pointer, a Timestamp and another ContactBufferHeader pointer as input. \\
	& \textbf{Exceptions:} & None.\\
	& \textbf{Transition:} & contactBufferHeaderInit initializes the first input ContactBufferHeader. It modifies its timestamp to the given Timestamp, its next header to be the next header of the second input ContactBufferHeader  (or to the first input header if the second one is null), and its number of Contacts to zero. Called by \hyperref[SecAPSSpace]{spacePushFreshContactBuffer} to initialize a ContactBufferHeader. \\
	& \textbf{Output:} & contactBufferHeaderInit returns a pointer to the initialized ContactBufferHeader. \newfunc \pagebreak %stylebreak
	

\end{longtable*}

%%%%%%%%%%%%%%%%%%%% VECTOR MODULE %%%%%%%%%%%%%%%%%%%%%%%

\section{MIS of the Vector Module} \label{MISVector}

\subsection{Module Name: Vector}

\subsection{Uses} \label{SecUVector}
	This module only uses standard libraries.

\subsection{Syntax}

\subsubsection{Exported Constants} \label{SecECVector}
	VECT_ERR, zeroVect: Vector \\
	VECT_ERR := \{INT_MAX, INT_MIN\} \\
	zeroVect := \{0.0, 0.0\}\\
	PI:= $\mathbb{R}$\\
	
%\subsubsection{Exported Variables}

%\subsubsection{Exported Data Types} \label{SecEDTVector}
%	Vector: struct 

\subsubsection{Exported Access Programs} \label{SecEAPVector}
%\olu{might not require all access programs below but will adjust on the go}\\
	\renewcommand*{\arraystretch}{1.2}
	\begin{longtable}{| y | x{3.5cm} | y | x{3.5cm} |}
	\hline \textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions} \\ \hline 
	vect & double, double & Vector & - \\ \hline
	vectEqual & Vector, Vector & Boolean & - \\ \hline
	vectAdd & Vector, Vector & Vector & - \\ \hline
	vectSub & Vector, Vector & Vector & - \\ \hline
	vectMult & Vector, double & Vector & - \\ \hline
	vectNeg & Vector & Vector & - \\ \hline
	vectDot & Vector, Vector & double & - \\ \hline
	vectCross & Vector, Vector & double & - \\ \hline
	vectPerp & Vector & Vector & - \\ \hline
	vectRPerp & Vector & Vector & - \\ \hline
	vectProject & Vector, Vector & Vector & - \\ \hline
	vectForAngle & double & Vector & - \\ \hline
	vectToAngle & Vector & double & - \\ \hline
	
\end{longtable}

\subsection{Semantics}

\subsubsection{State Variables} \label{SecSVVector}
\textbf{Vector:} 
\begin{multicols}{2}
	\noindent x: \R \\
	y: \R
\end{multicols}

%\subsubsection{State Invariant} 

%\subsubsection{Assumptions}

\subsubsection{Semantics} \label{SecAPSVector}

\renewcommand*{\arraystretch}{\funcPadding}
	\begin{longtable*}{@{} p{3.3cm} l p{\colDescrip}} 
	\textbf{vect:} & \textbf{Input:} & vect accepts two doubles as input. \\
	& \textbf{Exceptions:} & None.\\
	& \textbf{Transition:} & None. \\
	& \textbf{Output:} & vect returns a new Vector created from the input doubles.  \newfunc
	
	\textbf{vectEqual:} & \textbf{Input:} & vectEqual accepts two Vectors as input. \\
	& \textbf{Exceptions:} & None.\\
	& \textbf{Transition:} & None. \\
	& \textbf{Output:} & vectEqual compares the values of the input Vectors and returns true if they are equal, and false otherwise.  \newfunc
	
	\textbf{vectAdd:} & \textbf{Input:} & vectAdd accepts two Vectors as input. \\
	& \textbf{Exceptions:} & None.\\
	& \textbf{Transition:} & None. \\
	& \textbf{Output:} & vectAdd returns the sum of the input Vectors.  \newfunc
	
	\textbf{vectSub:} & \textbf{Input:} & vectSub accepts two Vectors as input. \\
	& \textbf{Exceptions:} & None.\\
	& \textbf{Transition:} & None. \\
	& \textbf{Output:} & vectSub returns the difference of the input Vectors.  \newfunc
	
	\textbf{vectMult:} & \textbf{Input:} & vectMult accepts a Vector and a double as inputs. \\
	& \textbf{Exceptions:} & None.\\
	& \textbf{Transition:} & None. \\
	& \textbf{Output:} & vectMult returns the scalar multiple of the input Vector with the input double.  \newfunc
	
	\textbf{vectNeg:} & \textbf{Input:} & vectNeg accepts a Vector as input. \\
	& \textbf{Exceptions:} & None.\\
	& \textbf{Transition:} & None. \\
	& \textbf{Output:} & vectNeg returns the negative of the input Vector.  \newfunc
	
	\textbf{vectDot:} & \textbf{Input:} & vectDot accepts two Vectors as inputs. \\
	& \textbf{Exceptions:} & None.\\
	& \textbf{Transition:} & None. \\
	& \textbf{Output:} & vectDot returns the dot product of the input Vectors.  \newfunc
	
	\textbf{vectCross:} & \textbf{Input:} & vectCross accepts two Vectors as inputs. \\
	& \textbf{Exceptions:} & None.\\
	& \textbf{Transition:} & None. \\
	& \textbf{Output:} & vectCross calculates the cross product of the input Vectors and returns the \textit{z}-component of the product as a double.  \newfunc	
	\textbf{vectForAngle:} & \textbf{Input:} & vectForAngle accepts a double as input. \\
	& \textbf{Exceptions:} & None.\\
	& \textbf{Transition:} & None. \\
	& \textbf{Output:} & vectForAngle computes the Vector corresponding to the input angle (double), measured from the \textit{x}-axis, and returns the result.  \newfunc
	
	\textbf{vectToAngle:} & \textbf{Input:} & vectToAngle accepts a Vector as input. \\
	& \textbf{Exceptions:} & None.\\
	& \textbf{Transition:} & None. \\
	& \textbf{Output:} & vectToAngle calculates the angle between the input Vector and the \textit{x}-axis and returns the result as a double.  \newfunc
	
	\textbf{vectRotate:} & \textbf{Input:} & vectRotate accepts two Vectors as inputs. \\
	& \textbf{Exceptions:} & None.\\
	& \textbf{Transition:} & None. \\
	& \textbf{Output:} & vectRotate rotates the first input Vector by the second using complex multiplication returns the resultant Vector as output.  \newfunc
		
	\textbf{vectLength:} & \textbf{Input:} & Each vectLength function accepts a Vector as input. \\
	& \textbf{Exceptions:} & None.\\
	& \textbf{Transition:} & None. \\
	& \textbf{Output:} & vectLength and vectLengthSq calculates the regular and squared length of the input Vector, respectively, and returns the result as a double.  \newfunc
	
\end{longtable*}


%%%%%%%%%%%%%%%%%%%%  COLLISION SOLVER MODULE %%%%%%%%%%%%%%%%%%%%%%%

\section{MIS of the Collision Solver Module} \label{MISCollision}

\subsection{Module Name: Collision}

\subsection{Uses} \label{SecUCollision}
	\Body, \Shape, \Vector \\

\subsection{Syntax}

\subsubsection{Exported Constants} \label{SecECCollision}
%	POINTS_ERR: ClosestPoints \\
%	POINTS_ERR := \{VECT_ERR, VECT_ERR, DBL_MIN, UINT32_MAX\} \\
%	\newline
%	MAX_GJK_ITERATIONS, MAX_EPA_ITERATIONS, WARN_GJK_ITERATIONS, WARN_EPA_ITERATIONS: \Z \\
%	MAX_GJK_ITERATIONS := 30 \\
%	MAX_EPA_ITERATIONS := 30 \\
%	WARN_GJK_ITERATIONS := 20 \\
%	WARN_EPA_ITERATIONS := 20
N/A
%\subsubsection{Exported Variables}

%\subsubsection{Exported Data Types} \label{SecEDTCollision}
%	SupportPoint: struct \\
%	MinkowskiPoint: struct \\
%	SupportContext: struct \\
%	EdgePoint: struct \\
%	Edge: struct \\
%	ClosestPoints: struct \\
%	CollisionFunc : Shape* $\times$ Shape* $\times$ CollisionInfo* $\to$ void \\
%	SupportPointFunc : Shape* $\times$ Vector $\to$ SupportPoint

\subsubsection{Exported Access Programs} \label{SecEAPCollision}
	\renewcommand*{\arraystretch}{1.2}
	\begin{longtable}{| y | x{3.5cm} | y | x{3.5cm} |}
	\hline \textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions} \\ \hline 
	relative_velocity & Body*, Body*, Vector, Vector & Vector & - \\ \hline
	normal_relative_velocity & Body*, Body*, Vector, Vector, Vector & double & - \\ \hline
	apply_impulse & Body*, Vector, Vector & - & - \\ \hline
	apply_impulses & Body*, Body*, Vector, Vector, Vector & - & - \\ \hline
	apply_bias_impulse & Body*, Vector, Vector & - & - \\ \hline
	apply_bias_impulses & Body*, Body*, Vector, Vector, Vector & - & - \\ \hline
	k_scalar_body & Body*, Vector, Vector & double & - \\ \hline
	k_scalar & Body*, Body*, Vector, Vector, Vector & double & UnsolvableCollision \\ \hline
	collide & Shape*, Shape*, CollisionID, Contact* & CollisionInfo & - \\ \hline
	shapesCollide & Shape*, Shape* & ContactPointSet & - \\ \hline
\end{longtable}

\subsection{Semantics}

\subsubsection{State Variables} \label{SecSVCollision}
\textbf{SupportPoint:} 
\begin{multicols}{2}
	\noindent p: Vector \\
	index: CollisionID
\end{multicols}
	
\noindent \textbf{MinkowskiPoint:} 
\begin{multicols}{2}
	\noindent a: Vector \\
	b: Vector \\
	ab: Vector \\
	id: CollisionID
\end{multicols}

\noindent \textbf{SupportContext:} 
\begin{multicols}{2}
	\noindent shape1: Shape* \\
	shape2: Shape* \\
	func1: SupportPointFunc \\
	func2: SupportPointFunc
\end{multicols}

\noindent \textbf{EdgePoint:} 
\begin{multicols}{2}
	\noindent p: Vector \\
	hash: HashValue
\end{multicols}

\noindent \textbf{Edge:} 
\begin{multicols}{2}
	\noindent a: EdgePoint \\
	b: EdgePoint \\
	radius: \R \\
	normal: Vector
\end{multicols}

\pagebreak % stylebreak

\noindent \textbf{ClosestPoints:} 
\begin{multicols}{3}
	\noindent a: Vector \\
	b: Vector \\
	n: Vector \\
	d: \R \\
	id: CollisionID
\end{multicols}

%\subsubsection{State Invariant} 

%\subsubsection{Assumptions}

\subsubsection{Access Program Semantics} \label{SecAPSCollision}

\renewcommand*{\arraystretch}{\funcPadding}
	\begin{longtable*}{@{} p{3.3cm} l p{\colDescrip}} 
	\textbf{relative_velocity:} & \textbf{Input:} & relative_velocity accepts two Body pointers and two Vectors as inputs. \\
	& \textbf{Exceptions:} & None.\\
	& \textbf{Transition:} & None. \\
	& \textbf{Output:} &  relative_velocity calculates the relative velocity of the second input Body relative to the first input Body with the input parameters and returns the result as a Vector. \newfunc
	
	\textbf{normal_relative_velocity:} & \textbf{Input:} & normal_relative_velocity accepts two Body pointers and three Vectors as inputs. \\
	& \textbf{Exceptions:} & None.\\
	& \textbf{Transition:} & None. \\
	& \textbf{Output:} &  normal_relative_velocity calculates the dot product of the relative velocity between the two input Bodies and the normal (third input Vector) and returns the result as a double. \newfunc
	
	\textbf{apply_impulse:} & \textbf{Input:} & apply_impulse accepts a Body pointer and two Vectors as inputs. \\
	& \textbf{Exceptions:} & None.\\
	& \textbf{Transition:} & apply_impulse recalculates the input Body's linear and angular velocity using the impulse (first input Vector) and point of application (second input Vector). \\
	& \textbf{Output:} & None. \newfunc
	
	\textbf{apply_impulses:} & \textbf{Input:} & apply_impulses accepts two Body pointers and three Vectors as inputs. \\
	& \textbf{Exceptions:} & None.\\
	& \textbf{Transition:} & apply_impulses applies the input impulse (third input Vector) to the two input Bodies, in opposite directions, to recalculate their linear and angular velocities, using their points of application (first and second input Vectors). \\
	& \textbf{Output:} & None. \newfunc
	
	\textbf{apply_bias_impulse:} & \textbf{Input:} & apply_bias_impulse accepts a Body pointer and two Vectors as inputs. \\
	& \textbf{Exceptions:} & None.\\
	& \textbf{Transition:} & apply_bias_impulse recalculates the input Body's linear and angular bias velocities using the impulse (first input Vector) and point of application (second input Vector). \\
	& \textbf{Output:} & None. \newfunc \\ % for pagebreak
	
	\textbf{apply_bias_impulses:} & \textbf{Input:} & apply_bias_impulses accepts two Body pointers and three Vectors as inputs. \\
	& \textbf{Exceptions:} & None.\\
	& \textbf{Transition:} & apply_bias_impulses applies the input impulse (third input Vector) to the two input Bodies, in opposite directions, to recalculate their linear and angular bias velocities, using their points of application (first and second input Vectors). \\
	& \textbf{Output:} & None. \newfunc
	
	\textbf{k_scalar_body:} & \textbf{Input:} & k_scalar_body accepts a Body pointer and two Vectors as inputs. \\
	& \textbf{Exceptions:} & None.\\
	& \textbf{Transition:} & None. \\
	& \textbf{Output:} & k_scalar_body first calculates the cross product of the two input Vectors. Then, it computes the product of the inverse momentum of the input Body and the squared cross product of the input Vectors. Finally, it calculates the sum of this quantity and the Body's inverse mass, and returns the final result as a double. \newfunc 
	
	\textbf{k_scalar:} & \textbf{Input:} & k_scalar accepts two Body pointers and three Vectors as inputs. \\
	& \textbf{Exceptions:} & k_scalar may throw an UnsolvableCollision exception if the calculated value is equal to zero. \\
	& \textbf{Transition:} & None. \\
	& \textbf{Output:} &  k_scalar calculates \hyperref[SecAPSCollision]{k_scalar_body} for the first input Body with the first and last input Vector, and for the second input Body with the second and last input Vector. It then calculates the sum of these results and returns the above sum as a double. \newfunc
	
	\textbf{collide:} & \textbf{Input:} & collide accepts two Shape pointers, a CollisionID and a Contact pointer as inputs. \\
	& \textbf{Exceptions:} & None.\\
	& \textbf{Transition:} & collide creates a new CollisionInfo structure with the input parameters and other fields zero-initialized. The function will then reorder the structure's Shape types as necessary, and apply the appropriate collision function from \hyperref[SecLCCollision]{CollisionFuncs} to it.\\
	& \textbf{Output:} & collide returns the new CollisionInfo structure as output. \newfunc
	
	\textbf{shapesCollide:} & \textbf{Input:} & shapesCollide accepts two Shape pointers as inputs. \\
	& \textbf{Exceptions:} & None.\\
	& \textbf{Transition:} & shapesCollide declares a new Contact array and generates a CollisionInfo structure for the input Shapes using the collide function and the Contact array, modifying the array in the process. Next, it declares a new ContactPointSet structure for the collision and sets the number of points and normal accordingly. Finally, the function will iterate through the Contact array to set the points for the ContactPointSet. \\
	& \textbf{Output:} & shapesCollide returns the new ContactPointSet as output. \newfunc
\end{longtable*}

\subsubsection{Local Constants} \label{SecLCCollision}
	BuiltinCollisionFuncs: array(CollisionFunc) \\
	BuiltinCollisionFuncs := \{CircleToCircle, CollisionError, CollisionError, CircleToSegment, SegmentToSegment, CollisionError, CircleToPoly, SegmentToPoly, PolyToPoly\} \\
	CollisionFuncs := BuiltinCollisionFuncs

\subsubsection{Local Functions} \label{SecLFCollision}

\renewcommand*{\arraystretch}{\funcPadding}
	\begin{longtable*}{@{} p{3.3cm} l p{\colDescrip}}
	\iffalse
	% Checks the area and signed area between the points. The original Chipmunk did
	% not mathematically specify the significance of these functions, so I'm actually
	% not 100% sure on that. They are used in EPA and GJK, seemingly to determine the
	% relative distance and positions of points from each other.
	
	\textbf{checkArea:} & \textbf{Input:} & checkArea accepts two Vectors as inputs. \\
	& \textbf{Exceptions:} & None.\\
	& \textbf{Transition:} & None. \\
	& \textbf{Output:} &  checkArea calculates the product of the first Vector's $x$-component with the second's $y$-component, and the product of the first Vector's $y$-component with the second's $x$-component. It returns true if the first result is greater than the second, and false otherwise. Called by \hyperref[SecLFCollision]{GJKRecurse}. \newfunc
	
	\textbf{checkSignedArea:} & \textbf{Input:} & checkSignedArea accepts three Vectors as inputs. \\
	& \textbf{Exceptions:} & None.\\
	& \textbf{Transition:} & None. \\
	& \textbf{Output:} & checkSignedArea calculates the signed area of a triangle using the three input Vectors as its vertices. It returns true if the signed area is positive, and false otherwise. Called by \hyperref[SecLFCollision]{EPARecurse}. \newfunc
	
	\fi
	
	\textbf{collisionInfo PushContact:} & \textbf{Input:} & collisionInfoPushContact accepts a CollisionInfo pointer, two Vectors and a HashValue as inputs. \\
	& \textbf{Exceptions:} & collisionInfoPushContact may throw a CollisionContactOverflow exception when the number of Contacts of the input CollisionInfo exceeds \hyperref[SecECArbiter]{MAX_CONTACTS_PER_ARBITER}. \\
	& \textbf{Transition:} & collisionInfoPushContact pushes a new Contact structure into the input CollisionInfo's Contacts array with the other input parameters and updates its number of Contacts accordingly. Called by the \hyperref[SecLFCollision]{ShapeToShape} collision functions to add new contact points and by \hyperref[SecLFCollision]{closestPoints} in the collision functions for SegmentShapes and PolyShapes. \\
	& \textbf{Output:} & None. \newfunc
	
	\iffalse
	% Used to find the vertex index for a PolyShape's support point.
	\textbf{polySupport PointIndex:} & \textbf{Input:} & polySupportPointIndex accepts an integer, a pointer to a SplittingPlane array and a Vector as inputs. \\
	& \textbf{Exceptions:} & None.\\
	& \textbf{Transition:} & polySupportPointIndex iterates through the input array. For each point in the array, the function calculates the dot product of the point's Vector with the input Vector, and computes the index of the point that maximizes this quantity. Used by \hyperref[SecLFCollision]{polySupportPoint and supportEdgeForPoly}. \\
	& \textbf{Output:} & polySupportPointIndex returns the index as an integer. \newfunc
	
	% Straightforward constructor for SupportPoints.
	\textbf{supportPoint New:} & \textbf{Input:} & supportPointNew accepts a Vector and a CollisionID as inputs. \\
	& \textbf{Exceptions:} & None.\\
	& \textbf{Transition:} & None. \\
	& \textbf{Output:} &  supportPointNew allocates a new SupportPoint structure with the input parameters and returns it as output. \newfunc 
	\fi
	
	\textbf{SupportPoint:} & \textbf{Input:} & Each SupportPoint function accepts a Shape pointer of the Shape type corresponding to the function's prefix and a Vector as inputs. \\
	& \textbf{Exceptions:} & None.\\
	& \textbf{Transition:} & None. \\
	& \textbf{Output:} &  Each SupportPoint creates a new SupportPoint with the input Shape's transformed center (CircleShapes), endpoint (SegmentShape) or vertex (PolyShape), with the appropriate index of the point as its CollisionID. Each corresponding function is used by the appropriate \hyperref[SecLFCollision]{ShapeToShape} function in generating the SupportPointContext to be passed to \hyperref[SecLFCollision]{GJK}. \newfunc
	
	\iffalse
	% Merged into a general shapeSupportPoint function.
	\textbf{circleSupport Point:} & \textbf{Input:} & circleSupportPoint accepts a CircleShape pointer and a Vector as inputs. \\
	& \textbf{Exceptions:} & None.\\
	& \textbf{Transition:} & None. \\
	& \textbf{Output:} &  circleSupportPoint creates a new SupportPoint with the input CircleShape's transformed center and zero as the ID, and returns it as output.\newfunc
	
	\textbf{segmentSupport Point:} & \textbf{Input:} & segmentSupportPoint accepts a SegmentShape pointer and a Vector as inputs. \\
	& \textbf{Exceptions:} & None.\\
	& \textbf{Transition:} & None. \\
	& \textbf{Output:} & segmentSupportPoint calculates the dot product of the input SegmentShape's endpoints with the input Vector. It creates a new SupportPoint with the endpoint that maximizes the product and either zero or one as the ID, depending on the endpoint used, and returns it as output. \newfunc
	
	\textbf{polySupport Point:} & \textbf{Input:} & polySupportPoint accepts a PolyShape pointer and a Vector as input. \\
	& \textbf{Exceptions:} & None.\\
	& \textbf{Transition:} & None. \\
	& \textbf{Output:} & polySupportPoint finds the index of the input PolyShape's support point with polySupportPointIndex and creates a new SupportPoint, using the vertex corresponding to the index and the index itself as the ID, and returns the new SupportPoint as output. \newfunc
	
	% Creates a new MinkowskiPoint containing the Minkowski difference of two SupportPoints.
	\textbf{minkowskiPoint New:} & \textbf{Input:} & minkowskiPointNew accepts two SupportPoints as input.\\
	& \textbf{Exceptions:} & None.\\
	& \textbf{Transition:} & None. \\
	& \textbf{Output:} & minkowskiPointNew allocates a new MinkowskiPoint structure using the input SupportPoints, their difference, and the concatenated index of both SupportPoints (calculated through bitwise operations). The new MinkowskiPoint is then returned as output. \newfunc
	\fi
	
	\textbf{support:} & \textbf{Input:} & support accepts a SupportContext pointer and a Vector as inputs. \\
	& \textbf{Exceptions:} & None.\\
	& \textbf{Transition:} & support calculates the maximal point on the Minkowski difference of two shapes along a particular axis. It generates two SupportPoints using the SupportPointFunc functions and Shapes contained in the input SupportContext and the input Vector, and creates a new MinkowskiPoint with these SupportPoints. Used in the calculations of \hyperref[SecLFCollision]{GJK and EPA}. \\
	& \textbf{Output:} &  support returns the new MinkowskiPoint as output. \newfunc
	
	\textbf{supportEdgeFor:} & \textbf{Input:} & Each supportEdgeFor function accepts a Shape pointer of the corresponding Shape type and a Vector as inputs. \\
	& \textbf{Exceptions:} & None.\\
	& \textbf{Transition:} & Each supportEdgeFor function computes the dot products of the input Shape's vertices (for PolyShapes) or normal (for SegmentShapes) with the input Vector to calculate a support edge for the input Shape, which is an edge of a SegmentShape or PolyShape that is in contact with another Shape. Called by some \hyperref[SecLFCollision]{ShapeToShape} functions to determine contact points for SegmentShapes and PolyShapes.  \\
	& \textbf{Output:} & Each supportEdgeFor function generates a new Edge structure containing information about the calculated support edge and returns it as output. \newfunc
	
	\iffalse
	
	% Merged into supportEdgeFor with a more general description.
	\textbf{supportEdgeFor Poly:} & \textbf{Input:} & supportEdgeForPoly accepts a PolyShape pointer and a Vector as inputs. \\
	& \textbf{Exceptions:} & None.\\
	& \textbf{Transition:} & supportEdgeForPoly finds the vertices adjacent to the input PolyShape's support point and calculates the dot product of the vertices and the input Vector. The function then creates a new Edge with the support point and the vertex that maximized the product. \\
	& \textbf{Output:} & supportEdgeForPoly returns the new Edge as output. \newfunc
	
	\textbf{supportEdgeFor Segment:} & \textbf{Input:} & supportEdgeForSegment accepts a SegmentShape pointer and a Vector as inputs. \\
	& \textbf{Exceptions:} & None.\\
	& \textbf{Transition:} & supportEdgeForSegment calculates the dot product of the input SegmentShape's transformed normal and the input Vector. If the result is positive, the function creates a new Edge using the SegmentShape's endpoints and other properties. Otherwise, it creates a new Edge using the endpoints in reversed order and a negative transformed normal. \\
	& \textbf{Output:} &  supportEdgeForSegment returns the new Edge as output. \newfunc 
	\fi
	
	\textbf{closestT:} & \textbf{Input:} & closestT accepts two Vectors as inputs. \\
	& \textbf{Exceptions:} & None.\\
	& \textbf{Transition:} & closestT finds the closest $\mathbf{p}(t)$ to the origin $(0, 0)$, where $\mathbf{p}(t) = \frac{a(1-t)+b(1+t)}{2}$, $a$ and $b$ are the two input Vectors and $t \in [-1, 1]$. The function clamps the result to this interval. Used for the computation of closest points in \hyperref[SecLFCollision]{closestPointsNew}. \\
	& \textbf{Output:} &  closestT returns a double as output. \newfunc
	
	\textbf{lerpT:} & \textbf{Input:} & lerpT accepts two Vectors and a double as inputs. \\
	& \textbf{Exceptions:} & None.\\
	& \textbf{Transition:} & lerpT functions similarly to \hyperref[SecAPSVector]{vectLerp}, except the parameter $t$, the last input double, is constrained to the interval $[-1, 1]$. Used for the computation of closest points in \hyperref[SecLFCollision]{closestPointsNew}. \\
	& \textbf{Output:} & lerpT returns a Vector as output. \newfunc
	
	\textbf{closestPoints New:} & \textbf{Input:} & closestPointsNew accepts two MinkowskiPoint structures as inputs. \\
	& \textbf{Exceptions:} & None.\\
	& \textbf{Transition:} & closestPointsNew finds the closest edge to the origin (0, 0) on the Minkowski difference of two Shapes, which is obtained by using \hyperref[SecLFCollision]{closestT and lerpT} with the input MinkowskiPoints. This is used to calculate the closest points on the surface of two Shapes, as well as the distance and the minimum separating axis between them. The function then generates a new ClosestPoints structure using the calculated data and the concatenated IDs of the input MinkowskiPoints. Used to compute closest points in \hyperref[SecLFCollision]{EPA and GJK}. \\
	& \textbf{Output:} &  closestPointsNew returns the new ClosestPoints as output.\newfunc
	
	\iffalse
	% Finds the closest distance between two points for EPA.
	\textbf{closestDist:} & \textbf{Input:} & closestDist accepts two Vectors as inputs. \\
	& \textbf{Exceptions:} & None.\\
	& \textbf{Transition:} & closestDist calls closestT with the input Vectors, and uses the result to linearly interpolate the two Vectors with lerpT. The function then calculates the squared length of the resultant Vector. \\
	& \textbf{Output:} & closestDist returns the result as a double. \newfunc
	
	% Decided to merge EPA and EPARecurse.
	\textbf{EPARecurse:} & \textbf{Input:} & EPARecurse accepts a SupportContext pointer, an integer, a pointer to a MinkowskiPoint array and another integer as inputs. \\
	& \textbf{Exceptions:} & EPARecurse may throw a SameVertices exception when the EPA vertices are the same. It may also raise HighIterWarning when the iteration number (last input integer) is greater than or equal to the \hyperref[SecECCollision]{WARN_EPA_ITERATIONS} threshold. \\
	& \textbf{Transition:} & EPARecurse is a recursive implementation of the EPA (Expanding Polytope Algorithm), where each recursion adds a point to the convex hull until the function obtains the closest point on the surface. 
	%\green{TODO: Elaborate more on the algorithm.} 
	\\
	& \textbf{Output:} & EPARecurse returns the new ClosestPoints structure as output. \newfunc
	\fi
	
	\iffalse
	% Decided to merge GJK and GJKRecurse together.
	\textbf{GJKRecurse:} & \textbf{Input:} & GJKRecurse accepts a SupportContext pointer, two MinkowskiPoint structures and an integer as inputs.\\
	& \textbf{Exceptions:} & GJKRecurse may raise a HighIterWarning when the iteration number (last input integer) is greater than or equal to the \hyperref[SecECCollision]{WARN_GJK_ITERATIONS} threshold, or \hyperref[SecECCollision]{WARN_EPA_ITERATIONS} when EPARecurse needs to be called. \\
	& \textbf{Transition:} & GJKRecurse is a recursive implementation of the GJK (Gilbert-Johnson-Keerthi) algorithm. If the collision Shapes are found to overlap, the function will execute EPA to find the closest points.
	%\green{TODO: Elaborate more on the algorithm?}. 
	\\
	& \textbf{Output:} & GJKRecurse returns the new ClosestPoints structure as output. \newfunc
	
	 Convenience constructor that calls the appropriate support point-generating function for the input Shape.
	\textbf{shapePoint:} & \textbf{Input:} & shapePoint accepts a Shape pointer and an integer as inputs. \\
	& \textbf{Exceptions:} & None.\\
	& \textbf{Transition:} & shapePoint creates a new SupportPoint depending on the type of the input Shape and index (the input integer). \\
	& \textbf{Output:} & shapePoint returns the new SupportPoint as output. \newfunc
	\fi
	
	
	\textbf{contactPoints:} & \textbf{Input:} & contactPoints accepts two Edge structures, a ClosestPoints structure and a CollisionInfo pointer as inputs. \\
	& \textbf{Exceptions:} & None.\\
	& \textbf{Transition:} & contactPoints finds contact point pairs on the surfaces of the input support Edges and pushes a new Contact structure into the input CollisionInfo's Contacts array. This is used in \hyperref[SecLFCollision]{ShapeToShape} functions involving SegmentShapes and PolyShapes (except for CircleToPoly). \\
	& \textbf{Output:} & None. \newfunc
	
	\textbf{ShapeToShape:} & \textbf{Input:} & Each ShapeToShape function 
	accept two pointers to the corresponding Shape types and a CollisionInfo pointer as inputs. \\
	& \textbf{Exceptions:} & None.\\
	& \textbf{Transition:} & Each ShapeToShape function calls \hyperref[SecLFCollision]{GJK} to find the ClosestPoints for the two input Shapes and uses it to check if the current distance between the two Shapes is less than the minimum collision distance (usually determined by the sum of the Shapes' radii). If so, the function pushes a new Contact structure containing information about the Shapes' contact points into the Contacts array of the input CollisionInfo. These functions are stored in the exported \hyperref[SecLCCollision]{CollisionFuncs} array, and the appropriate function will be called by \hyperref[SecAPSCollision]{collide}. \\
	& \textbf{Output:} & None. \newfunc
	
	\iffalse
	% These are the specific shape-to-shape collision functions. They are originally
	% documented in the MIS, but I've decided to abstract them into a general
	% 'ShapeToShape' function instead.
	
	\textbf{CircleToCircle:} & \textbf{Input:} & CircleToCircle accepts two CircleShape pointers and a CollisionInfo pointer as inputs. \\
	& \textbf{Exceptions:} & None.\\
	& \textbf{Transition:} & CircleToCircle checks if the current distance between the input CircleShapes is less than the minimum collision distance, which is the sum of the Shapes' radii. If so, the function pushes a new Contact structure to the Contacts array of the input CollisionInfo. \\
	& \textbf{Output:} & None. \newfunc
	

	

	
	\textbf{PolyToPoly:} & \textbf{Input:} & PolyToPoly accepts two PolyShape pointers and a CollisionInfo pointer as inputs. \\
	& \textbf{Exceptions:} & None.\\
	& \textbf{Transition:} & PolyToPoly creates a new SupportContext structure with the input PolyShapes and the polySupportPoint function. It then generates a ClosestPoints structure with GJK, using pointers to the context structure and the ID of the input CollisionInfo. Afterwards, it will check if the closest points are nearer than the minimum collision distance, which is the sum of the Shapes' radii, and if so, push a new Contact structure to the Contacts array of the input CollisionInfo. \\
	& \textbf{Output:} & None. \newfunc
	
	\textbf{CircleToPoly:} & \textbf{Input:} & CircleToPoly accepts a CircleShape pointer, a PolyShape pointer and a CollisionInfo pointer as inputs. \\
	& \textbf{Exceptions:} & None.\\
	& \textbf{Transition:} & CircleToPoly creates a new SupportContext structure with the input Shapes and their corresponding SupportPointFuncs. It then generates a ClosestPoints structure with GJK, using pointers to the context structure and the ID of the input CollisionInfo. Afterwards, it will check if the closest points are nearer than the minimum collision distance, which is the sum of the Shapes' radii, and if so, push a new Contact structure to the Contacts array of the input CollisionInfo. \\
	& \textbf{Output:} & None. \newfunc 
	\fi
	
	\textbf{CollisionError:} & \textbf{Input:} & CollisionError accepts two Shape pointers and a CollisionInfo pointer as inputs. \\
	& \textbf{Exceptions:} & CollisionError throws an eponymous exception when the types of the input Shapes are not in sorted order. \\
	& \textbf{Transition:} & CollisionError throws an exception and aborts the program. This function is stored in the exported \hyperref[SecLCCollision]{CollisionFuncs} array and called by \hyperref[SecAPSCollision]{collide} when the colliding Shape types are not in order. \\
	& \textbf{Output:} & None. \newfunc
\end{longtable*}

\wss{Please remove the commented out portions.  They are distracting.  Nothing
  will be lost, since it is all in version control.  Moreover, I don't think we
  want to continue along the path of the previous documentation.  It was too
  tied to the implementation.}

\wss{As mentioned above, we need a simpler design.  One that is tied to the SRS,
  not the the existing code.  The ``easy'' way of modifying the previous
  documentation was likely a mistake.  It would be better if you thought about
  the problem following the design examples from class.}

\wss{You won't have time for completely redoing this document, but please
  indicate how you would change it in the revised documentation.}

\olu{This is actually the harder way to go i.e modifying previous documentation, I had to read through over a hundred pages, I thought the ideas here would be helpful in the design. Its not as easy to document the design of this library in the short amount of time during the term but I am working on revamping the entire documentation which might not be ready soon.} 


%\textbf{:} & \textbf{Input:} & \\
%& \textbf{Exceptions:} & \\
%& \textbf{Transition:} & \\
%& \textbf{Output:} &  \newfunc

%may throw an IllegalBody exception if the Body violates any invariant in Section %\ref{SecSIBody} after the transition is complete. 

\end{document}