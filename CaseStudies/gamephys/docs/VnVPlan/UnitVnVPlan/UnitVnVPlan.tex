\documentclass[12pt, titlepage]{article}

\usepackage{booktabs}
\usepackage{tabularx}
\usepackage{hyperref}
\hypersetup{
    colorlinks,
    citecolor=black,
    filecolor=black,
    linkcolor=red,
    urlcolor=blue
}
\usepackage[round]{natbib}

\newcommand{\progname}{Tamias2D}

\input{../../Comments}

\begin{document}

\title{Tamias2D: Unit Verification and Validation Plan for a 2D Rigid Body Game Physics Library} 
\author{Oluwaseun Owojaiye}
\date{\today}
	
\maketitle

\pagenumbering{roman}

\section{Revision History}

\begin{tabularx}{\textwidth}{p{3cm}p{2cm}X}
\toprule {\bf Date} & {\bf Version} & {\bf Notes}\\
\midrule
Nov. 29, 2018 & 1.0 & Initial Draft\\
Dec. 1, 2018 & 1.1 & Updates from github feedback\\
\bottomrule
\end{tabularx}

~\newpage

\section{Symbols, Abbreviations and Acronyms}
See MIS documentation at \url{https://github.com/smiths/caseStudies/blob/gamephy_MIS/CaseStudies/gamephys/docs/Design/MIS/GamePhysicsMIS.pdf} \\
\renewcommand{\arraystretch}{1.2}
\begin{tabular}{l l} 
  \toprule		
  \textbf{symbol} & \textbf{description}\\
  \midrule 
  T & Test\\
  \bottomrule
\end{tabular}\\

%\wss{symbols, abbreviations or acronyms -- you can reference the SRS tables if needed}

\newpage

\tableofcontents

\listoftables

\listoffigures

\newpage

\pagenumbering{arabic}

This document describes the unit verification and validation (V\&V) plan for \progname, a 2D Rigid Body Game Physics Library. The purpose of this document is to specify the details of testing each unit of software by providing test cases based on the modules in the library's Module Interface Specification (MIS) document. The MIS, with all other documentation relating to \progname{}, can be found at: \url{https://github.com/smiths/caseStudies/tree/master/CaseStudies/gamephys}.

%This document ... \wss{provide an introductory blurb and roadmap of the unit V\&V plan}

\section{General Information}
\subsection{Purpose}

This section describes the summary of what is being tested, the objectives of this document and references for this document. \progname{} is a 2D rigid body game physics library which can be used to simulate the interaction between rigid bodies in video games. This software is able to simulate movement, rotation, collision and collision response of rigid bodies.

\subsection{Scope}

All modules of \progname{} include Body, Vector, Space, Shape and Collision Solver will be verified using the test cases listed in this document. Please see the Module Guide at \url{https://github.com/smiths/caseStudies/tree/gamephy_MG/CaseStudies/gamephys/docs/Design/MG} for a description of each module.
\wss{You could specifically list the names of the modules that will be tested. \olu{updated}
  A reference to your MG would be good here.}

\section{Plan}
	
\subsection{Verification and Validation Team}

Member(s) of the verification and validation team will include myself, Olu.

\subsection{Automated Testing and Verification Tools}

PyTest framework will be used for automated unit testing. A script with all the testcases covering all \progname{} modules will be created by me.

\subsection{Non-Testing Based Verification}

Not applicable for \progname

%\wss{List any approaches like code inspection, code walkthrough, symbolic
%  execution etc.  Enter not applicable if that is the case.}

\section{Unit Test Description}

The test cases discussed in this section are based on the Module Interface
Specification(MIS) which can be found at
\url{https://github.com/smiths/caseStudies/blob/gamephy_MIS/CaseStudies/gamephys/docs/Design/MIS/GamePhysicsMIS.pdf}. Each
test case listed covers for all applicable functions that need to be tested in
each module to ensure that \progname{} functions as intended based on the
requirements of the software.
	
\subsection{Tests for Functional Requirements}

\subsubsection{Body Module}
		
\paragraph{}
Body module is responsible for storing the physical properties of an object such
as mass, position, rotation properties, velocity etc.\ and provides operations on rigid bodies such as setting the mass, moment, applying force
etc.\ \wss{Please write etc.\, not e.t.c.}\olu{updated}

\begin{enumerate}
	

\item{UTC1} {: test\_body\_apply\_force1 \\}

Type: Automatic.
Initial State: 

Input: \\
shp = Box(Vec2(0, 0), Vec2(100, 100))\\
mass = 1000\\
body = Body(Vec2(0, 0), mass, 100, shp)\\
force = Vec2(1000,0)\\
body.update(1/60)\\
expectedAccel = force/mass\\

Output: body.accel == expectedAccel\\	
How test will be performed: PyTest\\ 
Ref. source: \url{https://onlinemschool.com/math/assistance/vector/calc/}
					
\item{UTC2}{: test\_body\_apply\_torque\\}

Type: Automatic

Initial State: 

Input: \\
shp = Box(Vec2(0, 0), Vec2(100, 100))\\
inertia = 1000\\
body = Body(Vec2(0, 0), 100, inertia, shp)\\
torque = 1000\\
body.update(1/60)\\
expectedAngularAccel = torque/inertia\\

Output: body.angularAccel == expectedAngularAccel
Ref. source: \url{https://onlinemschool.com/math/assistance/vector/calc/}

%\item{UTC3}{: Validate apply\_force3\\}
%
%Type: Automatic
%
%Initial State: Vec2(-2.0, -1.0)
%
%Input: b.apply\_force (Vec2(-5.0, -8.0))
%
%Output: New total force is Vec2(-7.0, -9.0)
%					
%How test will be performed: PyTest\\
%Ref. source: \url{https://onlinemschool.com/math/assistance/vector/calc/}
%
%\item{UTC4}{: Validate apply\_torque\\}
%
%Type: Automatic
%
%Initial State: 0.0
%
%Input: apply\_torque(100.0)
%
%Output: self.torque=100.0
%
%How test will be performed: PyTest

\item{UTC5}{: test\_space\_set\_gravity(space)\\}
Type: Automatic
Initial State: 
Input: \\
shp = Box(Vec2(0,0), Vec2(100,100))\\
body = Body(Vec2(0, 0), 100, 100, shp)\\
space = Space()\\
gravity = Vec2(0,9800)\\
time = 2\\
Output: body.accel == expectedAccel\\
How test will be performed: PyTest\\

\item{UTC6}{: Validate - Initialize dynamic body\\}
This testcase is to initialize a body object.
A body object is initialized with these parameters:\\ 
body = Body( position\_, mass\_, inertia\_, shape\_, angle=0, bodyType\_= DYNAMIC, restitution\_ = 0) to create and initialize a body.\\

Initial State: 

Input: space.add\_body(body)\\
body = Body(Vec2(250,0), 1000, 100, shape, 0, Body.DYNAMIC,1)\\

Output: body = Body(Vec2(250,0), 1000, 100, shape, 0, Body.DYNAMIC,1), 1 body created

How test will be performed: PyTest\\ is initialized with these parameters:\\ 
body = Body( position\_, mass\_, inertia\_, shape\_, angle=0, bodyType\_= DYNAMIC, restitution\_ = 0) to create and initialize a body.\\

Initial State: 

Input: space.add\_body(body)\\
body = Body(Vec2(250,0), 1000, 100, shape, 0, Body.DYNAMIC,1)\\

Output: body = Body(Vec2(250,0), 1000, 100, shape, 0, Body.DYNAMIC,1), 1 body created

How test will be performed: PyTest\\

\item{UTC7}{: Validate - Initialize static body\\}
This testcase is to initialize a body object.
A body object is initialized with these parameters:\\ 
body = Body( position\_, mass\_, inertia\_, shape\_, angle=0, bodyType\_= STATIC, restitution\_ = 0) to create and initialize a body.\\

Initial State: 

Input: space.add\_body(body)\\
body = Body(Vec2(250,0), 1000, 100, polyShape, 0, Body.STATIC,1)\\

Output: body = Body(Vec2(250,0), 1000, 100, polyShape, 0, Body.STATIC,1); 1 body created

How test will be performed: PyTest\\

\item{UTC8}{: Validate - Initialize multiple bodies\\}
This testcase is to initialize multiple body objects.
A body object is initialized with these parameters:\\ 
body = Body( position\_, mass\_, inertia\_, shape\_, angle=0, bodyType\_= DYNAMIC, restitution\_ = 0) to create and initialize a body.\\

Initial State: 

Input: space.add\_body(body)\\
body = Body(Vec2(250,0), 1000, 100, polyShape, 0, Body.DYNAMIC,1)\\
body = Body(Vec2(200,0), 1000, 100, polyShape, 0, Body.DYNAMIC,1)\\

Output: body = Body(Vec2(250,0), 1000, 100, polyShape, 0, Body.DYNAMIC,1)\\
        body = Body(Vec2(200,0), 1000, 100, polyShape, 0, Body.DYNAMIC,1)\\
        2 bodies created

How test will be performed: PyTest\\

\item{UTC9}{: Validate - Update Body\\}
This testcase is to update body object(s), after a cycle/tick.

Initial State: \[p_{initial} = (20,20), v_{initial} = (0, 0)\]
            
Input: apply\_force(20, 20)\\
Output: The table below displays the position and time of a rigid body when a force is applied. The result shows the output velocity and position from 0.5secs to 3secs.
\begin{table} [h!]
	
	\centering
	
	\begin{tabular}{|c|c|c|c}
		
		\hline	
		
	\textbf{Position} &\textbf{Velocity} & \textbf{after time t(secs)}\\
	\hline 

	\hline(20.025, 20.025)& (0.05, 0.05)& 0.5sec \\ \hline
		
    (20.175, 20.172)& (0.15, 0.15)& 1secs \\ \hline
		
	(20.625, 20.613)& (0.15, 0.15)& 1.5secs \\ \hline
		
    (21.625, 20.592)& (0.5, 0.5)& 2.0secs \\ \hline
		
	(23.500, 23.430)& (0.75, 0.74)& 2.5secs \\ \hline
	
	(26.650, 26.520)& (1.05, 1.03)& 3.0secs \\ \hline
		
	\end{tabular}
	
	
\end{table}
How test will be performed: PyTest\\

Ref. source: \url{https://calculator.tutorvista.com/physics/535/velocity-calculator.html}


\end{enumerate}

\subsubsection{Vector Module}

\paragraph{}
Vector module provides operations such as addition, scalar and vector multiplication, dot and cross products e.t.c.
\begin{enumerate}
	
\item{UTC10}{: test\_vec2\_add - (vector addition) \\}
	
	Type: Automatic.
	
	Initial State: 
	
	Input: Vec2(2.22,5.17) + Vec2(1.00,1.00)
	
	Output: Vec2(3.22, 6.17)
	
	How test will be performed: PyTest \\
	Ref. source: \url{https://onlinemschool.com/math/assistance/vector/calc/}
	
    \item{UTC11}{: test\_vec2\_sub1 - (vector subtraction)\\}
	
	Type: Automatic
	
	Initial State: 
	
	Input: Vec2(1.0 , 2.0 ) - Vec2(2.0 ,4.0)
	
	Output: Vec2(-1.0, -2.0)\\
	How will test be performed: PyTest\\
	Ref. source: \url{https://onlinemschool.com/math/assistance/vector/calc/}
	
    \item{UTC12}{: test\_vec2\_sub2 - (vector subtraction)\\}
	
	Type: Automatic
	
	Initial State: 
	
	Input: Vec2(-20.0,5.0) - Vec2(1.0,-10.0)
	
	Output: Vec2(-21.0, 15.0)\\
	How will test be performed: PyTest\\
	Ref. source: \url{https://onlinemschool.com/math/assistance/vector/calc/}
	
	\item{UTC13}{: test\_vec2\_mult} - (scalar multiplication)\\
	
	Type: Automatic
	
	Initial State: 
	
	Input: Vec(2.0, 4.0) * 2.0
	
	Output: Vec2(4.0, 8.0)
	
	How test will be performed: PyTest
	Ref. source: \url{https://onlinemschool.com/math/assistance/vector/multiply3/}
	
	\item{UTC14}{: test\_vec2\_mult2 - (scalar multiplication2)\\}
	
	Type: Automatic
	
	Initial State: 
	
	Input:  Vec(-2.0, -4.0) * 2.0
	
	Output:  Vec2(-4.0, -8.0)
	
	How test will be performed: PyTest
	Ref. source:\url{https://onlinemschool.com/math/assistance/vector/multiply3/}
	
	\item{UTC15}{: test\_vec2\_div\\}
	
	Type: Automatic
	
	Initial State: 
	
	Input: apply force Vec(22.24, 4.34) / 2.0
	
	Output: New total force is Vec2(11.12, 2.17)
	
	How test will be performed: PyTest
	
	\item{UTC16}{: test\_vec2\_div2\\}
	
	Type: Automatic
	
	Initial State: 
	
	Input: Vec(22.24, 4.34) / 2.0
	
	Output: Vec2(11.12, 2.17)
	
	How test will be performed: PyTest
	
	\item{UTC17}{: test\_vec2\_mag1 - (vector magnitude)\\}
	
	Type: Automatic
	
	Initial State: 
	
	Input: Velocity = Vec(0.0, 4.0)
	
	Output: magnitude = V.mag() = 2.0
	
	How test will be performed: PyTest\\
	Ref: \url{https://onlinemschool.com/math/assistance/vector/length/}
	
	\item{UTC18}{: test\_vec2\_mag2 - (vector magnitude)\\}
	
	Type: Automatic
	
	Initial State: 
	
	Input: Velocity = Vec(-2.0, -4.0)
	
	Output: magnitude = V.mag() = 4.47
	
	How test will be performed: PyTest\\
	Ref: \url{https://onlinemschool.com/math/assistance/vector/length/}
	\item{UTC19}{: test\_vec2\_dot1 - (vector dot product)\\}
	
	Type: Automatic
	
	Initial State: 
	
	Input: Vec2.dot(Vec2(1.0, 2.0), Vec2(2.0, 1.0))
	
	Output: magnitude = 4.0
	
	How test will be performed: PyTest\\
	Ref. source: \url{https://onlinemschool.com/math/assistance/vector/multiply/}
	
	
\end{enumerate}

\subsubsection{Shape Module}

\paragraph{}
Shape module is responsible for storing the surface properties of an object such as restitution and provides operations on shapes, such as setting the coefficient of restitution. e.t.c.
\begin{enumerate}
	
	
	\item{UTC20} {: Validate set\_angle \\}
	
	Type: Automatic.
	
	Initial State: 
	
	Input: shape.set\_angle(45)
	
	Output: self.angle = 45
	
	How test will be performed: PyTest 
	
	\item{UTC21}{: Validate set\_position\\}
	
	Type: Automatic
	
	Initial State: 
	
	Input: shape.set\_pos(Vec2(2,2))
	
	Output: Vec2(2,2)
	
	\item{UTC22}{: Validate get\_vertices\\}
	
	Type: Automatic
	
	Initial State: 
	
	Input: shape.get\_verts(Box(Vec2(0,0), Vec2(100,100), 0)) 
	
	Output: 4
	
	How test will be performed: PyTest
	

\end{enumerate}
\subsubsection{Space Module}

\paragraph{}
The space module is responsible for all the rigid bodies and shape interaction. It is the container for simulation.
\begin{enumerate}
	
	
	\item{UTC23} {: Validate set\_gravity \\}
	
	Type: Automatic.
	
	Initial State: 
	
	Input: space.set\_gravity(Vec2(0, 9.8))
	
	Output: (Vec2(0, 9.8)
	
	How test will be performed: PyTest 
	
	\item{UTC24}{: Validate add\_body\\}
	
	Type: Automatic
	
	Initial State: 
	
	Input: space.add\_body(b)
	
	Output: len(self.bodies) = 1
	

	\end{enumerate}

\subsubsection{Collision Solver Module}

\paragraph{}
This module is responsible for shape to shape collision detection, response and resolution.The new velocity,positions and orientation of bodies will be calculated and updated.
\begin{enumerate}
	
	
	\item{UTC25} {: Validate \_is\_intersecting\_with\_True \\}
This testcase checks for collision i.e. if points on rigid bodies are intersecting.\\	
	Type: Automatic.
	
	Initial State: 
	
	Input: \\
	shape1 = Box(Vec2(0,0), Vec2(100,100), 0)\\
	body1 = Body(Vec2(250,0), 1000, 100, shape1, 0, Body.DYNAMIC,0)\\
	
	shape2 = Box(Vec2(0,0), Vec2(100,200), 0)\\
	body2 = Body(Vec2(300,50), 1000, 100, shape2, 0, Body.DYNAMIC,0)\\
	
	Output: (body1, body2) -collision between body1 and body2
	
	How test will be performed: PyTest 
	
	\item{UTC26} {: Validate \_is\_intersecting\_with\_False \\}
	This testcase checks for collision i.e if points on rigid bodies are intersecting.\\	
	Type: Automatic.
	
	Initial State: 
	
	Input: \\
	shape1 = Box(Vec2(0,0), Vec2(100,100), 0)\\
	body1 =  Body(Vec2(250,0), 1000, 100, shape1, 0, Body.DYNAMIC,0)\\
	
	shape2 = Box(Vec2(10,0), Vec2(300,200), 0)\\
	body2 = Body(Vec2(300,50), 1000, 100, shape2, 0, Body.DYNAMIC,0)\\
	
	Output: () -(no collision)
	
	How test will be performed: PyTest 
	
	
\wss{Your test cases are definitely an improvement over the first draft.  I like
the test cases.  There seems like there could be more test cases for the
interesting access programs of update and collision detection.}	

\item{UTC27} {: Validate \_is\_intersecting\_with\_multiplebodies \\}
This testcase checks for collision i.e if points on rigid bodies are intersecting.\\	
Type: Automatic.

Initial State: 

Input: \\
shape1 = Box(Vec2(0,0), Vec2(100,100), 0)\\
body1 = Body(Vec2(250,0), 1000, 100, shape1, 0, Body.DYNAMIC,0)\\

shape2 = Box(Vec2(0,0), Vec2(100,200), 0)\\
body2 = Body(Vec2(300,50), 1000, 100, shape2, 0, Body.DYNAMIC,0)\\

shape3 = Box(Vec2(-10, -10), Vec2(0,0), 0)\\
body3 = Body(Vec2(250,0), 1000, 100, shape1, 0, Body.DYNAMIC,0)\\

shape4 = Box(Vec2(0,0), Vec2(100,200), 0)\\
body4 = Body(Vec2(300,50), 1000, 100, shape2, 0, Body.DYNAMIC,0)\\

Output:\\ (body1, body2) -collision between body1 and body2\\
		(body2, body4) -collision between body2 and body4\\
		(body2, body3) -collision between body2 and body3\\
How test will be performed: PyTest 
	
\end{enumerate}

\subsection{Tests for Nonfunctional Requirements}

Non-Functional testing will not be required for unit testing. This will be covered in section 5.2 of the System Verification and Validation document located at: 

\url{https://github.com/smiths/caseStudies/blob/gamephy_SysVnVPlan/CaseStudies/gamephys/docs/VnVPlan/SystVnVPlan/SystVnVPlan.pdf.pdf}

\subsection{Traceability Between Test Cases and Requirements}

The table below shows the traceability map between test cases and 

modules.

\begin{table} [h!]
	
	\centering
	
	\begin{tabular}{|c|c|}
		
		\hline	
		
		\textbf{Test Case ID} & \textbf{Module}\\
		
		\hline 
		
	
		UTC1-UTC2, UTC5-UTC9& Body Module\\ \hline
		
		UTC10 - UTC19& Vector  Module\\ \hline
		
		UTC20 - UTC22&  Shape Module\\ \hline
		
		UTC23 - UTC24& Space\\ \hline
		
		UTC25 - UTC27& Collision Solver\\ \hline
		
	\end{tabular}
	
	\caption{Traceability Between Test Cases and Modules}
	
	\label{Table:Traceability} 
	
\end{table}
~\newline

~\newpage

\bibliographystyle{plainnat}

\bibliography {../../../refs/References}
~\newline
\section{Appendix}
This section provides additional content related to this document.

\subsection{Symbolic Parameters}
There are no symbolic parameters used in this document.

\end{document}
