\documentclass[12pt, titlepage]{article}

\usepackage{amsmath, mathtools}

\usepackage[round]{natbib}
\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage{graphicx}
\usepackage{colortbl}
\usepackage{xr}
\usepackage{hyperref}
\usepackage{longtable}
\usepackage{xfrac}
\usepackage{tabularx}
\usepackage{float}
\usepackage{siunitx}
\usepackage{booktabs}
\usepackage{multirow}
\usepackage[section]{placeins}
\usepackage{caption}
\usepackage{fullpage}

\hypersetup{
	bookmarks=true,     % show bookmarks bar?
	colorlinks=true,       % false: boxed links; true: colored links
	linkcolor=red,          % color of internal links (change box color with 
	%linkbordercolor)
	citecolor=blue,      % color of links to bibliography
	filecolor=magenta,  % color of file links
	urlcolor=cyan          % color of external links
}

\usepackage{array}

\newcounter{tablenum} %Table number
\newcommand{\tablethetablenum}{Table\thetablenum}
\newcommand{\tableref}[1]{Table\ref{#1}}
\newcounter{modulenum} %Module number
\newcommand{\modulethemodulenum}{Module\themodulenum}
\newcommand{\moduleref}[1]{Module\ref{#1}}
\newcounter{algnum} %Algorithm number
\newcommand{\algthealgnum}{NA\thealgnum}
\newcommand{\algref}[1]{NA\ref{#1}}

%\newcommand{\forceindent}{\parindent=1em\indent\parindent=0pt\relax}

%\oddsidemargin -1000mm
%\evensidemargin -1000mm
%\textwidth 160mm
%\textheight 300mm
%\newgeometry{margin=2cm}

\externaldocument[MG-]{../MG/MG}
\externaldocument[SRS-]{../../SRS/SRS}

\input{../../Comments}

\newcommand{\progname}{SSP}

\begin{document}

\title{Module Interface Specification for Slope Stability Analysis Program 
(\progname)} 
\author{Henry Frankis and Brooks MacLachlan}
\date{\today}
	
\maketitle

\pagenumbering{roman}

\section{Revision History}

\begin{tabularx}{\textwidth}{p{3cm}p{2cm}X}
	\toprule {\bf Date} & {\bf Version} & {\bf Notes}\\
	\midrule
	11/12/18 & 1.0 & Initial updates based on template\\
	\bottomrule
\end{tabularx}

~\newpage

\section{Symbols, Abbreviations and Acronyms}

See Section~\ref{SRS-sec_RefMat} of the SRS Documentation, available in
\href{https://github.com/smiths/caseStudies/blob/master/CaseStudies/ssp/docs/SRS/SRS.pdf}
{the GitHub repository for the project}.

\newpage

\tableofcontents

\newpage

\pagenumbering{arabic}

\section{Introduction}

The following document details the Module Interface Specifications for
\progname, a program for determining the critical slip surface and 
corresponding factor of safety for a given sloped mass of soil. The document is 
intended to ease understanding of the design of \progname{} and should be used 
as a resource for any maintenance of \progname{}.

Complementary documents include the System Requirement Specifications
and Module Guide.  The full documentation and implementation can be
found at 
\href{https://github.com/smiths/caseStudies/tree/master/CaseStudies/ssp}
{the GitHub repository for the project}.

% ---------------------------------------------------------------- %
% ------------------------ NOTATION ------------------------------ %
% ---------------------------------------------------------------- %

\section{Notation}

The structure of the MIS for modules comes from \citet{HoffmanAndStrooper1995},
with the addition that template modules have been adapted from
\cite{GhezziEtAl2003}.  The mathematical notation comes from Chapter 3 of
\citet{HoffmanAndStrooper1995}.  For instance, the symbol $\coloneqq$ is used 
for a multiple assignment statement and conditional rules follow the form $(c_1
\Rightarrow r_1 | c_2 \Rightarrow r_2 | \dots | c_n \Rightarrow r_n )$. For 
quantifiers, this document uses the word ``with'' to specify constraints on the 
bound variable.

The following table summarizes the primitive data types used by \progname.

~\newline \renewcommand*{\arraystretch}{1.5}
\begin{tabular}{p{0.2\textwidth} p{0.1\textwidth} p{0.7\textwidth}}
  \hline \textbf{Data Type} & \textbf{Notation} & \textbf{Description}
  \\ \hline
  
  character & char & a single symbol or digit\\

  boolean & $\mathbb{B}$ & a value from the set \{true, false\}\\
  
  real & $\mathbb{R}$ & any number in $\left( -\infty, \infty \right)$\\
  
  integer & $\mathbb{Z}$ & a number without a fractional component in $\left( 
  -\infty, \infty \right)$\\
  \bottomrule
\end{tabular}

~\newline
The specification of \progname{} uses some derived data types: sequences, 
strings, and tuples. Sequences are ordered lists of elements of the same data 
type, denoted by brackets enclosing the type of the data elements. If a 
sequence has fixed dimensions, the notation of the type will include the 
dimensions in superscript. Strings are sequences of characters. Tuples contain 
a list of values, potentially of different types, each associated with a field 
identifier. When a tuple is referenced in this document, a link to an appendix 
section that specifies the fields of the tuple will be provided. In addition, 
\progname \ uses functions, which are defined by the data types of their inputs 
and outputs. Local functions are described by giving their type signature 
followed by their specification.

% ---------------------------------------------------------------- %
% ------------------------ ALGORITHM ----------------------------- %
% ---------------------------------------------------------------- %

\section{Numerical Algorithms}

\subsection*{Morgenstern-Price (Section \ref{sec:MPMod})}
The non-linear nature of the systems of equations in the Morgenstern-Price 
solver algorithm requires that the equations for
the factor of safety (IM\ref{SRS-IM_FS}), the interslice normal-to-shear force 
ratio (IM\ref{SRS-IM_Lambda}), and the interslice normal forces 
(IM\ref{SRS-IM_E}) are solved iteratively, with an initial guess for two of the 
values, typically the factor of safety and interslice normal-to-shear force 
ratio.

\subsection*{Genetic Algorithm (Section \ref{sec:GenAlgMod})}
\progname{} uses a genetic algorithm to find the coordinates of the
critical slip surface vertices that minimize the factor of safety, as described 
in IM\ref{SRS-IM_Min}. The genetic algorithm generates a set of initial 
potential slip surfaces, and subsequent generations are created by merging and 
mutating slip surfaces with low factors of safety from the previous generation. 
The minimum factor of safety after several generations is assumed to correspond 
to the critical slip surface.

\bmac{This section is not on the template. I've left it in for now because the 
information does seem useful, but maybe this is not the right place for it? 
Maybe this should go to an appendix?}

% ---------------------------------------------------------------- %
% --------------------- MODULE DECOMPOSITION --------------------- %
% ---------------------------------------------------------------- %

\section{Module Decomposition}

The following table is taken directly from the Module Guide document for this 
project.

\begin{table}[h!]
	\centering
	\begin{tabular}{p{0.3\textwidth} p{0.6\textwidth} }
		\toprule
		\textbf{Level 1} & \textbf{Level 2} \\
		\midrule
		
		{Hardware-Hiding} & ~ \\
		\midrule
		
		\multirow{8}{0.3\textwidth}{Behaviour-Hiding} &
		Control \\
		& Input \\
		& Output \\
		& Genetic Algorithm \\
		& Kinematic Admissibility \\
		& Slip Weighting \\
		& Slip Slicing \\
		& Morgenstern-Price Calculation \\
		& Slice Property Calculation \\
		\midrule
		
		\multirow{3}{0.3\textwidth}{Software Decision} &
		Sequence Data Structure \\
		& Random Number Generation \\
		& Plotting \\
		\bottomrule
		
	\end{tabular}
	\caption{Module Hierarchy}
	\label{Table:Decomp}
\end{table}

% ---------------------------------------------------------------- %
% --------------------- CONTROL MODULE --------------------------- %
% ---------------------------------------------------------------- %

\section{MIS of the Control Module}

\subsection{Module}
Control

\subsection{Uses}

Input (Section \ref{sec:InputMod}), Output (Section \ref{sec:OutputMod}), 
GenAlg (Section \ref{sec:GenAlgMod}), Sequence (Section~\ref{sec:SequenceData})

\subsection{Syntax}

\subsubsection{Exported Constants}
N/A

\subsubsection{Exported Data Types}
N/A

\subsubsection{Exported Access Programs}

\begin{center}
\renewcommand*{\arraystretch}{1.5}
\begin{tabular} {p{0.18\textwidth}  p{0.15\textwidth}  p{0.15\textwidth} 
p{0.45\textwidth} } \hline 
\textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions} \\ \hline

  Control & string & - & - \\ \hline
\end{tabular}
\end{center}

\subsection{Semantics}

\subsubsection{State Variables}

N/A

\subsubsection{Environment Variables}

N/A

\subsubsection{Assumptions}

The access program is called with a string parameter.

\subsubsection{Access Routine Semantics}

control(\textit{fname}):
\begin{itemize}
	\item transition: 
	\begin{itemize}
		\item[] Modifies the state of the Input Module, Genetic Algorithm 
		Module, and Output Module.
	\end{itemize}
\end{itemize}

\subsubsection{Local Functions}

N/A

% ---------------------------------------------------------------- %
% ---------------------- INPUT MODULE ---------------------------- %
% ---------------------------------------------------------------- %

\section{MIS of the Input Module} \label{sec:InputMod}

\subsection{Module}
Input

\subsection{Uses}
Sequence (Section~\ref{sec:SequenceData})

\subsection{Syntax}

\subsubsection{Exported Constants}
N/A

\subsubsection{Exported Data Types}
\renewcommand*{\arraystretch}{1.5}
\begin{longtable}{p{0.14\textwidth} c p{0.8\textwidth}}
	coord &=& tuple of (x : $\mathbb{R}$, y : $\mathbb{R}$) \\
	coords &=& [coord] \\
	paramsLayers &=& tuple of (strat : coords, phi : $\mathbb{R}$, coh : 
	$\mathbb{R}$, gam : $\mathbb{R}$, gams : $\mathbb{R}$) 
	(Appendix~\ref{Tbl:LayerParam})\\
	paramsPiez &=& tuple of (piez : coords, gamw : $\mathbb{R}$) 
	(Appendix~\ref{Tbl:PiezParam}) \\
	paramsSearch &=& tuple of (Xext, Xetr, Ylim : 
	[$\mathbb{R}$]\textsuperscript{1x2}) (Appendix~\ref{Tbl:SearchParam}) \\
	paramsSoln &=& tuple of (ltor, ftype, evnslc, cncvu, obtu : 
	$\mathbb{B}$) (Appendix~\ref{Tbl:SolnParam}) \\
\end{longtable}

\subsubsection{Exported Access Programs}

\begin{center}
\renewcommand*{\arraystretch}{1.5}
\begin{tabular}{p{0.18\textwidth}  p{0.15\textwidth}  p{0.15\textwidth}  
p{0.45\textwidth} } \hline 

  \textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions} \\ \hline

   load\_params & string & - & 
   fileNotExist, badFileExtension, unexpectedInput  \\
   
   verify\_params & - & - & 
   badSlopeGeometry, badEffAngleFriction, badCohesion, badDryUnitWeight, 
   badSatUnitWeight, badPiezGeometry, badWatUnitWeight \\
   
   strat & - & coords & - \\
   slopeX & - & [$\mathbb{R}$] & - \\
   slopeY & - & [$\mathbb{R}$] & - \\
   phi & - & $\mathbb{R}$ & - \\
   coh & - & $\mathbb{R}$ & - \\
   gam & - & $\mathbb{R}$ & - \\
   gams & - & $\mathbb{R}$ & - \\
   piez & - & coords & - \\
   piezX & - & [$\mathbb{R}$] & - \\
   piezY & - & [$\mathbb{R}$] & - \\
   gamw & - & $\mathbb{R}$ & - \\
   Xext & - & [$\mathbb{R}$]\textsuperscript{1x2} & - \\
   Xetr & - & [$\mathbb{R}$]\textsuperscript{1x2} & - \\
   Ylim & - & [$\mathbb{R}$]\textsuperscript{1x2} & - \\
   ltor & - & $\mathbb{B}$ & - \\
   ftype & - & $\mathbb{B}$ & - \\
   evnslc & - & $\mathbb{B}$ & - \\
   cncvu & - & $\mathbb{B}$ & - \\
   obtu & - & $\mathbb{B}$ & - \\
   \hline

\end{tabular}
\end{center}

\subsection{Semantics}

\subsubsection{State Variables}

\textit{slope} : paramsLayers\\
\textit{piez} : paramsPiez\\
\textit{search} : paramsSearch\\
\textit{soln} : paramsSoln\\

\subsubsection{Environment Variables}

\textit{in\_file} : String
\begin{itemize}
	\item \textit{in\_file} represents a file stored in the file system of the 
	hardware running \progname{}. \\
\end{itemize}

\subsubsection{Assumptions}
\begin{itemize}
	\item load\_params is called before any of the other access programs.
	
	\item The guesses for potential minimum and maximum $x$ and $y$ values of 
	the critical slip surface, as described in \textit{in\_file}, lie within 
	the boundaries of the given slope geometry.
\end{itemize}

\subsubsection{Access Routine Semantics}

load\_params(\textit{fname}):
\begin{itemize}
	\item transition:
	\begin{itemize}
		\item[] \textit{slope}, \textit{piez}, 
		\textit{search}, 
		\textit{soln} $\coloneqq$  \textit{slope'}, 
		\textit{piez'}, \textit{search'}, 
		\textit{soln'}\\ 
		where \textit{slope'}, 
		\textit{piez'}, \textit{search'}, and 
		\textit{soln'}
		are populated based on the contents of \textit{in\_file}.
	\end{itemize}

	\item exceptions:
	\begin{itemize}
		\item[] \textit{exc} $\coloneqq$ (\textit{fname} does not exist in file 
		system $\Rightarrow$ fileNotExist\\
		$|$ \textit{fname}[($|$\textit{fname}$|$ - 5)..($|$\textit{fname}$|$ - 
		1)] = ``.out'' $\Rightarrow$ badFileExtension\\
		$|$ \textit{in\_file} is not formatted correctly $\Rightarrow$ 
		unexpectedInput)
	\end{itemize}
\end{itemize}

\noindent verify\_params():
\begin{itemize}
	\item exceptions:
	\begin{itemize}
		\item[] \textit{exc} $\coloneqq$ ($\lnot (\forall i \in 
		[0..|slope.strat|-2])$($slope.strat[i].x -\\ 
		slope.strat[i+1].x \leq 0)$ 
		$\Rightarrow$ badSlopeGeometry\\
		$|$ $\lnot (0 < slope.phi < 90)$ $\Rightarrow$ 
		badEffAngleFriction\\
		$|$ $\lnot (0 < slope.coh)$ $\Rightarrow$ 
		badCohesion\\
		$|$ $\lnot (0 < slope.gam)$ $\Rightarrow$ 
		badDryUnitWeight\\
		$|$ $\lnot (0 < slope.gams)$ $\Rightarrow$ 
		badSatUnitWeight\\
		$|$ $\lnot (\forall i \in 
		[0..|piez.piez|-2])$($piez.piez[i].x -\\ 
		piez.piez[i+1].x \leq 0)$\\ $\lor piez.piez[0].x \neq 
		slope.strat[0].x$ \\$\lor 
		piez.piez[|piez.piez|-1].x$\\ $\neq 
		slope.strat[|slope.strat|-1].x$ $\Rightarrow$ 
		badPiezGeometry)\\
	\end{itemize}
\end{itemize}

\noindent strat():
\begin{itemize}
	\item output:
	\begin{itemize}
		\item[] \textit{out} $\coloneqq$ \textit{slope.strat}\\
	\end{itemize}
\end{itemize}

\noindent slopeX():
\begin{itemize}
	\item output:
	\begin{itemize}
		\item[] \textit{out} $\coloneqq$ $slope.strat[0].x || 
		slope.strat[1].x ||$\\$ \dots || slope.strat[| 
		slope.strat|-1].x$\\
	\end{itemize}
\end{itemize}

\noindent slopeY():
\begin{itemize}
	\item output:
	\begin{itemize}
		\item[] \textit{out} $\coloneqq$ $slope.strat[0].y || 
		slope.strat[1].y ||$\\$ \dots || slope.strat[| 
		slope.strat|-1].y$\\
	\end{itemize}
\end{itemize}

\noindent phi():
\begin{itemize}
	\item output:
	\begin{itemize}
		\item[] \textit{out} $\coloneqq$ \textit{slope.phi}\\
	\end{itemize}
\end{itemize}

\noindent coh():
\begin{itemize}
	\item output:
	\begin{itemize}
		\item[] \textit{out} $\coloneqq$ \textit{slope.coh}\\
	\end{itemize}
\end{itemize}

\noindent gam():
\begin{itemize}
	\item output:
	\begin{itemize}
		\item[] \textit{out} $\coloneqq$ \textit{slope.gam}\\
	\end{itemize}
\end{itemize}

\noindent gams():
\begin{itemize}
	\item output:
	\begin{itemize}
		\item[] \textit{out} $\coloneqq$ \textit{slope.gams}\\
	\end{itemize}
\end{itemize}

\noindent piez():
\begin{itemize}
	\item output:
	\begin{itemize}
		\item[] \textit{out} $\coloneqq$ \textit{piez.piez}\\
	\end{itemize}
\end{itemize}

\noindent piezX():
\begin{itemize}
	\item output:
	\begin{itemize}
		\item[] \textit{out} $\coloneqq$ $piez.piez[0].x || 
		piez.piez[1].x ||$\\$ \dots || piez.piez[| 
		piez.piez|-1].x$\\
	\end{itemize}
\end{itemize}

\noindent piezY():
\begin{itemize}
	\item output:
	\begin{itemize}
		\item[] \textit{out} $\coloneqq$ $piez.piez[0].y || 
		piez.piez[1].y ||$\\$ \dots || piez.piez[| 
		piez.piez|-1].y$\\
	\end{itemize}
\end{itemize}

\noindent gamw():
\begin{itemize}
	\item output:
	\begin{itemize}
		\item[] \textit{out} $\coloneqq$ \textit{piez.gamw}\\
	\end{itemize}
\end{itemize}

\noindent Xext():
\begin{itemize}
	\item output:
	\begin{itemize}
		\item[] \textit{out} $\coloneqq$ \textit{search.Xext}\\
	\end{itemize}
\end{itemize}

\noindent Xetr():
\begin{itemize}
	\item output:
	\begin{itemize}
		\item[] \textit{out} $\coloneqq$ \textit{search.Xetr}\\
	\end{itemize}
\end{itemize}

\noindent Ylim():
\begin{itemize}
	\item output:
	\begin{itemize}
		\item[] \textit{out} $\coloneqq$ \textit{search.Ylim}\\
	\end{itemize}
\end{itemize}

\noindent ltor():
\begin{itemize}
	\item output:
	\begin{itemize}
		\item[] \textit{out} $\coloneqq$ \textit{soln.ltor}\\
	\end{itemize}
\end{itemize}

\noindent ftype():
\begin{itemize}
	\item output:
	\begin{itemize}
		\item[] \textit{out} $\coloneqq$ \textit{soln.ftype}\\
	\end{itemize}
\end{itemize}

\noindent evnslc():
\begin{itemize}
	\item output:
	\begin{itemize}
		\item[] \textit{out} $\coloneqq$ \textit{soln.evnslc}\\
	\end{itemize}
\end{itemize}

\noindent cncvu():
\begin{itemize}
	\item output:
	\begin{itemize}
		\item[] \textit{out} $\coloneqq$ \textit{soln.cncvu}\\
	\end{itemize}
\end{itemize}

\noindent obtu():
\begin{itemize}
	\item output:
	\begin{itemize}
		\item[] \textit{out} $\coloneqq$ \textit{soln.obtu}\\
	\end{itemize}
\end{itemize}

\subsubsection{Local Functions}

N/A

% ---------------------------------------------------------------- %
% -------------------- OUTPUT MODULE ----------------------------- %
% ---------------------------------------------------------------- %

\section{MIS of the Output Module} \label{sec:OutputMod}

\subsection{Module}
Output

\subsection{Uses}

Sequence (Section~\ref{sec:SequenceData}), Plot (Section~\ref{sec:Plotting})

\subsection{Syntax}

\subsubsection{Exported Constants}
N/A

\subsubsection{Exported Data Types}
N/A

\subsubsection{Exported Access Programs}

\begin{center}
\renewcommand*{\arraystretch}{1.5}
\begin{tabular} {p{0.18\textwidth}  p{0.15\textwidth}  p{0.15\textwidth} 
p{0.45\textwidth} } \hline 
\textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions} \\ \hline
	
verify\_output & $\mathbb{R}$ & - & negativeFS \\
output & $\mathbb{R}$, coords, coords, coords, string & - & - \\ \hline
\end{tabular}
\end{center}

\subsection{Semantics}

\subsubsection{State Variables}
N/A

\subsubsection{Environment Variables}

\textit{out\_file} : String
\begin{itemize}
	\item \textit{out\_file} represents a file stored in the file system of the 
	hardware running \progname{}. \\
\end{itemize}

\textit{screen} : [$\mathbb{Z}$]
\begin{itemize}
	\item \textit{screen} represents the colour values for each pixel on the 
	screen of the hardware running \progname{}. \\
\end{itemize}

\subsubsection{Assumptions}
N/A

\subsubsection{Access Routine Semantics}
verify\_output(\textit{Fs}):
\begin{itemize}
	\item exceptions:
	\begin{itemize}
		\item[] \textit{exc} $\coloneqq$ $\textit{Fs} < 0$ 
		$\Rightarrow$ negativeFS\\
	\end{itemize}
\end{itemize}

\noindent output(\textit{Fs}, \textit{crit\_slip}, \textit{G}, \textit{X}, 
\textit{fname}):
\begin{itemize}
	\item transition:
	\begin{itemize}
		\item[] \textit{out\_file} is created at path $\textit{fname}$ $||$ 
		``.out''. The outputs of Xetr(), Xext(), Ylim(), ftype(), \textit{Fs}, 
		\textit{crit\_slip}, \textit{G}, and \textit{X} are written to 
		\textit{out\_file}.
		\textit{screen} is modified to display the outputs of 
		plot(\textit{crit\_slip.x}, \textit{crit\_slip.y}), plot(\textit{G.x}, 
		\textit{G.y}), and plot(\textit{X.x}, \textit{X.y}).  \\
	\end{itemize}
\end{itemize}

\subsubsection{Local Functions}
N/A

% ---------------------------------------------------------------- %
% -------------------- GEN ALG MODULE ------------------------- %
% ---------------------------------------------------------------- %

\section{MIS of the Genetic Algorithm Module} \label{sec:GenAlgMod}

\subsection{Module}
GenAlg

\subsection{Uses}

\subsubsection{Imported Access Programs}
Input (Section~\ref{sec:InputMod}), MorgPriceSolver (Section \ref{sec:MPMod}), 
Slicer (Section \ref{sec:SlicerMod}), KinAdm (Section \ref{sec:KinAdmMod}), 
SlipWeighter (Section \ref{sec:WeightMod}), Sequence 
(Section~\ref{sec:SequenceData}), Rand (Section~\ref{sec:Random})

\subsection{Syntax}

\subsubsection{Exported Constants}
MIN\_GENS = 100\\
NUM\_SLIPS = 20\\
REL\_DIFF = 0.00005\\

\subsubsection{Exported Data Types}
\renewcommand*{\arraystretch}{1.5}
\begin{longtable}{p{0.14\textwidth} c p{0.8\textwidth}}
	slip &=& tuple of (surf : coords, Fs : $\mathbb{R}$, G : coords, X : 
	coords, wt : $\mathbb{R}$) \\
	slips &=& [slip] \\
\end{longtable}

\subsubsection{Exported Access Programs}

\begin{center}
	\renewcommand*{\arraystretch}{1.5}
	\begin{tabular} {p{0.18\textwidth}  p{0.15\textwidth}  p{0.15\textwidth} 
			p{0.45\textwidth} } \hline 
		\textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions} \\ 
		\hline
		
		genetic\_alg & - & $\mathbb{R}$, coords, coords, coords & - \\ \hline
	\end{tabular}
\end{center}

\subsection{Semantics}

\subsubsection{State Variables}
N/A

\subsubsection{Environment Variables}
N/A

\subsubsection{Assumptions}
N/A

\subsubsection{Access Routine Semantics}
genetic\_alg():
\begin{itemize}
	\item output:
	\begin{itemize}
	\item[] \textit{out} $\coloneqq$ slipWeighter(\textit{MSlip}, 
	\textit{slip\_surfs})[0].surf, slipWeighter(\textit{MSlip}, 
	\textit{slip\_surfs})[0].Fs, slipWeighter(\textit{MSlip}, 
	\textit{slip\_surfs})[0].G, and slipWeighter(\textit{MSlip}, 
	\textit{slip\_surfs})[0].X, where \textit{slip\_surfs}, of type slips, is 
	developed by:
	\begin{itemize}
		\item using rand to randomly generate coordinates for NUM\_SLIPS 
		potential slip surfaces, where the entry and exit x-coordinate for each 
		slip surface are computed according to \textit{generate\_slips(Xetr)} 
		and \textit{generate\_slips(Xext)}. Corresponding y-coordinates are 
		determined by interpolating on the slope geometry.
		\item using kinAdm to verify that the geometry of each potential slip 
		surface is physically realizable. If any are not, new slip surfaces are 
		randomly generated until NUM\_SLIPS valid slip surfaces have been 
		generated,
		\item using slicer to redefine each slip surface's coordinates based on 
		the desired number of slices
		\item using morgPrice to determine the \textit{Fs}, \textit{G}, and 
		\textit{X} fields of each slip 
		surface
		\item using slipWeighter to determine the \textit{wt} field of each 
		slip surface
		\item using rand to generate a new pool of NUM\_SLIPS slip surfaces by 
		applying crossovers and mutations to the previous generation, with the 
		more highly-weighted members having a greater likelihood of 
		contributing to the subsequent generations
		\item applying kinAdm, slicer, morgPrice, and slipWeighter to the new 
		generation
		\item repeating until at least MIN\_GENS have occured and the relative 
		difference between subsequent generations is less than REL\_DIFF.
	\end{itemize}
	\end{itemize}
\end{itemize}

\subsubsection{Local Functions}
generate\_slips() : 
\begin{equation*}
generate\_slips(Xrange) = (Xrange[0] + rand()*(Xrange[1] - Xrange[0]))
\end{equation*}

% ---------------------------------------------------------------- %
% -------------------- KIN ADM MODULE ---------------------------- %
% ---------------------------------------------------------------- %

\section{MIS of the Kinematic Admissibility
	Module} \label{sec:KinAdmMod}

\subsection{Module}
KinAdm

\subsection{Uses}
Input (Section~\ref{sec:InputMod}), Sequence (Section~\ref{sec:SequenceData})

\subsection{Syntax}

\subsubsection{Exported Constants}
N/A

\subsubsection{Exported Data Types}
N/A

\subsubsection{Exported Access Programs}

\begin{center}
	\renewcommand*{\arraystretch}{1.5}
	\begin{tabular} {p{0.18\textwidth}  p{0.15\textwidth}  p{0.15\textwidth} 
			p{0.45\textwidth} } \hline 
		\textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions} \\ 
		\hline
		
		kinAdm & slip & $\mathbb{B}$ & - \\ \hline
		
	\end{tabular}
\end{center}

\subsection{Semantics}

\subsubsection{State Variables}
N/A

\subsubsection{Environment Variables}
N/A

\subsubsection{Assumptions}
\begin{itemize}
	\item The \textit{surf} field is populated for every member of the input 
	sequence of 
	slip data.
\end{itemize}

\subsubsection{Access Routine Semantics}
kinAdm(\textit{slip\_surf}):
\begin{itemize}
	\item output:
	\begin{itemize}
		\item[] \textit{out} $\coloneqq$ ( $\lnot(\forall i \in 
		[0..|\textit{slip\_surf}.\textit{surf}| - 
		2])(\textit{slip\_surf}.\textit{surf}[i].x - 
		\textit{slip\_surf}.\textit{surf}[i+1].x \leq 0) \\
		\lor \lnot is\_on\_slope(\textit{slip\_surf}.\textit{surf}[0])\\
		\lor \lnot 
		is\_on\_slope(\textit{slip\_surf}.\textit{surf}[|\textit{slip\_surf}.\textit{surf}-1|])\\
		\lor \lnot is\_in\_slope(\textit{slip\_surf}.\textit{surf})\\
		\lor (cncvu() \land 
		is\_concave\_up(\textit{slip\_surf}.\textit{surf}))\\
		\lor (obtu() \land 
		has\_no\_sharp\_angles(\textit{slip\_surf}.\textit{surf}))\\
		\Rightarrow false\\
		| else \Rightarrow true$)
	\end{itemize}
\end{itemize}

\bmac{Not sure if I'm allowed to use "else" here but don't know how else to 
express the "else" case succintly}

\subsubsection{Local Functions}
linSlope : coord $\times$ coord $\rightarrow$ $\mathbb{R}$\\
linSlope(\textit{point1}, \textit{point2}) = $\frac{point2.y - 
point1.y}{point2.x 
- point1.x}$\\

\noindent is\_on\_slope : coord $\rightarrow$ $\mathbb{B}$\\
is\_on\_slope(\textit{point}) = $(\exists i \in 
[0..|slope.strat|-1])(point = slope.strat[i])\\ \lor (\exists i 
\in [0..|slope.strat|-2])(point.y = linSlope(slope.strat[i], 
slope.strat[i+1])*point.x + 
\frac{slope.strat[i].y}{linSlope(slope.strat[i], 
slope.strat[i+1])*slope.strat[i].x}) $\\

\noindent is\_in\_slope : coords $\rightarrow$ $\mathbb{B}$
is\_in\_slope(\textit{surf}) = $(\forall i \in [1..|\textit{surf}|-2])((\forall 
j \in 
[0..|slope.strat|-2] \text{ with } slope.strat[j].x \leq \textit{surf}[i].x < 
slope.strat[j+1].x)(\textit{surf}[i].y < (slope.strat[j].y + 
(\textit{surf}[i].x - 
slope.strat[j].x)*linSlope(slope.strat[j], slope.strat[j+1]))))$\\

\noindent is\_concave\_up : coords $\rightarrow$ $\mathbb{B}$\\
is\_concave\_up(\textit{surf}) = $(\forall i \in 
[0..|\textit{surf}|-3])(linSlope(\textit{surf}[i+1], \textit{surf}[i+2]) \geq 
linSlope(\textit{surf}[i], 
\textit{surf}[i+1]))$\\

\noindent distance : coord $\times$ coord $\rightarrow$ $\mathbb{R}$\\
distance(\textit{point1}, \textit{point2}) = $\sqrt{(point1.x - point2.x)^2 + 
(point1.y - point2.y)^2}$\\

\noindent has\_no\_sharp\_angles : coords $\rightarrow$ $\mathbb{B}$\\
has\_no\_sharp\_angles(\textit{surf}) = $(\forall i \in 
[0..|\textit{surf}|-3])\\
(\arccos \frac{(distance(\textit{surf}[i], 
\textit{surf}[i+1]))^2 + 
(distance(\textit{surf}[i+1], \textit{surf}[i+2]))^2 - 
(distance(\textit{surf}[i], 
\textit{surf}[i+2]))^2}{2*distance(\textit{surf}[i], 
\textit{surf}[i+1])*distance(\textit{surf}[i+1], 
\textit{surf}[i+2])})$\\

% ---------------------------------------------------------------- %
% -------------------- SLIP WEIGHTING MODULE ------------------------- %
% ---------------------------------------------------------------- %

\section{MIS of the Slip Weighting
	Module} \label{sec:WeightMod}

\subsection{Module}
SlipWeighter

\subsection{Uses}
Sequence (Section~\ref{sec:SequenceData})

\subsection{Syntax}

\subsubsection{Exported Constants}
N/A

\subsubsection{Exported Data Types}
N/A

\subsubsection{Exported Access Programs}

\begin{center}
	\renewcommand*{\arraystretch}{1.5}
	\begin{tabular} {p{0.18\textwidth}  p{0.15\textwidth}  p{0.15\textwidth} 
			p{0.45\textwidth} } \hline 
		\textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions} \\ 
		\hline
		
		slipWeighter & slips & slips & - \\ \hline
	\end{tabular}
\end{center}

\subsection{Semantics}

\subsubsection{State Variables}
N/A

\subsubsection{Environment Variables}
N/A

\subsubsection{Assumptions}
\begin{itemize}
	\item The \textit{Fs} field is populated for every member of the input 
	sequence of 
	slip data.
\end{itemize}

\subsubsection{Access Routine Semantics}
slipWeighter(\textit{slip\_surfs}):
\begin{itemize}
	\item output:
	\begin{itemize}
		\item[] \textit{out} $\coloneqq$ \textit{slip\_surfs} sorted by their 
		\textit{Fs} field in ascending order and with the \textit{wt} field of 
		each member populated.
	\end{itemize}
\end{itemize}

\subsubsection{Local Functions}
N/A

% ---------------------------------------------------------------- %
% -------------------- SLICER MODULE ----------------------------- %
% ---------------------------------------------------------------- %

\section{MIS of the Slip Slicer Module} \label{sec:SlicerMod}

\subsection{Module}
Slicer

\subsection{Uses}
Sequence (Section~\ref{sec:SequenceData})

\subsection{Syntax}

\subsubsection{Exported Constants}
N/A

\subsubsection{Exported Data Types}
N/A

\subsubsection{Exported Access Programs}

\begin{center}
	\renewcommand*{\arraystretch}{1.5}
	\begin{tabular} {p{0.18\textwidth}  p{0.15\textwidth}  p{0.15\textwidth} 
			p{0.45\textwidth} } \hline 
		\textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions} \\ 
		\hline
		slicer & coords, $\mathbb{Z}$ & slip & - \\ \hline
		
	\end{tabular}
\end{center}

\subsection{Semantics}

\subsubsection{State Variables}
N/A

\subsubsection{Environment Variables}
N/A

\subsubsection{Assumption}
N/A

\subsubsection{Access Routine Semantics}
slicer(\textit{slip\_surf}, \textit{num\_slices}):
\begin{itemize}
	\item output:
	\begin{itemize}
		\item[] \textit{out} $\coloneqq$ ($\textit{evnslc} \Rightarrow$ 
		\textit{slip\_surf'} obtained by repeatedly applying 
		\textit{slip\_surf}[large\_segment(\textit{slip\_surf})] $||$ 
		midpoint(\textit{slip\_surf}[large\_segment(\textit{slip\_surf})], 
		\textit{slip\_surf}[large\_segment(\textit{slip\_surf})+1])
		$||$ \textit{slip\_surf}[large\_segment(\textit{slip\_surf})+1] until 
		$|\textit{slip\_surf'}| = \textit{num\_slices}$ \\
		$| \lnot \textit{evnslc} \Rightarrow$ \textit{slip\_surf'} such that 
		$\forall(i : \mathbb{Z} | i \in [0..|\textit{slip\_surf}|-2] : 
		\textit{slip\_surf'}[i*\frac{\textit{num\_slices}}
		{|\textit{slip\_surf}|-1}..(i+1)*\frac{\textit{num\_slices}}
		{|\textit{slip\_surf}|-1}] = subslice(\frac{\textit{num\_slices}}
		{|\textit{slip\_surf}|-1}, \textit{slip\_surf}[i], 
		\textit{slip\_surf}[i+1]))$
	\end{itemize}
\end{itemize}

\subsubsection{Local Functions}
large\_segment : coords $\rightarrow$ $\mathbb{Z}$\\
large\_segment(\textit{surf}) = \textit{index} such that\\
$\forall(i : \mathbb{Z} | i \in [0..|\textit{surf}|-2] : 
\textit{surf}[\textit{index}+1] - \textit{surf}[\textit{index}] \geq 
\textit{surf}[i+1] - \textit{surf}[i])$\\

\noindent midpoint : coord $\times$ coord $\rightarrow$ coord\\
midpoint(\textit{point1}, \textit{point2}) = $< \frac{point1.x + point2.x}{2}, 
\frac{point1.y + point2.y}{2} >$

\noindent subslice : int $\times$ coord $\times$ coord $\rightarrow$ coords
subslice(\textit{n}, \textit{point1}, \textit{point2}) = \textit{subslices} 
such that\\
$\forall(i : \mathbb{Z} | i \in [0..n] : subslices[i].x = point1.x + 
\frac{i}{n}*(point2.x - point1.x) \land subslices[i].y = point1.y + 
\frac{i}{n}*(point2.y - point1.y))$\\

% ---------------------------------------------------------------- %
% -------------------- MORG PRICE MODULE ------------------------- %
% ---------------------------------------------------------------- %

\section{MIS of the Morgenstern Price Solver Module} \label{sec:MPMod}

\subsection{Module}
MorgPriceSolver

\subsection{Uses}

Input (Section~\ref{sec:InputMod}), PropertySorter (Section 
\ref{sec:PropSortMod}), Sequence (Section~\ref{sec:SequenceData})

\subsection{Syntax}

\subsubsection{Exported Constants}
N/A

\subsubsection{Exported Data Types}
N/A

\subsubsection{Exported Access Programs}

\begin{center}
	\renewcommand*{\arraystretch}{1.5}
	\begin{tabular} {p{0.18\textwidth}  p{0.15\textwidth}  p{0.15\textwidth} 
			p{0.45\textwidth} } \hline 
		\textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions} \\ 
		\hline

  Morgenstern Price ~\newline Solver & Sequence; ~\newline struc;
  ~\newline struc; ~\newline struc; ~\newline struc & Real & Non
  Converging; ~\newline Spurious \textit{F\_MP} \\ \hline
\end{tabular}
\end{center}

\subsection{Semantics}

\subsubsection{Local Constants}
\renewcommand*{\arraystretch}{1.5}
\begin{longtable}{ p{0.2\textwidth}  p{0.8\textwidth}}
  \textit{F\_MinLim} : $\mathbb{R}$ & The minimum factor of safety
  value that the solution must be above to not be considered
  spurious. [\textit{F\_MinLim}=0.5]\\
  
  \textit{max\_iter} : $\mathbb{R}$ & The max number of iterations the
  algorithm will perform before the solution is considered non
  converging. [\textit{max\_iter}=20]\\

  \textit{eps\_F} : $\mathbb{R}$ & The value the absolute difference
  between the factor of safety calculated by the algorithm between
  consecutive iterations must be below for the answer to be considered
  converged. [\textit{eps\_F}=1E-6]\\

  \textit{eps\_Lam} : $\mathbb{R}$ & The value the absolute difference
  between the interslice normal to shear force ratio calculated by the
  algorithm between consecutive iterations must be below for the
  answer to be considered converged. [\textit{eps\_Lam}=1E-6]\\
\end{longtable}

\subsubsection{State Variables}

\renewcommand*{\arraystretch}{1.5}
\begin{longtable}{ p{0.2\textwidth}  p{0.8\textwidth}}
  \textit{Lam} : $\mathbb{R}$ & The interslice normal to shear force
  ratio. From IM\ref{SRS-IM_Lambda} of the SRS. \\

  \textit{E\_force} : $[\mathbb{R}]^{1,n+1}$ & Sequence of the value
  of the interslice normal force exerted between slices. A value for
  each interslice, including ends. Sequence length value \textit{n} is
  defined by the input \textit{evalslip}. From IM\ref{SRS-IM_E} of the
  SRS. \\

  \textit{Del\_F} : $\mathbb{R}$ & The difference between the factor
  of safety of the current iteration and the previous iteration. When
  converged the value will not be changing and \textit{Del\_F} will be
  small.\\

  \textit{Del\_Lam} : $\mathbb{R}$ & The difference between the
  interslice normal to shear force ratio of the current iteration and
  the previous iteration. When converged the value will not be
  changing and \textit{Del\_Lam} will be small.\\ 
\end{longtable}
 
\subsubsection{Access Routine Semantics}

\textbf{Input:} 
\renewcommand*{\arraystretch}{1.5}
\begin{longtable}{p{0.3\textwidth} p{0.7\textwidth}}
  \textit{evalslip} : $[\mathbb{R}]^{2,n+1}$ & Vertex coordinates for
  the slip surface being evaluated. Identifies shape of the slope, and
  slice points. Sequence length value of \textit{n} is defined by the
  Slicer module (section \ref{sec:SlicerMod}).\\

  \textit{params\_layers} : struc\_layers & (Appendix
  \ref{Tbl:LayerParam})\\

  \textit{piez} : struc\_piez & (Appendix
  \ref{Tbl:PiezParam})\\

  \textit{soln} : struc\_soln & (Appendix
  \ref{Tbl:SolnParam})\\

  \textit{params\_load} : struc\_load & (Appendix
  \ref{Tbl:LoadForceParam})
\end{longtable}

\noindent \textbf{Exceptions:} ~\newline\noindent A solution which
does not converge to a consistent solution, where the change in
calculated factor of safety (\textit{Del\_F}) between iterations is
less than \textit{eps\_F}, and the change in interslice normal to
shear force ratio (\textit{Del\_Lam}) is less than \textit{eps\_Lam},
in less than \textit{max\_iter} iterations will be considered non
converging exception case. A solution with a final calculated a factor
of safety less than \textit{F\_MinLim} will be considered a spurious
factor of safety exception case. Solutions that trigger these
exception cases will output a factor of safety (\textit{F\_MP}) of
1000.

~\newline\noindent \textbf{Output:}
\renewcommand*{\arraystretch}{1.5}
\begin{longtable}{p{0.15\textwidth} p{0.85\textwidth}}
  \textit{F\_MP} : $\mathbb{R}$ & The factor of safety of the slope,
  as calculated by the Morgenstern Price solution method, measuring
  the stability of the slope. From IM\ref{SRS-IM_FS} of the SRS.\\
\end{longtable}

% ---------------------------------------------------------------- %
% -------------------- PROPERTY SORTER MODULE -------------------- %
% ---------------------------------------------------------------- %

\section{MIS of the Property Sorter Module} \label{sec:PropSortMod}

\subsection{Module} 
PropertySorter

\subsection{Uses}
Input (Section~\ref{sec:InputMod}), Sequence (Section~\ref{sec:SequenceData})

\subsection{Syntax}

\subsubsection{Exported Constants}
N/A

\subsubsection{Exported Data Types}
N/A

\subsubsection{Exported Access Programs}

\begin{center}
	\renewcommand*{\arraystretch}{1.5}
	\begin{tabular} {p{0.18\textwidth}  p{0.15\textwidth}  p{0.15\textwidth} 
			p{0.45\textwidth} } \hline 
		\textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions} \\ 
		\hline

  Property Sorter & Sequence; ~\newline struc; ~\newline
  struc & struc; ~\newline struc; ~\newline struc; ~\newline struc &
  None \\ \hline
\end{tabular}
\end{center}

\subsection{Semantics}

\subsubsection{Access Routine Semantics}
\textbf{Input:}
\renewcommand*{\arraystretch}{1.5}
\begin{longtable}{p{0.3\textwidth} p{0.7\textwidth}}
  \textit{evalslip} : $[\mathbb{R}]^{1,n}$ & Sequence of vertex
  coordinates for the slip surface being evaluated. Identifies shape
  of the slope, and slice points. Sequence length value \textit{n} is
  defined by the Slicer module (section \ref{sec:SlicerMod}).  \\

  \textit{params\_layers} : struc\_layers & (Appendix
  \ref{Tbl:LayerParam}) \\
  
  \textit{piez} : struc\_piez & (Appendix \ref{Tbl:PiezParam})
  \\
\end{longtable}

\noindent \textbf{Exceptions:} ~\newline\noindent There are no
potential exceptions for Property Sorter.

~\newline\noindent \textbf{Output:}
\renewcommand*{\arraystretch}{1.5}
\begin{longtable}{p{0.4\textwidth} p{0.6\textwidth}}
  \textit{params\_internalForce} : struc\_intForce & (Appendix
  \ref{Tbl:ForceParam})\\
  
  \textit{params\_angles} : struc\_angles & (Appendix \ref{Tbl:AngleParam})\\

  \textit{params\_soilInterior} : struc\_soilInt & (Appendix
  \ref{Tbl:SoilIntParam})\\

  \textit{params\_soilBase} : struc\_soilBase & (Appendix
  \ref{Tbl:SoilBaseParam})\\
\end{longtable}


% ---------------------------------------------------------------- %
% ---------------- SEQUENCE DATA STRUCTURE MODULE ---------------- %
% ---------------------------------------------------------------- %

\section{MIS of the Sequence Data Structure Module} \label{sec:SequenceData}

\subsection{Module}
Sequence

\subsection{Uses}

N/A

\subsection{Syntax}

\subsubsection{Exported Constants}
N/A

\subsubsection{Exported Data Types}

[T] = sequence of T, where T is any type

\subsubsection{Exported Access Programs}

\begin{center}
	\renewcommand*{\arraystretch}{1.5}
	\begin{tabular} {p{0.18\textwidth}  p{0.15\textwidth}  p{0.15\textwidth} 
			p{0.45\textwidth} } \hline 
		\textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions} \\ 
		\hline
		
		[\_] & Any number of values of type T & [T] & - \\ 
		\_(\_) & [T], $\mathbb{Z}$ & T & \\
		\_(\_:\_) & [T], $\mathbb{Z}$, $\mathbb{Z}$ & [T] & - \\\hline
	\end{tabular}
\end{center}

\subsection{Semantics}

\subsubsection{State Variables}

N/A

\subsubsection{Environment Variables}

N/A

\subsubsection{Assumptions}

N/A

\subsubsection{Access Routine Semantics}

[\_](Any number of values):
\begin{itemize}
	\item output: 
	\begin{itemize}
		\item[] \textit{out} $\coloneqq$ A sequence containing the arguments 
		passed to the function.
	\end{itemize}
\end{itemize}

\noindent \_(\_)(\textit{list}, \textit{int}):
\begin{itemize}
	\item output: 
	\begin{itemize}
		\item[] \textit{out} $\coloneqq$ $list$[\textit{int}]	
	\end{itemize}
\end{itemize}

\noindent \_(\_:\_)(\textit{list}, \textit{int1}, \textit{int2}):
\begin{itemize}
	\item output: 
	\begin{itemize}
		\item[] \textit{out} $\coloneqq$ $list$[\textit{int1}..\textit{int2}]
	\end{itemize}
\end{itemize}

\subsubsection{Local Functions}

N/A

\subsubsection{Considerations}
This module is the sequence data type and operations on sequences implemented 
by Matlab.

% ---------------------------------------------------------------- %
% ------------------------- PLOTTING MODULE ---------------------- %
% ---------------------------------------------------------------- %

\section{MIS of the Plotting Module} \label{sec:Plotting}

\subsection{Module}
Plot

\subsection{Uses}

N/A

\subsection{Syntax}

\subsubsection{Exported Constants}
N/A

\subsubsection{Exported Data Types}

N/A

\subsubsection{Exported Access Programs}

\begin{center}
	\renewcommand*{\arraystretch}{1.5}
	\begin{tabular} {p{0.18\textwidth}  p{0.15\textwidth}  p{0.15\textwidth} 
			p{0.45\textwidth} } \hline 
		\textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions} \\ 
		\hline
		
		plot & [$\mathbb{R}$], [$\mathbb{R}$] & - & - \\ \hline
	\end{tabular}
\end{center}

\subsection{Semantics}

\subsubsection{State Variables}

N/A

\subsubsection{Environment Variables}

\textit{screen} : [$\mathbb{Z}$]
\begin{itemize}
	\item \textit{screen} represents the colour values for each pixel on the 
	screen of the hardware running \progname{}. \\
\end{itemize}

\subsubsection{Assumptions}

N/A

\subsubsection{Access Routine Semantics}

plot(\textit{x}, \textit{y}):
\begin{itemize}
	\item transition: 
	\begin{itemize}
		\item[] Modifies \textit{screen} to display a plot with $x$ on the 
		horizontal axis and $y$ on the vertical axis.
	\end{itemize}
\end{itemize}

\subsubsection{Local Functions}

N/A

\subsubsection{Considerations}
This module is the plot function implemented by Matlab.

% ---------------------------------------------------------------- %
% ---------------- RANDOM NUMBER GENERATION MODULE --------------- %
% ---------------------------------------------------------------- %

\section{MIS of the Random Number Generation Module} \label{sec:Random}

\subsection{Module}
Rand

\subsection{Uses}

N/A

\subsection{Syntax}

\subsubsection{Exported Constants}
N/A

\subsubsection{Exported Data Types}

N/A

\subsubsection{Exported Access Programs}

\begin{center}
	\renewcommand*{\arraystretch}{1.5}
	\begin{tabular} {p{0.18\textwidth}  p{0.15\textwidth}  p{0.15\textwidth} 
			p{0.45\textwidth} } \hline 
		\textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions} \\ 
		\hline
		
		rand & - & $\mathbb{R}$ & - \\ \hline
	\end{tabular}
\end{center}

\subsection{Semantics}

\subsubsection{State Variables}

N/A

\subsubsection{Environment Variables}

N/A

\subsubsection{Assumptions}

N/A

\subsubsection{Access Routine Semantics}

rand():
\begin{itemize}
	\item output: 
	\begin{itemize}
		\item[] \textit{out} $coloneqq$ A random number in the interval (0,1).
	\end{itemize}
\end{itemize}

\subsubsection{Local Functions}

N/A

\subsubsection{Considerations}
This module is the rand function implemented by Matlab.

\newpage

\bibliographystyle {plainnat}
\bibliography {../../../refs/References}

\newpage

% ---------------------------------------------------------------- %
% ------------------------  APPENDIX --------------------------%
% ---------------------------------------------------------------- %
\section{Appendix}

\subsection{Parameter Tables} \label{sec:ParamTables}

\subsubsection{Layer Parameters} \label{Tbl:LayerParam}
\noindent
The elements in the structure of the containers for the parameters of
different slope layers. Assumed that the parameters will be entered
such that sequence progresses from the uppermost stratigraphic layer
at the first index, to the lowest stratigraphic layer at the last
index. $nlayer$ refers to the number of soil layers in the slope, and
is defined by the input file.

\begin{center}
\begin{longtable}{ p{0.25\textwidth}
    p{0.75\textwidth}}\hline

  \textbf{Parameter} & \textbf{Description}\\ \hline

  \textit{strat} : $[[\mathbb{R}]^{2,\text{nvtx}}]^{1,\text{nlayer}}$
  & Sequence of coordinate sequences describing the vertexes of each
  layer. The value \textit{nvtx} is defined by the input file, and can
  be different for each sequence.\\

  \textit{phi} : $[\mathbb{R}]^{1,\text{nlayer}}$ & Sequence of the
  effective angle of friction for each stratigraphic layer.\\

  \textit{coh} : $[\mathbb{R}]^{1,\text{nlayer}}$ & Sequence of the
  effective cohesion for each stratigraphic layer.\\

  \textit{gam} : $[\mathbb{R}]^{1,\text{nlayer}}$ & Sequence of the dry
  unit weight of soil for each stratigraphic layer.\\

  \textit{gams} : $[\mathbb{R}]^{1,\text{nlayer}}$ & Sequence of the
  saturated unit weight of soil for each stratigraphic layer.\\

  \textit{E} : $[\mathbb{R}]^{1,\text{nlayer}}$ & Sequence of the
  Young's modulus for each stratigraphic layer.\\

  \textit{nu} : $[\mathbb{R}]^{1,\text{nlayer}}$ & Sequence of the
  poissons ratio for each stratigraphic layer. \\ \hline
\end{longtable}
\end{center}

\subsubsection{Piezometric Parameter} \label{Tbl:PiezParam}
\noindent
The elements in the structure for parameters relating to the
piezometric surface existing on the slope. $npz$ refers to the number
of vertexes describing the piezometric surface, and is defined by the
input file.

\begin{center}
\begin{longtable}{ p{0.2\textwidth}
    p{0.8\textwidth}}\hline 
  \textbf{Parameter} & \textbf{Description}\\ \hline

  \textit{piez} : $[\mathbb{R}]^{2,\text{npz}}$ & Sequence of vertex
  coordinates describing the geometry of the water table. If there is
  no water table than \textit{piez} is an empty array. \\

  \textit{gamw} : $\mathbb{R}$ & The unit weight of water. \\ \hline
\end{longtable}
\end{center}

\subsubsection{Search Range Parameters} \label{Tbl:SearchParam}
\noindent
The elements in the structure for parameters relating to the range of
coordinates the critical slip surface will be searched for in.

\begin{center}
\begin{tabular}{ p{0.2\textwidth}
    p{0.8\textwidth}}\hline 

  \textbf{Parameter} &
  \textbf{Description}\\ \hline

  Xext : $[\mathbb{R}]^{1,2}$ & Sequence of the range of $x$-ordinates
  that the exit point of the slip will be searched for in. Exit refers
  to the point of the slip at lower elevation that the slope mass will
  move towards during failure. \\

  Xent : $[\mathbb{R}]^{1,2}$ & Sequence of the range of $x$-ordinates
  that the entry point of the slip will be searched for in. Entry
  refers to the point of the slip at higher elevation that the slope
  mass will move away from during failure. \\

  Ylim : $[\mathbb{R}]^{1,2}$ & Sequence of range of $y$-ordinates
  that the slip will be searched for in. The larger value should be
  greater than the max $y$-ordinate of the slope. The smaller Ylim
  value is the deepest the slip surface is expected to descend
  to.\\ \hline
\end{tabular}
\end{center}

\subsubsection{Solution Parameters} \label{Tbl:SolnParam}
\noindent
The elements in the structure for parameters relating to method in
which the solution method will be approached.

\begin{center}
\begin{longtable}{ p{0.15\textwidth} 
    p{0.85\textwidth}}\hline 

  \textbf{Parameter} & \textbf{Description}\\ \hline

  ltor : $\mathbb{B}$ & Direction the slope is expected to
  experience failure in. If true than the side of the slope with a
  greater x-ordinate value is at a lower elevation. If false than the
  side of the slope with a greater x-ordinate is at a higher
  elevation.\\

  ftype : $\mathbb{B}$ & Switch between functions to use for
  interslice shear/normal inclination function. If true then the
  inclination function is a constant (Spencer's method). If false then
  the inclination function is a half-sine (standard Morgenstern Price
  method). \\

  evnslc : $\mathbb{B}$ & Switch between method of slicing a slip
  surface to when preparing for analysis. If true then slice slip
  surface into equal x-ordinate widths. If false then slice distance
  between vertices into even number of slices. \\

  cncvu : $\mathbb{B}$ & Switch for concave slip surface admissibility
  criterion. If true then an admissible slip surface must be concave
  upwards towards the surface. If false then an admissible slip
  surface does not need to pass this criterion.\\

  obtu : $\mathbb{B}$ & Switch for angle limit slip surface
  admissibility criterion. If true then an admissible slip surface
  must have all interior angles greater than a set limit. If false
  then an admissible slip surface does not need to pass this
  criterion.\\ \hline
\end{longtable}
\end{center}

\subsubsection{Internal Force Parameters} \label{Tbl:ForceParam}
\noindent
The elements in the structure for parameters relating to the forces
acting on a slice caused by the slope, and water in the slope acting
on itself. $n$ refers to the number of slices composing the evaluation
slip surface, and is defined by the Slicer module (section
\ref{sec:SlicerMod}).

\begin{center}
\begin{longtable}{ p{0.2\textwidth} 
    p{0.8\textwidth}}\hline 

  \textbf{Parameter} & \textbf{Description}\\ \hline

  Ub : $[\mathbb{R}]^{1,n}$ & Sequence of the force acting on the
  basal surface of a slice as a result of pore water pressure within
  the slice. Value for each slice. From DD\ref{SRS-DD_Ub} of the
  SRS.\\
  
  Ut : $[\mathbb{R}]^{1,n}$ & Sequence of the force acting on the
  upper surface of a slice as a result of pore water pressure standing
  water on the surface. Value for each slice. From DD\ref{SRS-DD_Ut}
  of the SRS.\\

  W : $[\mathbb{R}]^{1,n}$ & Sequence of the downward force acting on
  the slice caused by the mass of the slice and the force of
  gravity. Value for each slice. From DD\ref{SRS-DD_W} of the SRS.\\

  H : $[\mathbb{R}]^{1,n-1}$ & Sequence of the force acting into the
  interslice surfaces as a result of pore water pressure within the
  adjacent slices. Value for each interslice. From DD\ref{SRS-DD_H} of
  the SRS.\\
\end{longtable}
\end{center}

\subsubsection{Angle Parameters} \label{Tbl:AngleParam}
\noindent
The elements in the structure for parameters relating to the angles of
the slice surfaces. $n$ refers to the number of slices composing the
slip surface, and is defined by the input \textit{evalslip} given to
the Property Sorter module (section \ref{sec:PropSortMod}).

\begin{center}
\begin{longtable}{ p{0.3\textwidth}
    p{0.7\textwidth}}\hline 
  \textbf{Parameter} & \textbf{Description}\\ \hline

  Alpha : $[\mathbb{R}]^{1,n}$ & Sequence of the angle that the basal
  surface of the slice makes with the horizontal. Value for each
  slice. From DD\ref{SRS-DD_Angles} of the SRS.\\

  Beta : $[\mathbb{R}]^{1,n}$ & Sequence of the angle that the upper
  surface of the slice makes with the horizontal. Value for each
  slice. From DD\ref{SRS-DD_Angles} of the SRS.\\ \hline
\end{longtable}
\end{center}

\subsubsection{Soil Interslice Properties} \label{Tbl:SoilIntParam}
The elements in the structure for parameters relating to the soil
properties of the slope, as calculated at the interslice interfaces of
an evaluation slip. Calculation is based on the ratio of the interface
that is in different stratigraphic layers, and the values of the
effective angle of friction in the different layers. Interest is only
with the interior interslice interfaces therefore for a slope of $n$
slices, there will be $n-1$ interior interslice interfaces. The value
\textit{n} is defined by the input \textit{evalslip} given to the
Property Sorter module (section \ref{sec:PropSortMod}).


\begin{center}
\begin{longtable}{p{0.2\textwidth} p{0.8\textwidth}}
  \hline \textbf{Parameter} & \textbf{Description} \\ \hline
    
  \textit{phi\_IS} : $[\mathbb{R}]^{1,n-1}$ & Sequence of the vector
  of the effective angle of friction calculated at each interslice
  interface. \\

  \textit{coh\_IS} := $[\mathbb{R}]^{1,n-1}$ & Sequence of the vector
  of the effective cohesion calculated at each interslice interface.\\

  \textit{E\_IS} := $[\mathbb{R}]^{1,n-1}$ & Sequence of the vector of
  the Youngs modulus calculated at each interslice interface.\\

  \textit{nu\_IS} := $[\mathbb{R}]^{1,n-1}$ & Sequence of the vector
  of the Poisson ratio calculated at each interslice
  interface. \\ \hline
\end{longtable}
\end{center}

\subsubsection{Soil Base Properties} \label{Tbl:SoilBaseParam}
The elements in the structure for parameters relating to the soil
properties of the slope, as calculated at the basal surfaces of an
evaluation slip. Calculation is based on the ratio of the basal
surface that is in different stratigraphic layers, and the values of
the effective angle of friction in the different layers. An evaluation
slip of $n$ slices will have $n$ basal surfaces, and the value of
\textit{n} is defined by the input \textit{evalslip} given to
the Property Sorter module (section \ref{sec:PropSortMod}).


\begin{center}
\begin{longtable}{p{0.2\textwidth} p{0.8\textwidth}}
  \hline \textbf{Parameter} & \textbf{Description} \\ \hline

  \textit{phi\_Base} : $[\mathbb{R}]^{1,n}$ & Sequence of the vector
  of the effective angle of friction calculated at each slice basal
  surface in an evaluation slip.\\

  \textit{coh\_Base} : $[\mathbb{R}]^{1,n}$ & Sequence of the vector
  of the effective cohesion calculated at each slice basal surface in
  an evaluation slip.\\

  \textit{E\_Base} : $[\mathbb{R}]^{1,n}$ & Sequence of the vector of
  the Young's modulus calculated at each slice basal surface in an
  evaluation slip.\\

  \textit{nu\_Base} : $[\mathbb{R}]^{1,n}$ & Sequence of the vector of
  the Poisson ratio calculated at each slice basal surface in an
  evaluation slip.  \\ \hline
\end{longtable}
\end{center}

\end{document}
